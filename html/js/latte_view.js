


(function(define) {'use strict'
	define("latte_view/controller/commands/attrs.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		/**
			@example
				p (show:"{{status}}=='show'")
				{
					status:"show" 
				}
		*/
		(function() {
			var latte_lib = require('latte_lib');
			var Language = require('../../language');
			var forEachJSON = function(data, key, result) {
					for(var i in data) {
						
						if(latte_lib.isObject(data[i])) {
							var ckey = latte_lib.clone(key);
							ckey.push(i);
							forEachJSON(data[i], ckey, result);
						}else if(latte_lib.isArray(data[i])){
							var ckey = latte_lib.clone(key);
							ckey.push(i);
							forEachJSON(data[i], ckey, result);
						}else{
							var ckey = latte_lib.clone(key);
							ckey.push(i);
							result[ckey.join(".")] = data[i] != null ?data[i].toString(): "undefined";
							
		
						}
					}
				}
			var toJSON = function(data) {
		
				if(latte_lib.isObject(data)) {
					return JSON.stringify(data.toJSON());
				}else if(latte_lib.isString(data)){
					return '"' + data +'"'
				}else{
					return JSON.stringify(data);
				}
				
			}
			var attrs = ["top","bottom","left","right","width","height", "scrollTop"];
			this.after = function(data, view, controller) {
				attrs.forEach(function(attr) {
					var showValue = view.latte(attr);
					if(showValue) {
						var key1s = Language.stringRegExp(showValue, "{{", "}}");
						var doChange = function() {
							if(controller.isClose()) {
								return;
							}
							var text = showValue;
							var j = {};
							key1s.forEach(function(key) {
								j[key] = toJSON(data.get(key));
							});
							text = latte_lib.format.templateStringFormat(text, j);
							try {
								var att;
								eval('att =' + text);
								view[attr](att);
							}catch(e) {
								return;
							}
						};
						doChange();
						key1s.forEach(function(key) {
							controller.bind("data", key, function(value, oldValue) {
								doChange();
							});
						});
					}
				});
			}
		}).call(module.exports);
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/blankData.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		/**
			@example
				p (src:"{{path}}/{{filename}}")
				{
					path:"./html",
					filename: "./"
				}
		*/
		(function() {
			var latte_lib = require('latte_lib');
			var Language = require('../../language');
			this.after = function(data, view, controller) {
				if(!view.setBlankData) {
					return;
				}
				var attr = view.latte('blankData');
				if(attr) {
					var changeData = function() {
						view.setBlankData(data.get(attr));
					}
					var change = function(value, old) {
						if(old) {
							oldValue.off("change", changeFunc);
						}
						value.on("change", changeFunc);
						changeData();
					};
					controller.on('data', data, change);
					changeData();
					controller.on('close', function() {
						data.get(attr).off("change", changeData);
					});
				}
			}
		}).call(module.exports);
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/class.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		/**
			@example
				button (class:"{!cssCalss!}", click:"click")
				{
					cssClass: "a",
					click: function() {
						var cssClass = this.get("cssClass");
						if(cssClass == "a") {
							this.set("cssClass", "b");
						}else{
							this.set("cssClass", "a");
						}
					}
					
				}
		*/
		(function() {
			var Language = require('../../language');
			var latte_lib = require('latte_lib');
			this.after = function(data, view, controller) {
				var classStr = view.latte("class") || view.latte("glass");
				if(classStr) {
					var ifs = Language.stringRegExp(classStr, "{!", "!}");
					var json = {};
					ifs.forEach(function(key) {
						var split1s = key.split("?");
						var k = split1s[0].trim();
						var split2s = split1s[1].split(":");
						var change = function(value, old) {
							if(value == old) {
								return;
							}
							if(Language.toString(split2s[0]) != "") {
								view.classed(Language.toString(split2s[0]), value);
							}
							if(Language.toString(split2s[1]) != "") {
								view.classed(Language.toString(split2s[1]), !value);
							}
						}
						classStr = classStr.replace("{!" + key + "!}", data.get(k) ? Language.toString(split2s[0]): Language.toString(split2s[1]));
						
						controller.bind("data", k, change);
						
						
					});
					var keys = Language.stringRegExp(classStr);
					keys.forEach(function(key) {
						json[key] = data.get(key) || "";
						var change = function(value, oldValue) {
							if(controller.isClose()) {
								controller.unbind("data", key, change);
							}
							view.classed(oldValue, 0);
							view.classed(value, 1);
						}
						controller.bind("data", key, change);
					});
					view.lcssClass(view.lcssClass() + " " +latte_lib.format.templateStringFormat(classStr, json));
				}	
			}
		}).call(module.exports);
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/click.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		/**
			@example
				button (click:"click")
				{
					click: function() {
						console.log("点击事件")
					}
				}
		*/
		(function() {
			this.after = function(data, view, controller) {
				var clickAttribute = view.attr('latte-click');
				if(clickAttribute) {
					var clickEvent = function(e) {
						if(controller.isClose()) {
							return controller.unbind('view', 'click', clickEvent);
						}
						var self =  view.constructor.create(e.srcElement);
						var events = clickAttribute.split(" ");
						events.forEach(function(eventName) {
							var click = data.get(eventName);
							click && click.call(data, e, self, view);
						});
					}
					controller.bind("view", "click", clickEvent);
				}
			}
		}).call(module.exports);
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/css.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		(function() {
			var Language = require('../../language');
			var latte_lib = require('latte_lib');
			this.after = function(data, view, controller) {
				/*if(view.type != 'h5View') {
					return;
				}*/
				var cssAttribute = view.latte("css");
				if(cssAttribute) {
					console.log(cssAttribute);
					var attrs = cssAttribute.split(';');
					attrs.forEach(function(attr) {
						var keys = attr.split(':');
						var key = keys.shift();
						var value = keys.join(':');
						var i = value.indexOf('{!');
						if(i == -1) {
							var ai = value.indexOf('{{');
							if(ai == -1) {
								view.style(key, value);
								return;
							}
							var keys = Language.stringRegExp(value);
							return keys.forEach(function(k) {
								var change = function() {
									var json = {};
									json[k] = data.get(k) || "";
									var str = latte_lib.format.templateStringFormat(value, json);
									view.style(key, str);
								}
								controller.bind("data", k, change);
								change();
							});
						}else{
							var keys = Language.stringRegExp(value, "{!", "!}");
							var str = keys[0];
							if(keys.length > 1) {
								console.error('css',key, value);
								return;
							}
							var mk = Language.stringRegExp(str);
							return mk.forEach(function(k) {
								var change = function() {
									var json = {};
									json[k] = data.get(k) || "";
									var sv = latte_lib.format.templateStringFormat(str, json);
									var v;
									try {
										v = eval(sv);
									}catch(err) {
										console.error('css',key, value);
										v = "";
									}
		
									v = value.replace("{!" + str + "!}", v);
									view.style(key, v);
								}
								controller.bind("data", k, change);
								change();
							});
						}
						
					});
				}
			}
		}).call(module.exports);
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/duplex.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var Command = {};
		(function() {
			var changeTags = ["input", "select", "textarea"];
			this.after = function(data, view, controller) {
				if(view.type != 'h5View') {
					return;
				}
				var duplexAttribute = view.latte("duplex");
				if(duplexAttribute) {
					var changeDomFunc;
					if(changeTags.indexOf(view.getTag().toLowerCase()) != -1) {
						/*var domChange = function(value) {
							if(controller.isClose()) {
								return controller.unbind("view", "change", domChange);
							}
							data.set(duplexAttribute, view.value());
						}
						controller.bind("view", "change", domChange);
						changeDomFunc = function(value) {
							view.value(value);
						};*/
						controller.bind("view", "keyup", function(event) {
							if(view.text() != data.get(duplexAttribute)) {
								data.set(duplexAttribute, view.value());
							}
						});
						changeDomFunc = view.value.bind(view);
					}else{
						view.attr("contenteditable", "true");
						controller.bind("view", "keyup", function(event) {
							if(view.text() != data.get(duplexAttribute)) {
								data.set(duplexAttribute, view.text());
							}
						});
						changeDomFunc = view.text.bind(view);
					}
					var duplexChange = function(value) {
						if(controller.isClose()) {
							return controller.unbind("data", duplexAttribute, duplexChange)
						}
						if(value == undefined) {
							changeDomFunc("");
						}else{
							changeDomFunc(value);
						}
					}
					controller.bind("data", duplexAttribute, duplexChange);
					if(data.get(duplexAttribute) == undefined) {
						changeDomFunc("");
					}else{
						changeDomFunc(data.get(duplexAttribute));
					}
				}
			}
		}).call(Command);
		module.exports = Command;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });


(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/anchor.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var oop = require("./lib/oop");
		var EventEmitter = require("./lib/event_emitter").EventEmitter;
		
		/**
		 *
		 * Defines a floating pointer in the document. Whenever text is inserted or deleted before the cursor, the position of the anchor is updated.
		 *
		 * @class Anchor
		 **/
		
		/**
		 * Creates a new `Anchor` and associates it with a document.
		 *
		 * @param {Document} doc The document to associate with the anchor
		 * @param {Number} row The starting row position
		 * @param {Number} column The starting column position
		 *
		 * @constructor
		 **/
		
		var Anchor = exports.Anchor = function(doc, row, column) {
		    this.$onChange = this.onChange.bind(this);
		    this.attach(doc);
		    
		    if (typeof column == "undefined")
		        this.setPosition(row.row, row.column);
		    else
		        this.setPosition(row, column);
		};
		
		(function() {
		
		    oop.implement(this, EventEmitter);
		
		    /**
		     * Returns an object identifying the `row` and `column` position of the current anchor.
		     * @returns {Object}
		     **/
		    this.getPosition = function() {
		        return this.$clipPositionToDocument(this.row, this.column);
		    };
		
		    /**
		     *
		     * Returns the current document.
		     * @returns {Document}
		     **/
		    this.getDocument = function() {
		        return this.document;
		    };
		
		    /**
		     * experimental: allows anchor to stick to the next on the left
		     */
		    this.$insertRight = false;
		    /**
		     * Fires whenever the anchor position changes.
		     *
		     * Both of these objects have a `row` and `column` property corresponding to the position.
		     *
		     * Events that can trigger this function include [[Anchor.setPosition `setPosition()`]].
		     *
		     * @event change
		     * @param {Object} e  An object containing information about the anchor position. It has two properties:
		     *  - `old`: An object describing the old Anchor position
		     *  - `value`: An object describing the new Anchor position
		     *
		     **/
		    this.onChange = function(delta) {
		        if (delta.start.row == delta.end.row && delta.start.row != this.row)
		            return;
		
		        if (delta.start.row > this.row)
		            return;
		            
		        var point = $getTransformedPoint(delta, {row: this.row, column: this.column}, this.$insertRight);
		        this.setPosition(point.row, point.column, true);
		    };
		    
		    function $pointsInOrder(point1, point2, equalPointsInOrder) {
		        var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;
		        return (point1.row < point2.row) || (point1.row == point2.row && bColIsAfter);
		    }
		            
		    function $getTransformedPoint(delta, point, moveIfEqual) {
		        // Get delta info.
		        var deltaIsInsert = delta.action == "insert";
		        var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row    - delta.start.row);
		        var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
		        var deltaStart = delta.start;
		        var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.
		        
		        // DELTA AFTER POINT: No change needed.
		        if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
		            return {
		                row: point.row,
		                column: point.column
		            };
		        }
		        
		        // DELTA BEFORE POINT: Move point by delta shift.
		        if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
		            return {
		                row: point.row + deltaRowShift,
		                column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
		            };
		        }
		        
		        // DELTA ENVELOPS POINT (delete only): Move point to delta start.
		        // TODO warn if delta.action != "remove" ?
		        
		        return {
		            row: deltaStart.row,
		            column: deltaStart.column
		        };
		    }
		
		    /**
		     * Sets the anchor position to the specified row and column. If `noClip` is `true`, the position is not clipped.
		     * @param {Number} row The row index to move the anchor to
		     * @param {Number} column The column index to move the anchor to
		     * @param {Boolean} noClip Identifies if you want the position to be clipped
		     *
		     **/
		    this.setPosition = function(row, column, noClip) {
		        var pos;
		        if (noClip) {
		            pos = {
		                row: row,
		                column: column
		            };
		        } else {
		            pos = this.$clipPositionToDocument(row, column);
		        }
		
		        if (this.row == pos.row && this.column == pos.column)
		            return;
		
		        var old = {
		            row: this.row,
		            column: this.column
		        };
		
		        this.row = pos.row;
		        this.column = pos.column;
		        this._signal("change", {
		            old: old,
		            value: pos
		        });
		    };
		
		    /**
		     * When called, the `"change"` event listener is removed.
		     *
		     **/
		    this.detach = function() {
		        this.document.removeEventListener("change", this.$onChange);
		    };
		    this.attach = function(doc) {
		        this.document = doc || this.document;
		        this.document.on("change", this.$onChange);
		    };
		
		    /**
		     * Clips the anchor position to the specified row and column.
		     * @param {Number} row The row index to clip the anchor to
		     * @param {Number} column The column index to clip the anchor to
		     *
		     **/
		    this.$clipPositionToDocument = function(row, column) {
		        var pos = {};
		
		        if (row >= this.document.getLength()) {
		            pos.row = Math.max(0, this.document.getLength() - 1);
		            pos.column = this.document.getLine(pos.row).length;
		        }
		        else if (row < 0) {
		            pos.row = 0;
		            pos.column = 0;
		        }
		        else {
		            pos.row = row;
		            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
		        }
		
		        if (column < 0)
		            pos.column = 0;
		
		        return pos;
		    };
		
		}).call(Anchor.prototype);
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/apply_delta.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		function throwDeltaError(delta, errorText){
		    console.log("Invalid Delta:", delta);
		    throw "Invalid Delta: " + errorText;
		}
		
		function positionInDocument(docLines, position) {
		    return position.row    >= 0 && position.row    <  docLines.length &&
		           position.column >= 0 && position.column <= docLines[position.row].length;
		}
		
		function validateDelta(docLines, delta) {
		    // Validate action string.
		    if (delta.action != "insert" && delta.action != "remove")
		        throwDeltaError(delta, "delta.action must be 'insert' or 'remove'");
		    
		    // Validate lines type.
		    if (!(delta.lines instanceof Array))
		        throwDeltaError(delta, "delta.lines must be an Array");
		
		    // Validate range type.
		    if (!delta.start || !delta.end)
		       throwDeltaError(delta, "delta.start/end must be an present");
		
		    // Validate that the start point is contained in the document.
		    var start = delta.start;
		    if (!positionInDocument(docLines, delta.start))
		        throwDeltaError(delta, "delta.start must be contained in document");
		    
		    // Validate that the end point is contained in the document (remove deltas only).
		    var end = delta.end;
		    if (delta.action == "remove" && !positionInDocument(docLines, end))
		        throwDeltaError(delta, "delta.end must contained in document for 'remove' actions");
		    
		    // Validate that the .range size matches the .lines size.
		    var numRangeRows = end.row - start.row;
		    var numRangeLastLineChars = (end.column - (numRangeRows == 0 ? start.column : 0));
		    if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars)
		        throwDeltaError(delta, "delta.range must match delta lines");
		}
		
		exports.applyDelta = function(docLines, delta, doNotValidate) {
		    // disabled validation since it breaks autocompletion popup
		    // if (!doNotValidate)
		    //    validateDelta(docLines, delta);
		    
		    var row = delta.start.row;
		    var startColumn = delta.start.column;
		    var line = docLines[row] || "";
		    switch (delta.action) {
		        case "insert":
		            var lines = delta.lines;
		            if (lines.length === 1) {
		                docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
		            } else {
		                var args = [row, 1].concat(delta.lines);
		                docLines.splice.apply(docLines, args);
		                docLines[row] = line.substring(0, startColumn) + docLines[row];
		                docLines[row + delta.lines.length - 1] += line.substring(startColumn);
		            }
		            break;
		        case "remove":
		            var endColumn = delta.end.column;
		            var endRow = delta.end.row;
		            if (row === endRow) {
		                docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
		            } else {
		                docLines.splice(
		                    row, endRow - row + 1,
		                    line.substring(0, startColumn) + docLines[endRow].substring(endColumn)
		                );
		            }
		            break;
		    }
		}
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/background_tokenizer.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var oop = require("./lib/oop");
		var EventEmitter = require("./lib/event_emitter").EventEmitter;
		
		
		/**
		 * Tokenizes the current [[Document `Document`]] in the background, and caches the tokenized rows for future use. 
		 * 
		 * If a certain row is changed, everything below that row is re-tokenized.
		 *
		 * @class BackgroundTokenizer
		 **/
		
		/**
		 * Creates a new `BackgroundTokenizer` object.
		 * @param {Tokenizer} tokenizer The tokenizer to use
		 * @param {Editor} editor The editor to associate with
		 *
		 * @constructor
		 **/
		
		var BackgroundTokenizer = function(tokenizer, editor) {
		    this.running = false;
		    this.lines = [];
		    this.states = [];
		    this.currentLine = 0;
		    this.tokenizer = tokenizer;
		
		    var self = this;
		
		    this.$worker = function() {
		        if (!self.running) { return; }
		
		        var workerStart = new Date();
		        var currentLine = self.currentLine;
		        var endLine = -1;
		        var doc = self.doc;
		
		        var startLine = currentLine;
		        while (self.lines[currentLine])
		            currentLine++;
		        
		        var len = doc.getLength();
		        var processedLines = 0;
		        self.running = false;
		        while (currentLine < len) {
		            self.$tokenizeRow(currentLine);
		            endLine = currentLine;
		            do {
		                currentLine++;
		            } while (self.lines[currentLine]);
		
		            // only check every 5 lines
		            processedLines ++;
		            if ((processedLines % 5 === 0) && (new Date() - workerStart) > 20) {                
		                self.running = setTimeout(self.$worker, 20);
		                break;
		            }
		        }
		        self.currentLine = currentLine;
		        
		        if (startLine <= endLine)
		            self.fireUpdateEvent(startLine, endLine);
		    };
		};
		
		(function(){
		
		    oop.implement(this, EventEmitter);
		
		    /**
		     * Sets a new tokenizer for this object.
		     *
		     * @param {Tokenizer} tokenizer The new tokenizer to use
		     *
		     **/
		    this.setTokenizer = function(tokenizer) {
		        this.tokenizer = tokenizer;
		        this.lines = [];
		        this.states = [];
		
		        this.start(0);
		    };
		
		    /**
		     * Sets a new document to associate with this object.
		     * @param {Document} doc The new document to associate with
		     **/
		    this.setDocument = function(doc) {
		        this.doc = doc;
		        this.lines = [];
		        this.states = [];
		
		        this.stop();
		    };
		
		     /**
		     * Fires whenever the background tokeniziers between a range of rows are going to be updated.
		     * 
		     * @event update
		     * @param {Object} e An object containing two properties, `first` and `last`, which indicate the rows of the region being updated.
		     *
		     **/
		    /**
		     * Emits the `'update'` event. `firstRow` and `lastRow` are used to define the boundaries of the region to be updated.
		     * @param {Number} firstRow The starting row region
		     * @param {Number} lastRow The final row region
		     *
		     **/
		    this.fireUpdateEvent = function(firstRow, lastRow) {
		        var data = {
		            first: firstRow,
		            last: lastRow
		        };
		        this._signal("update", {data: data});
		    };
		
		    /**
		     * Starts tokenizing at the row indicated.
		     *
		     * @param {Number} startRow The row to start at
		     *
		     **/
		    this.start = function(startRow) {
		        this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());
		
		        // remove all cached items below this line
		        this.lines.splice(this.currentLine, this.lines.length);
		        this.states.splice(this.currentLine, this.states.length);
		
		        this.stop();
		        // pretty long delay to prevent the tokenizer from interfering with the user
		        this.running = setTimeout(this.$worker, 700);
		    };
		    
		    this.scheduleStart = function() {
		        if (!this.running)
		            this.running = setTimeout(this.$worker, 700);
		    }
		
		    this.$updateOnChange = function(delta) {
		        var startRow = delta.start.row;
		        var len = delta.end.row - startRow;
		
		        if (len === 0) {
		            this.lines[startRow] = null;
		        } else if (delta.action == "remove") {
		            this.lines.splice(startRow, len + 1, null);
		            this.states.splice(startRow, len + 1, null);
		        } else {
		            var args = Array(len + 1);
		            args.unshift(startRow, 1);
		            this.lines.splice.apply(this.lines, args);
		            this.states.splice.apply(this.states, args);
		        }
		
		        this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());
		
		        this.stop();
		    };
		
		    /**
		     * Stops tokenizing.
		     *
		     **/
		    this.stop = function() {
		        if (this.running)
		            clearTimeout(this.running);
		        this.running = false;
		    };
		
		    /**
		     * Gives list of tokens of the row. (tokens are cached)
		     * 
		     * @param {Number} row The row to get tokens at
		     *
		     * 
		     *
		     **/
		    this.getTokens = function(row) {
		        return this.lines[row] || this.$tokenizeRow(row);
		    };
		
		    /**
		     * [Returns the state of tokenization at the end of a row.]{: #BackgroundTokenizer.getState}
		     *
		     * @param {Number} row The row to get state at
		     **/
		    this.getState = function(row) {
		        if (this.currentLine == row)
		            this.$tokenizeRow(row);
		        return this.states[row] || "start";
		    };
		
		    this.$tokenizeRow = function(row) {
		        var line = this.doc.getLine(row);
		        var state = this.states[row - 1];
		
		        var data = this.tokenizer.getLineTokens(line, state, row);
		
		        if (this.states[row] + "" !== data.state + "") {
		            this.states[row] = data.state;
		            this.lines[row + 1] = null;
		            if (this.currentLine > row + 1)
		                this.currentLine = row + 1;
		        } else if (this.currentLine == row) {
		            this.currentLine = row + 1;
		        }
		
		        return this.lines[row] = data.tokens;
		    };
		
		}).call(BackgroundTokenizer.prototype);
		
		exports.BackgroundTokenizer = BackgroundTokenizer;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/bidihandler.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var bidiUtil = require("./lib/bidiutil");
		var lang = require("./lib/lang");
		var useragent = require("./lib/useragent");
		var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
		
		/**
		 * This object is used to ensure Bi-Directional support (for languages with text flowing from right to left, like Arabic or Hebrew)
		 * including correct caret positioning, text selection mouse and keyboard arrows functioning
		 * @class BidiHandler
		 **/
		
		/**
		 * Creates a new `BidiHandler` object
		 * @param {EditSession} session The session to use
		 *
		 * @constructor
		 **/
		var BidiHandler = function(session) {
		    this.session = session;
		    this.bidiMap = {};
		    /* current screen row */
		    this.currentRow = null;
		    this.bidiUtil = bidiUtil;
		    /* Arabic/Hebrew character width differs from regular character width */
		    this.charWidths = [];
		    this.EOL = "\xAC";
		    this.showInvisibles = true;
		    this.isRtlDir = false;
		    this.line = "";
		    this.wrapIndent = 0;
		    this.isLastRow = false;
		    this.EOF = "\xB6";
		    this.seenBidi = false;
		};
		
		(function() {
		    /**
		     * Returns 'true' if row contains Bidi characters, in such case
		     * creates Bidi map to be used in operations related to selection
		     * (keyboard arrays, mouse click, select)
		     * @param {Number} the screen row to be checked
		     * @param {Number} the document row to be checked [optional]
		     * @param {Number} the wrapped screen line index [ optional]
		    **/
		    this.isBidiRow = function(screenRow, docRow, splitIndex) {
		        if (!this.seenBidi)
		            return false;
		        if (screenRow !== this.currentRow) {
		            this.currentRow = screenRow;
		            this.updateRowLine(docRow, splitIndex);
		            this.updateBidiMap();
		        }
		        return this.bidiMap.bidiLevels;
		    };
		
		    this.onChange = function(delta) {
		        if (!this.seenBidi) {
		            if (delta.action == "insert" && bidiRE.test(delta.lines.join("\n"))) {
		                this.seenBidi = true;
		                this.currentRow = null;
		            }
		        } 
		        else {
		            this.currentRow = null;
		        }
		    };
		
		    this.getDocumentRow = function() {
		        var docRow = 0;
		        var rowCache = this.session.$screenRowCache;
		        if (rowCache.length) {
		            var index = this.session.$getRowCacheIndex(rowCache, this.currentRow);
		            if (index >= 0)
		                docRow = this.session.$docRowCache[index];
		        }
		
		        return docRow;
		    };
		
		    this.getSplitIndex = function() {
		        var splitIndex = 0;
		        var rowCache = this.session.$screenRowCache;
		        if (rowCache.length) {
		            var currentIndex, prevIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow);
		            while (this.currentRow - splitIndex > 0) {
		                currentIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow - splitIndex - 1);
		                if (currentIndex !== prevIndex)
		                    break;
		
		                prevIndex = currentIndex;
		                splitIndex++;
		            }
		        }
		
		        return splitIndex;
		    };
		
		    this.updateRowLine = function(docRow, splitIndex) {
		        if (docRow === undefined)
		            docRow = this.getDocumentRow();
		            
		        this.wrapIndent = 0;
		        this.isLastRow = (docRow === this.session.getLength() - 1);
		        this.line = this.session.getLine(docRow);
		        if (this.session.$useWrapMode) {
		            var splits = this.session.$wrapData[docRow];
		            if (splits) {
		                if (splitIndex === undefined)
		                    splitIndex = this.getSplitIndex();
		
		                if(splitIndex > 0 && splits.length) {
		                    this.wrapIndent = splits.indent;
		                    this.line = (splitIndex < splits.length) ?
		                        this.line.substring(splits[splitIndex - 1], splits[splits.length - 1]) :
		                            this.line.substring(splits[splits.length - 1]);
		                } else {
		                    this.line = this.line.substring(0, splits[splitIndex]);
		                }
		            }
		        }
		            
		        /* replace tab and wide characters by commensurate spaces */
		        var session = this.session, shift = 0, size;
		        this.line = this.line.replace(/\t|[\u1100-\u2029, \u202F-\uFFE6]/g, function(ch, i){
		            if (ch === '\t' || session.isFullWidth(ch.charCodeAt(0))) {
		                size = (ch === '\t') ? session.getScreenTabSize(i + shift) : 2;
		                shift += size - 1;
		                return lang.stringRepeat(bidiUtil.DOT, size);
		            }
		            return ch;
		        });
		    };
		    
		    this.updateBidiMap = function() {
		        var textCharTypes = [], endOfLine = this.isLastRow ? this.EOF : this.EOL;
		        var line = this.line + (this.showInvisibles ? endOfLine : bidiUtil.DOT);
		        if (bidiUtil.hasBidiCharacters(line, textCharTypes)) {
		            this.bidiMap = bidiUtil.doBidiReorder(line, textCharTypes, this.isRtlDir);
		        } else {
		            this.bidiMap = {};
		        }
		    };
		
		    /**
		     * Resets stored info related to current screen row
		    **/
		    this.markAsDirty = function() {
		        this.currentRow = null;
		    };
		
		    /**
		     * Updates array of character widths
		     * @param {Object} font metrics
		     *
		    **/
		    this.updateCharacterWidths = function(fontMetrics) {
		        if (!this.seenBidi)
		            return;
		        if (this.characterWidth === fontMetrics.$characterSize.width)
		            return;
		
		        var characterWidth = this.characterWidth = fontMetrics.$characterSize.width;
		        var bidiCharWidth = fontMetrics.$measureCharWidth("\u05d4");
		
		        this.charWidths[bidiUtil.L] = this.charWidths[bidiUtil.EN] = this.charWidths[bidiUtil.ON_R] = characterWidth;
		        this.charWidths[bidiUtil.R] = this.charWidths[bidiUtil.AN] = bidiCharWidth;
		        this.charWidths[bidiUtil.R_H] = useragent.isChrome ? bidiCharWidth : bidiCharWidth * 0.45;
		        this.charWidths[bidiUtil.B] = 0;
		
		        this.currentRow = null;
		    };
		
		    this.getShowInvisibles = function() {
		        return this.showInvisibles;
		    };
		
		    this.setShowInvisibles = function(showInvisibles) {
		        this.showInvisibles = showInvisibles;
		        this.currentRow = null;
		    };
		
		    this.setEolChar = function(eolChar) {
		        this.EOL = eolChar; 
		    };
		
		    this.setTextDir = function(isRtlDir) {
		        this.isRtlDir = isRtlDir; 
		    };
		
		    /**
		     * Returns offset of character at position defined by column.
		     * @param {Number} the screen column position
		     *
		     * @return {int} horizontal pixel offset of given screen column
		     **/
		    this.getPosLeft = function(col) {
		        col -= this.wrapIndent;
		        var visualIdx = bidiUtil.getVisualFromLogicalIdx(col > 0 ? col - 1 : 0, this.bidiMap),
		            levels = this.bidiMap.bidiLevels, left = 0;
		
		        if (col === 0 && levels[visualIdx] % 2 !== 0)
		            visualIdx++;
		
		        for (var i = 0; i < visualIdx; i++) {
		            left += this.charWidths[levels[i]];
		        }
		
		        if (col !== 0 && levels[visualIdx] % 2 === 0)
		            left += this.charWidths[levels[visualIdx]];
		
		        if (this.wrapIndent)
		            left += this.wrapIndent * this.charWidths[bidiUtil.L];
		
		        return left;
		    };
		
		    /**
		     * Returns 'selections' - array of objects defining set of selection rectangles
		     * @param {Number} the start column position
		     * @param {Number} the end column position
		     *
		     * @return {Array of Objects} Each object contains 'left' and 'width' values defining selection rectangle.
		    **/
		    this.getSelections = function(startCol, endCol) {
		        var map = this.bidiMap, levels = map.bidiLevels, level, offset = this.wrapIndent * this.charWidths[bidiUtil.L], selections = [],
		            selColMin = Math.min(startCol, endCol) - this.wrapIndent, selColMax = Math.max(startCol, endCol) - this.wrapIndent,
		                isSelected = false, isSelectedPrev = false, selectionStart = 0;
		
		        for (var logIdx, visIdx = 0; visIdx < levels.length; visIdx++) {
		            logIdx = map.logicalFromVisual[visIdx];
		            level = levels[visIdx];
		            isSelected = (logIdx >= selColMin) && (logIdx < selColMax);
		            if (isSelected && !isSelectedPrev) {
		                selectionStart = offset;
		            } else if (!isSelected && isSelectedPrev) {
		                selections.push({left: selectionStart, width: offset - selectionStart});
		            }
		            offset += this.charWidths[level];
		            isSelectedPrev = isSelected;
		        }
		
		        if (isSelected && (visIdx === levels.length)) {
		            selections.push({left: selectionStart, width: offset - selectionStart});
		        }
		
		        return selections;
		    };
		
		    /**
		     * Converts character coordinates on the screen to respective document column number
		     * @param {int} character horizontal offset
		     *
		     * @return {Number} screen column number corresponding to given pixel offset
		    **/
		    this.offsetToCol = function(posX) {
		        var logicalIdx = 0, posX = Math.max(posX, 0),
		            offset = 0, visualIdx = 0, levels = this.bidiMap.bidiLevels,
		                charWidth = this.charWidths[levels[visualIdx]];
		
		        if (this.wrapIndent) {
		            posX -= this.wrapIndent * this.charWidths[bidiUtil.L];
		        }
		    
		        while(posX > offset + charWidth/2) {
		            offset += charWidth;
		            if(visualIdx === levels.length - 1) {
		                /* quit when we on the right of the last character, flag this by charWidth = 0 */
		                charWidth = 0;
		                break;
		            }
		            charWidth = this.charWidths[levels[++visualIdx]];
		        }
		    
		        if (visualIdx > 0 && (levels[visualIdx - 1] % 2 !== 0) && (levels[visualIdx] % 2 === 0)){
		        /* Bidi character on the left and None Bidi character on the right */
		            if(posX < offset)
		                visualIdx--;
		            logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
		
		        } else if (visualIdx > 0 && (levels[visualIdx - 1] % 2 === 0) && (levels[visualIdx] % 2 !== 0)){
		        /* None Bidi character on the left and Bidi character on the right */
		            logicalIdx = 1 + ((posX > offset) ? this.bidiMap.logicalFromVisual[visualIdx]
		                    : this.bidiMap.logicalFromVisual[visualIdx - 1]);
		
		        } else if ((this.isRtlDir && visualIdx === levels.length - 1 && charWidth === 0 && (levels[visualIdx - 1] % 2 === 0))
		                || (!this.isRtlDir && visualIdx === 0 && (levels[visualIdx] % 2 !== 0))){
		        /* To the right of last character, which is None Bidi, in RTL direction or */
		        /* to the left of first Bidi character, in LTR direction */
		            logicalIdx = 1 + this.bidiMap.logicalFromVisual[visualIdx];
		        } else {
		            /* Tweak visual position when Bidi character on the left in order to map it to corresponding logical position */
		            if (visualIdx > 0 && (levels[visualIdx - 1] % 2 !== 0) && charWidth !== 0)
		                visualIdx--;
		
		            /* Regular case */
		            logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
		        }
		
		        return (logicalIdx + this.wrapIndent);
		    };
		
		}).call(BidiHandler.prototype);
		
		exports.BidiHandler = BidiHandler;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/clipboard.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		
		module.exports = { lineMode: false };
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/commands/command_manager.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var oop = require("../lib/oop");
		var MultiHashHandler = require("../keyboard/hash_handler").MultiHashHandler;
		var EventEmitter = require("../lib/event_emitter").EventEmitter;
		
		/**
		 * @class CommandManager
		 *
		 **/
		
		/**
		 * new CommandManager(platform, commands)
		 * @param {String} platform Identifier for the platform; must be either `"mac"` or `"win"`
		 * @param {Array} commands A list of commands
		 *
		 **/
		
		var CommandManager = function(platform, commands) {
		    MultiHashHandler.call(this, commands, platform);
		    this.byName = this.commands;
		    this.setDefaultHandler("exec", function(e) {
		        return e.command.exec(e.editor, e.args || {});
		    });
		};
		
		oop.inherits(CommandManager, MultiHashHandler);
		
		(function() {
		
		    oop.implement(this, EventEmitter);
		
		    this.exec = function(command, editor, args) {
		        if (Array.isArray(command)) {
		            for (var i = command.length; i--; ) {
		                if (this.exec(command[i], editor, args)) return true;
		            }
		            return false;
		        }
		        
		        if (typeof command === "string")
		            command = this.commands[command];
		
		        if (!command)
		            return false;
		
		        if (editor && editor.$readOnly && !command.readOnly)
		            return false;
		
		        var e = {editor: editor, command: command, args: args};
		        e.returnValue = this._emit("exec", e);
		        this._signal("afterExec", e);
		
		        return e.returnValue === false ? false : true;
		    };
		
		    this.toggleRecording = function(editor) {
		        if (this.$inReplay)
		            return;
		
		        editor && editor._emit("changeStatus");
		        if (this.recording) {
		            this.macro.pop();
		            this.removeEventListener("exec", this.$addCommandToMacro);
		
		            if (!this.macro.length)
		                this.macro = this.oldMacro;
		
		            return this.recording = false;
		        }
		        if (!this.$addCommandToMacro) {
		            this.$addCommandToMacro = function(e) {
		                this.macro.push([e.command, e.args]);
		            }.bind(this);
		        }
		
		        this.oldMacro = this.macro;
		        this.macro = [];
		        this.on("exec", this.$addCommandToMacro);
		        return this.recording = true;
		    };
		
		    this.replay = function(editor) {
		        if (this.$inReplay || !this.macro)
		            return;
		
		        if (this.recording)
		            return this.toggleRecording(editor);
		
		        try {
		            this.$inReplay = true;
		            this.macro.forEach(function(x) {
		                if (typeof x == "string")
		                    this.exec(x, editor);
		                else
		                    this.exec(x[0], editor, x[1]);
		            }, this);
		        } finally {
		            this.$inReplay = false;
		        }
		    };
		
		    this.trimMacro = function(m) {
		        return m.map(function(x){
		            if (typeof x[0] != "string")
		                x[0] = x[0].name;
		            if (!x[1])
		                x = x[0];
		            return x;
		        });
		    };
		
		}).call(CommandManager.prototype);
		
		exports.CommandManager = CommandManager;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/commands/default_commands.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var lang = require("../lib/lang");
		var config = require("../config");
		var Range = require("../range").Range;
		
		function bindKey(win, mac) {
		    return {win: win, mac: mac};
		}
		
		/*
		    multiSelectAction: "forEach"|"forEachLine"|function|undefined,
		    scrollIntoView: true|"cursor"|"center"|"selectionPart"
		*/
		exports.commands = [{
		    name: "showSettingsMenu",
		    bindKey: bindKey("Ctrl-,", "Command-,"),
		    exec: function(editor) {
		        config.loadModule("./ext/settings_menu", function(module) {
		            module.init(editor);
		            editor.showSettingsMenu();
		        });
		    },
		    readOnly: true
		}, {
		    name: "goToNextError",
		    bindKey: bindKey("Alt-E", "Ctrl-E"),
		    exec: function(editor) {
		        config.loadModule("./ext/error_marker", function(module) {
		            module.showErrorMarker(editor, 1);
		        });
		    },
		    scrollIntoView: "animate",
		    readOnly: true
		}, {
		    name: "goToPreviousError",
		    bindKey: bindKey("Alt-Shift-E", "Ctrl-Shift-E"),
		    exec: function(editor) {
		        config.loadModule("./ext/error_marker", function(module) {
		            module.showErrorMarker(editor, -1);
		        });
		    },
		    scrollIntoView: "animate",
		    readOnly: true
		}, {
		    name: "selectall",
		    bindKey: bindKey("Ctrl-A", "Command-A"),
		    exec: function(editor) { editor.selectAll(); },
		    readOnly: true
		}, {
		    name: "centerselection",
		    bindKey: bindKey(null, "Ctrl-L"),
		    exec: function(editor) { editor.centerSelection(); },
		    readOnly: true
		}, {
		    name: "gotoline",
		    bindKey: bindKey("Ctrl-L", "Command-L"),
		    exec: function(editor) {
		        var line = parseInt(prompt("Enter line number:"), 10);
		        if (!isNaN(line)) {
		            editor.gotoLine(line);
		        }
		    },
		    readOnly: true
		}, {
		    name: "fold",
		    bindKey: bindKey("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
		    exec: function(editor) { editor.session.toggleFold(false); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "center",
		    readOnly: true
		}, {
		    name: "unfold",
		    bindKey: bindKey("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
		    exec: function(editor) { editor.session.toggleFold(true); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "center",
		    readOnly: true
		}, {
		    name: "toggleFoldWidget",
		    bindKey: bindKey("F2", "F2"),
		    exec: function(editor) { editor.session.toggleFoldWidget(); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "center",
		    readOnly: true
		}, {
		    name: "toggleParentFoldWidget",
		    bindKey: bindKey("Alt-F2", "Alt-F2"),
		    exec: function(editor) { editor.session.toggleFoldWidget(true); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "center",
		    readOnly: true
		}, {
		    name: "foldall",
		    bindKey: bindKey(null, "Ctrl-Command-Option-0"),
		    exec: function(editor) { editor.session.foldAll(); },
		    scrollIntoView: "center",
		    readOnly: true
		}, {
		    name: "foldOther",
		    bindKey: bindKey("Alt-0", "Command-Option-0"),
		    exec: function(editor) { 
		        editor.session.foldAll();
		        editor.session.unfold(editor.selection.getAllRanges());
		    },
		    scrollIntoView: "center",
		    readOnly: true
		}, {
		    name: "unfoldall",
		    bindKey: bindKey("Alt-Shift-0", "Command-Option-Shift-0"),
		    exec: function(editor) { editor.session.unfold(); },
		    scrollIntoView: "center",
		    readOnly: true
		}, {
		    name: "findnext",
		    bindKey: bindKey("Ctrl-K", "Command-G"),
		    exec: function(editor) { editor.findNext(); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "center",
		    readOnly: true
		}, {
		    name: "findprevious",
		    bindKey: bindKey("Ctrl-Shift-K", "Command-Shift-G"),
		    exec: function(editor) { editor.findPrevious(); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "center",
		    readOnly: true
		}, {
		    name: "selectOrFindNext",
		    bindKey: bindKey("Alt-K", "Ctrl-G"),
		    exec: function(editor) {
		        if (editor.selection.isEmpty())
		            editor.selection.selectWord();
		        else
		            editor.findNext(); 
		    },
		    readOnly: true
		}, {
		    name: "selectOrFindPrevious",
		    bindKey: bindKey("Alt-Shift-K", "Ctrl-Shift-G"),
		    exec: function(editor) { 
		        if (editor.selection.isEmpty())
		            editor.selection.selectWord();
		        else
		            editor.findPrevious();
		    },
		    readOnly: true
		}, {
		    name: "find",
		    bindKey: bindKey("Ctrl-F", "Command-F"),
		    exec: function(editor) {
		        config.loadModule("./ext/searchbox", function(e) {e.Search(editor)});
		    },
		    readOnly: true
		}, {
		    name: "overwrite",
		    bindKey: "Insert",
		    exec: function(editor) { editor.toggleOverwrite(); },
		    readOnly: true
		}, {
		    name: "selecttostart",
		    bindKey: bindKey("Ctrl-Shift-Home", "Command-Shift-Up"),
		    exec: function(editor) { editor.getSelection().selectFileStart(); },
		    multiSelectAction: "forEach",
		    readOnly: true,
		    scrollIntoView: "animate",
		    aceCommandGroup: "fileJump"
		}, {
		    name: "gotostart",
		    bindKey: bindKey("Ctrl-Home", "Command-Home|Command-Up"),
		    exec: function(editor) { editor.navigateFileStart(); },
		    multiSelectAction: "forEach",
		    readOnly: true,
		    scrollIntoView: "animate",
		    aceCommandGroup: "fileJump"
		}, {
		    name: "selectup",
		    bindKey: bindKey("Shift-Up", "Shift-Up"),
		    exec: function(editor) { editor.getSelection().selectUp(); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "cursor",
		    readOnly: true
		}, {
		    name: "golineup",
		    bindKey: bindKey("Up", "Up|Ctrl-P"),
		    exec: function(editor, args) { editor.navigateUp(args.times); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "cursor",
		    readOnly: true
		}, {
		    name: "selecttoend",
		    bindKey: bindKey("Ctrl-Shift-End", "Command-Shift-Down"),
		    exec: function(editor) { editor.getSelection().selectFileEnd(); },
		    multiSelectAction: "forEach",
		    readOnly: true,
		    scrollIntoView: "animate",
		    aceCommandGroup: "fileJump"
		}, {
		    name: "gotoend",
		    bindKey: bindKey("Ctrl-End", "Command-End|Command-Down"),
		    exec: function(editor) { editor.navigateFileEnd(); },
		    multiSelectAction: "forEach",
		    readOnly: true,
		    scrollIntoView: "animate",
		    aceCommandGroup: "fileJump"
		}, {
		    name: "selectdown",
		    bindKey: bindKey("Shift-Down", "Shift-Down"),
		    exec: function(editor) { editor.getSelection().selectDown(); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "cursor",
		    readOnly: true
		}, {
		    name: "golinedown",
		    bindKey: bindKey("Down", "Down|Ctrl-N"),
		    exec: function(editor, args) { editor.navigateDown(args.times); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "cursor",
		    readOnly: true
		}, {
		    name: "selectwordleft",
		    bindKey: bindKey("Ctrl-Shift-Left", "Option-Shift-Left"),
		    exec: function(editor) { editor.getSelection().selectWordLeft(); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "cursor",
		    readOnly: true
		}, {
		    name: "gotowordleft",
		    bindKey: bindKey("Ctrl-Left", "Option-Left"),
		    exec: function(editor) { editor.navigateWordLeft(); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "cursor",
		    readOnly: true
		}, {
		    name: "selecttolinestart",
		    bindKey: bindKey("Alt-Shift-Left", "Command-Shift-Left"),
		    exec: function(editor) { editor.getSelection().selectLineStart(); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "cursor",
		    readOnly: true
		}, {
		    name: "gotolinestart",
		    bindKey: bindKey("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
		    exec: function(editor) { editor.navigateLineStart(); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "cursor",
		    readOnly: true
		}, {
		    name: "selectleft",
		    bindKey: bindKey("Shift-Left", "Shift-Left"),
		    exec: function(editor) { editor.getSelection().selectLeft(); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "cursor",
		    readOnly: true
		}, {
		    name: "gotoleft",
		    bindKey: bindKey("Left", "Left|Ctrl-B"),
		    exec: function(editor, args) { editor.navigateLeft(args.times); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "cursor",
		    readOnly: true
		}, {
		    name: "selectwordright",
		    bindKey: bindKey("Ctrl-Shift-Right", "Option-Shift-Right"),
		    exec: function(editor) { editor.getSelection().selectWordRight(); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "cursor",
		    readOnly: true
		}, {
		    name: "gotowordright",
		    bindKey: bindKey("Ctrl-Right", "Option-Right"),
		    exec: function(editor) { editor.navigateWordRight(); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "cursor",
		    readOnly: true
		}, {
		    name: "selecttolineend",
		    bindKey: bindKey("Alt-Shift-Right", "Command-Shift-Right"),
		    exec: function(editor) { editor.getSelection().selectLineEnd(); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "cursor",
		    readOnly: true
		}, {
		    name: "gotolineend",
		    bindKey: bindKey("Alt-Right|End", "Command-Right|End|Ctrl-E"),
		    exec: function(editor) { editor.navigateLineEnd(); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "cursor",
		    readOnly: true
		}, {
		    name: "selectright",
		    bindKey: bindKey("Shift-Right", "Shift-Right"),
		    exec: function(editor) { editor.getSelection().selectRight(); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "cursor",
		    readOnly: true
		}, {
		    name: "gotoright",
		    bindKey: bindKey("Right", "Right|Ctrl-F"),
		    exec: function(editor, args) { editor.navigateRight(args.times); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "cursor",
		    readOnly: true
		}, {
		    name: "selectpagedown",
		    bindKey: "Shift-PageDown",
		    exec: function(editor) { editor.selectPageDown(); },
		    readOnly: true
		}, {
		    name: "pagedown",
		    bindKey: bindKey(null, "Option-PageDown"),
		    exec: function(editor) { editor.scrollPageDown(); },
		    readOnly: true
		}, {
		    name: "gotopagedown",
		    bindKey: bindKey("PageDown", "PageDown|Ctrl-V"),
		    exec: function(editor) { editor.gotoPageDown(); },
		    readOnly: true
		}, {
		    name: "selectpageup",
		    bindKey: "Shift-PageUp",
		    exec: function(editor) { editor.selectPageUp(); },
		    readOnly: true
		}, {
		    name: "pageup",
		    bindKey: bindKey(null, "Option-PageUp"),
		    exec: function(editor) { editor.scrollPageUp(); },
		    readOnly: true
		}, {
		    name: "gotopageup",
		    bindKey: "PageUp",
		    exec: function(editor) { editor.gotoPageUp(); },
		    readOnly: true
		}, {
		    name: "scrollup",
		    bindKey: bindKey("Ctrl-Up", null),
		    exec: function(e) { e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight); },
		    readOnly: true
		}, {
		    name: "scrolldown",
		    bindKey: bindKey("Ctrl-Down", null),
		    exec: function(e) { e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight); },
		    readOnly: true
		}, {
		    name: "selectlinestart",
		    bindKey: "Shift-Home",
		    exec: function(editor) { editor.getSelection().selectLineStart(); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "cursor",
		    readOnly: true
		}, {
		    name: "selectlineend",
		    bindKey: "Shift-End",
		    exec: function(editor) { editor.getSelection().selectLineEnd(); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "cursor",
		    readOnly: true
		}, {
		    name: "togglerecording",
		    bindKey: bindKey("Ctrl-Alt-E", "Command-Option-E"),
		    exec: function(editor) { editor.commands.toggleRecording(editor); },
		    readOnly: true
		}, {
		    name: "replaymacro",
		    bindKey: bindKey("Ctrl-Shift-E", "Command-Shift-E"),
		    exec: function(editor) { editor.commands.replay(editor); },
		    readOnly: true
		}, {
		    name: "jumptomatching",
		    bindKey: bindKey("Ctrl-P", "Ctrl-P"),
		    exec: function(editor) { editor.jumpToMatching(); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "animate",
		    readOnly: true
		}, {
		    name: "selecttomatching",
		    bindKey: bindKey("Ctrl-Shift-P", "Ctrl-Shift-P"),
		    exec: function(editor) { editor.jumpToMatching(true); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "animate",
		    readOnly: true
		}, {
		    name: "expandToMatching",
		    bindKey: bindKey("Ctrl-Shift-M", "Ctrl-Shift-M"),
		    exec: function(editor) { editor.jumpToMatching(true, true); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "animate",
		    readOnly: true
		}, {
		    name: "passKeysToBrowser",
		    bindKey: bindKey(null, null),
		    exec: function() {},
		    passEvent: true,
		    readOnly: true
		}, {
		    name: "copy",
		    exec: function(editor) {
		        // placeholder for replay macro
		    },
		    readOnly: true
		},
		
		// commands disabled in readOnly mode
		{
		    name: "cut",
		    exec: function(editor) {
		        var range = editor.getSelectionRange();
		        editor._emit("cut", range);
		
		        if (!editor.selection.isEmpty()) {
		            editor.session.remove(range);
		            editor.clearSelection();
		        }
		    },
		    scrollIntoView: "cursor",
		    multiSelectAction: "forEach"
		}, {
		    name: "paste",
		    exec: function(editor, args) {
		        editor.$handlePaste(args);
		    },
		    scrollIntoView: "cursor"
		}, {
		    name: "removeline",
		    bindKey: bindKey("Ctrl-D", "Command-D"),
		    exec: function(editor) { editor.removeLines(); },
		    scrollIntoView: "cursor",
		    multiSelectAction: "forEachLine"
		}, {
		    name: "duplicateSelection",
		    bindKey: bindKey("Ctrl-Shift-D", "Command-Shift-D"),
		    exec: function(editor) { editor.duplicateSelection(); },
		    scrollIntoView: "cursor",
		    multiSelectAction: "forEach"
		}, {
		    name: "sortlines",
		    bindKey: bindKey("Ctrl-Alt-S", "Command-Alt-S"),
		    exec: function(editor) { editor.sortLines(); },
		    scrollIntoView: "selection",
		    multiSelectAction: "forEachLine"
		}, {
		    name: "togglecomment",
		    bindKey: bindKey("Ctrl-/", "Command-/"),
		    exec: function(editor) { editor.toggleCommentLines(); },
		    multiSelectAction: "forEachLine",
		    scrollIntoView: "selectionPart"
		}, {
		    name: "toggleBlockComment",
		    bindKey: bindKey("Ctrl-Shift-/", "Command-Shift-/"),
		    exec: function(editor) { editor.toggleBlockComment(); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "selectionPart"
		}, {
		    name: "modifyNumberUp",
		    bindKey: bindKey("Ctrl-Shift-Up", "Alt-Shift-Up"),
		    exec: function(editor) { editor.modifyNumber(1); },
		    scrollIntoView: "cursor",
		    multiSelectAction: "forEach"
		}, {
		    name: "modifyNumberDown",
		    bindKey: bindKey("Ctrl-Shift-Down", "Alt-Shift-Down"),
		    exec: function(editor) { editor.modifyNumber(-1); },
		    scrollIntoView: "cursor",
		    multiSelectAction: "forEach"
		}, {
		    name: "replace",
		    bindKey: bindKey("Ctrl-H", "Command-Option-F"),
		    exec: function(editor) {
		        config.loadModule("ace/ext/searchbox", function(e) {e.Search(editor, true)});
		    }
		}, {
		    name: "undo",
		    bindKey: bindKey("Ctrl-Z", "Command-Z"),
		    exec: function(editor) { editor.undo(); }
		}, {
		    name: "redo",
		    bindKey: bindKey("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
		    exec: function(editor) { editor.redo(); }
		}, {
		    name: "copylinesup",
		    bindKey: bindKey("Alt-Shift-Up", "Command-Option-Up"),
		    exec: function(editor) { editor.copyLinesUp(); },
		    scrollIntoView: "cursor"
		}, {
		    name: "movelinesup",
		    bindKey: bindKey("Alt-Up", "Option-Up"),
		    exec: function(editor) { editor.moveLinesUp(); },
		    scrollIntoView: "cursor"
		}, {
		    name: "copylinesdown",
		    bindKey: bindKey("Alt-Shift-Down", "Command-Option-Down"),
		    exec: function(editor) { editor.copyLinesDown(); },
		    scrollIntoView: "cursor"
		}, {
		    name: "movelinesdown",
		    bindKey: bindKey("Alt-Down", "Option-Down"),
		    exec: function(editor) { editor.moveLinesDown(); },
		    scrollIntoView: "cursor"
		}, {
		    name: "del",
		    bindKey: bindKey("Delete", "Delete|Ctrl-D|Shift-Delete"),
		    exec: function(editor) { editor.remove("right"); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "cursor"
		}, {
		    name: "backspace",
		    bindKey: bindKey(
		        "Shift-Backspace|Backspace",
		        "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"
		    ),
		    exec: function(editor) { editor.remove("left"); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "cursor"
		}, {
		    name: "cut_or_delete",
		    bindKey: bindKey("Shift-Delete", null),
		    exec: function(editor) { 
		        if (editor.selection.isEmpty()) {
		            editor.remove("left");
		        } else {
		            return false;
		        }
		    },
		    multiSelectAction: "forEach",
		    scrollIntoView: "cursor"
		}, {
		    name: "removetolinestart",
		    bindKey: bindKey("Alt-Backspace", "Command-Backspace"),
		    exec: function(editor) { editor.removeToLineStart(); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "cursor"
		}, {
		    name: "removetolineend",
		    bindKey: bindKey("Alt-Delete", "Ctrl-K"),
		    exec: function(editor) { editor.removeToLineEnd(); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "cursor"
		}, {
		    name: "removewordleft",
		    bindKey: bindKey("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
		    exec: function(editor) { editor.removeWordLeft(); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "cursor"
		}, {
		    name: "removewordright",
		    bindKey: bindKey("Ctrl-Delete", "Alt-Delete"),
		    exec: function(editor) { editor.removeWordRight(); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "cursor"
		}, {
		    name: "outdent",
		    bindKey: bindKey("Shift-Tab", "Shift-Tab"),
		    exec: function(editor) { editor.blockOutdent(); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "selectionPart"
		}, {
		    name: "indent",
		    bindKey: bindKey("Tab", "Tab"),
		    exec: function(editor) { editor.indent(); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "selectionPart"
		}, {
		    name: "blockoutdent",
		    bindKey: bindKey("Ctrl-[", "Ctrl-["),
		    exec: function(editor) { editor.blockOutdent(); },
		    multiSelectAction: "forEachLine",
		    scrollIntoView: "selectionPart"
		}, {
		    name: "blockindent",
		    bindKey: bindKey("Ctrl-]", "Ctrl-]"),
		    exec: function(editor) { editor.blockIndent(); },
		    multiSelectAction: "forEachLine",
		    scrollIntoView: "selectionPart"
		}, {
		    name: "insertstring",
		    exec: function(editor, str) { editor.insert(str); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "cursor"
		}, {
		    name: "inserttext",
		    exec: function(editor, args) {
		        editor.insert(lang.stringRepeat(args.text  || "", args.times || 1));
		    },
		    multiSelectAction: "forEach",
		    scrollIntoView: "cursor"
		}, {
		    name: "splitline",
		    bindKey: bindKey(null, "Ctrl-O"),
		    exec: function(editor) { editor.splitLine(); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "cursor"
		}, {
		    name: "transposeletters",
		    bindKey: bindKey("Ctrl-T", "Ctrl-T"),
		    exec: function(editor) { editor.transposeLetters(); },
		    multiSelectAction: function(editor) {editor.transposeSelections(1); },
		    scrollIntoView: "cursor"
		}, {
		    name: "touppercase",
		    bindKey: bindKey("Ctrl-U", "Ctrl-U"),
		    exec: function(editor) { editor.toUpperCase(); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "cursor"
		}, {
		    name: "tolowercase",
		    bindKey: bindKey("Ctrl-Shift-U", "Ctrl-Shift-U"),
		    exec: function(editor) { editor.toLowerCase(); },
		    multiSelectAction: "forEach",
		    scrollIntoView: "cursor"
		}, {
		    name: "expandtoline",
		    bindKey: bindKey("Ctrl-Shift-L", "Command-Shift-L"),
		    exec: function(editor) {
		        var range = editor.selection.getRange();
		
		        range.start.column = range.end.column = 0;
		        range.end.row++;
		        editor.selection.setRange(range, false);
		    },
		    multiSelectAction: "forEach",
		    scrollIntoView: "cursor",
		    readOnly: true
		}, {
		    name: "joinlines",
		    bindKey: bindKey(null, null),
		    exec: function(editor) {
		        var isBackwards = editor.selection.isBackwards();
		        var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();
		        var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();
		        var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;
		        var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());
		        var selectedCount = selectedText.replace(/\n\s*/, " ").length;
		        var insertLine = editor.session.doc.getLine(selectionStart.row);
		
		        for (var i = selectionStart.row + 1; i <= selectionEnd.row + 1; i++) {
		            var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i)));
		            if (curLine.length !== 0) {
		                curLine = " " + curLine;
		            }
		            insertLine += curLine;
		        }
		
		        if (selectionEnd.row + 1 < (editor.session.doc.getLength() - 1)) {
		            // Don't insert a newline at the end of the document
		            insertLine += editor.session.doc.getNewLineCharacter();
		        }
		
		        editor.clearSelection();
		        editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);
		
		        if (selectedCount > 0) {
		            // Select the text that was previously selected
		            editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);
		            editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);
		        } else {
		            // If the joined line had something in it, start the cursor at that something
		            firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? (firstLineEndCol + 1) : firstLineEndCol;
		            editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);
		        }
		    },
		    multiSelectAction: "forEach",
		    readOnly: true
		}, {
		    name: "invertSelection",
		    bindKey: bindKey(null, null),
		    exec: function(editor) {
		        var endRow = editor.session.doc.getLength() - 1;
		        var endCol = editor.session.doc.getLine(endRow).length;
		        var ranges = editor.selection.rangeList.ranges;
		        var newRanges = [];
		
		        // If multiple selections don't exist, rangeList will return 0 so replace with single range
		        if (ranges.length < 1) {
		            ranges = [editor.selection.getRange()];
		        }
		
		        for (var i = 0; i < ranges.length; i++) {
		            if (i == (ranges.length - 1)) {
		                // The last selection must connect to the end of the document, unless it already does
		                if (!(ranges[i].end.row === endRow && ranges[i].end.column === endCol)) {
		                    newRanges.push(new Range(ranges[i].end.row, ranges[i].end.column, endRow, endCol));
		                }
		            }
		
		            if (i === 0) {
		                // The first selection must connect to the start of the document, unless it already does
		                if (!(ranges[i].start.row === 0 && ranges[i].start.column === 0)) {
		                    newRanges.push(new Range(0, 0, ranges[i].start.row, ranges[i].start.column));
		                }
		            } else {
		                newRanges.push(new Range(ranges[i-1].end.row, ranges[i-1].end.column, ranges[i].start.row, ranges[i].start.column));
		            }
		        }
		
		        editor.exitMultiSelectMode();
		        editor.clearSelection();
		
		        for(var i = 0; i < newRanges.length; i++) {
		            editor.selection.addRange(newRanges[i], false);
		        }
		    },
		    readOnly: true,
		    scrollIntoView: "none"
		}];
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/commands/multi_select_commands.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		// commands to enter multiselect mode
		exports.defaultCommands = [{
		    name: "addCursorAbove",
		    exec: function(editor) { editor.selectMoreLines(-1); },
		    bindKey: {win: "Ctrl-Alt-Up", mac: "Ctrl-Alt-Up"},
		    scrollIntoView: "cursor",
		    readOnly: true
		}, {
		    name: "addCursorBelow",
		    exec: function(editor) { editor.selectMoreLines(1); },
		    bindKey: {win: "Ctrl-Alt-Down", mac: "Ctrl-Alt-Down"},
		    scrollIntoView: "cursor",
		    readOnly: true
		}, {
		    name: "addCursorAboveSkipCurrent",
		    exec: function(editor) { editor.selectMoreLines(-1, true); },
		    bindKey: {win: "Ctrl-Alt-Shift-Up", mac: "Ctrl-Alt-Shift-Up"},
		    scrollIntoView: "cursor",
		    readOnly: true
		}, {
		    name: "addCursorBelowSkipCurrent",
		    exec: function(editor) { editor.selectMoreLines(1, true); },
		    bindKey: {win: "Ctrl-Alt-Shift-Down", mac: "Ctrl-Alt-Shift-Down"},
		    scrollIntoView: "cursor",
		    readOnly: true
		}, {
		    name: "selectMoreBefore",
		    exec: function(editor) { editor.selectMore(-1); },
		    bindKey: {win: "Ctrl-Alt-Left", mac: "Ctrl-Alt-Left"},
		    scrollIntoView: "cursor",
		    readOnly: true
		}, {
		    name: "selectMoreAfter",
		    exec: function(editor) { editor.selectMore(1); },
		    bindKey: {win: "Ctrl-Alt-Right", mac: "Ctrl-Alt-Right"},
		    scrollIntoView: "cursor",
		    readOnly: true
		}, {
		    name: "selectNextBefore",
		    exec: function(editor) { editor.selectMore(-1, true); },
		    bindKey: {win: "Ctrl-Alt-Shift-Left", mac: "Ctrl-Alt-Shift-Left"},
		    scrollIntoView: "cursor",
		    readOnly: true
		}, {
		    name: "selectNextAfter",
		    exec: function(editor) { editor.selectMore(1, true); },
		    bindKey: {win: "Ctrl-Alt-Shift-Right", mac: "Ctrl-Alt-Shift-Right"},
		    scrollIntoView: "cursor",
		    readOnly: true
		}, {
		    name: "splitIntoLines",
		    exec: function(editor) { editor.multiSelect.splitIntoLines(); },
		    bindKey: {win: "Ctrl-Alt-L", mac: "Ctrl-Alt-L"},
		    readOnly: true
		}, {
		    name: "alignCursors",
		    exec: function(editor) { editor.alignCursors(); },
		    bindKey: {win: "Ctrl-Alt-A", mac: "Ctrl-Alt-A"},
		    scrollIntoView: "cursor"
		}, {
		    name: "findAll",
		    exec: function(editor) { editor.findAll(); },
		    bindKey: {win: "Ctrl-Alt-K", mac: "Ctrl-Alt-G"},
		    scrollIntoView: "cursor",
		    readOnly: true
		}];
		
		// commands active only in multiselect mode
		exports.multiSelectCommands = [{
		    name: "singleSelection",
		    bindKey: "esc",
		    exec: function(editor) { editor.exitMultiSelectMode(); },
		    scrollIntoView: "cursor",
		    readOnly: true,
		    isAvailable: function(editor) {return editor && editor.inMultiSelectMode}
		}];
		
		var HashHandler = require("../keyboard/hash_handler").HashHandler;
		exports.keyboardHandler = new HashHandler(exports.multiSelectCommands);
		
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/config.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var lang = require("./lib/lang");
		var oop = require("./lib/oop");
		var net = require("./lib/net");
		var AppConfig = require("./lib/app_config").AppConfig;
		
		module.exports = exports = new AppConfig();
		
		var global = (function() {
		    return this || typeof window != "undefined" && window;
		})();
		
		var options = {
		    packaged: false,
		    workerPath: null,
		    modePath: null,
		    themePath: null,
		    basePath: "",
		    suffix: ".js",
		    $moduleUrls: {}
		};
		
		exports.get = function(key) {
		    if (!options.hasOwnProperty(key))
		        throw new Error("Unknown config key: " + key);
		
		    return options[key];
		};
		
		exports.set = function(key, value) {
		    if (!options.hasOwnProperty(key))
		        throw new Error("Unknown config key: " + key);
		
		    options[key] = value;
		};
		
		exports.all = function() {
		    return lang.copyObject(options);
		};
		
		// module loading
		exports.moduleUrl = function(name, component) {
		    if (options.$moduleUrls[name])
		        return options.$moduleUrls[name];
		
		    var parts = name.split("/");
		    component = component || parts[parts.length - 2] || "";
		    
		    // todo make this configurable or get rid of '-'
		    var sep = component == "snippets" ? "/" : "-";
		    var base = parts[parts.length - 1];
		    if (component == "worker" && sep == "-") {
		        var re = new RegExp("^" + component + "[\\-_]|[\\-_]" + component + "$", "g");
		        base = base.replace(re, "");
		    }
		
		    if ((!base || base == component) && parts.length > 1)
		        base = parts[parts.length - 2];
		    var path = options[component + "Path"];
		    if (path == null) {
		        path = options.basePath;
		    } else if (sep == "/") {
		        component = sep = "";
		    }
		    if (path && path.slice(-1) != "/")
		        path += "/";
		    return path + component + sep + base + this.get("suffix");
		};
		
		exports.setModuleUrl = function(name, subst) {
		    return options.$moduleUrls[name] = subst;
		};
		
		exports.$loading = {};
		exports.loadModule = function(moduleName, onLoad) {
		    var module, moduleType;
		    if (Array.isArray(moduleName)) {
		        moduleType = moduleName[0];
		        moduleName = moduleName[1];
		    }
		
		    try {
		        module = require(moduleName);
		    } catch (e) {}
		    // require(moduleName) can return empty object if called after require([moduleName], callback)
		    if (module && !exports.$loading[moduleName])
		        return onLoad && onLoad(module);
		
		    if (!exports.$loading[moduleName])
		        exports.$loading[moduleName] = [];
		
		    exports.$loading[moduleName].push(onLoad);
		
		    if (exports.$loading[moduleName].length > 1)
		        return;
		
		    var afterLoad = function() {
		        require([moduleName], function(module) {
		            exports._emit("load.module", {name: moduleName, module: module});
		            var listeners = exports.$loading[moduleName];
		            exports.$loading[moduleName] = null;
		            listeners.forEach(function(onLoad) {
		                onLoad && onLoad(module);
		            });
		        });
		    };
		
		    if (!exports.get("packaged"))
		        return afterLoad();
		    net.loadScript(exports.moduleUrl(moduleName, moduleType), afterLoad);
		};
		
		// initialization
		function init(packaged) {
		    if (!global || !global.document)
		        return;
		    
		    options.packaged = packaged || require.packaged || module.packaged || (global.define && define.packaged);
		
		    var scriptOptions = {};
		    var scriptUrl = "";
		
		    // Use currentScript.ownerDocument in case this file was loaded from imported document. (HTML Imports)
		    var currentScript = (document.currentScript || document._currentScript ); // native or polyfill
		    var currentDocument = currentScript && currentScript.ownerDocument || document;
		    
		    var scripts = currentDocument.getElementsByTagName("script");
		    for (var i=0; i<scripts.length; i++) {
		        var script = scripts[i];
		
		        var src = script.src || script.getAttribute("src");
		        if (!src)
		            continue;
		
		        var attributes = script.attributes;
		        for (var j=0, l=attributes.length; j < l; j++) {
		            var attr = attributes[j];
		            if (attr.name.indexOf("data-ace-") === 0) {
		                scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, ""))] = attr.value;
		            }
		        }
		
		        var m = src.match(/^(.*)\/ace(\-\w+)?\.js(\?|$)/);
		        if (m)
		            scriptUrl = m[1];
		    }
		
		    if (scriptUrl) {
		        scriptOptions.base = scriptOptions.base || scriptUrl;
		        scriptOptions.packaged = true;
		    }
		
		    scriptOptions.basePath = scriptOptions.base;
		    scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;
		    scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;
		    scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;
		    delete scriptOptions.base;
		
		    for (var key in scriptOptions)
		        if (typeof scriptOptions[key] !== "undefined")
		            exports.set(key, scriptOptions[key]);
		}
		
		exports.init = init;
		
		function deHyphenate(str) {
		    return str.replace(/-(.)/g, function(m, m1) { return m1.toUpperCase(); });
		}
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/css/editor.css", ["require", "exports", "module", "window","__filename", "__dirname"],
 	function(require, exports, module, window, __filename, __dirname) {
 		module.exports = '.ace_editor {    position: relative;    overflow: hidden;    font: 12px/normal "Monaco", "Menlo", "Ubuntu Mono", "Consolas", "source-code-pro", monospace;    direction: ltr;    text-align: left;}.ace_scroller {    position: absolute;    overflow: hidden;    top: 0;    bottom: 0;    background-color: inherit;    -ms-user-select: none;    -moz-user-select: none;    -webkit-user-select: none;    user-select: none;    cursor: text;}.ace_content {    position: absolute;    -moz-box-sizing: border-box;    -webkit-box-sizing: border-box;    box-sizing: border-box;    min-width: 100%;}.ace_dragging .ace_scroller:before{    position: absolute;    top: 0;    left: 0;    right: 0;    bottom: 0;    content: "";    background: rgba(250, 250, 250, 0.01);    z-index: 1000;}.ace_dragging.ace_dark .ace_scroller:before{    background: rgba(0, 0, 0, 0.01);}.ace_selecting, .ace_selecting * {    cursor: text !important;}.ace_gutter {    position: absolute;    overflow : hidden;    width: auto;    top: 0;    bottom: 0;    left: 0;    cursor: default;    z-index: 4;    -ms-user-select: none;    -moz-user-select: none;    -webkit-user-select: none;    user-select: none;}.ace_gutter-active-line {    position: absolute;    left: 0;    right: 0;}.ace_scroller.ace_scroll-left {    box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;}.ace_gutter-cell {    padding-left: 19px;    padding-right: 6px;    background-repeat: no-repeat;}.ace_gutter-cell.ace_error {    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==");    background-repeat: no-repeat;    background-position: 2px center;}.ace_gutter-cell.ace_warning {    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==");    background-position: 2px center;}.ace_gutter-cell.ace_info {    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=");    background-position: 2px center;}.ace_dark .ace_gutter-cell.ace_info {    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC");}.ace_scrollbar {    position: absolute;    right: 0;    bottom: 0;    z-index: 6;}.ace_scrollbar-inner {    position: absolute;    cursor: text;    left: 0;    top: 0;}.ace_scrollbar-v{    overflow-x: hidden;    overflow-y: scroll;    top: 0;}.ace_scrollbar-h {    overflow-x: scroll;    overflow-y: hidden;    left: 0;}.ace_print-margin {    position: absolute;    height: 100%;}.ace_text-input {    position: absolute;    z-index: 0;    width: 0.5em;    height: 1em;    opacity: 0;    background: transparent;    -moz-appearance: none;    appearance: none;    border: none;    resize: none;    outline: none;    overflow: hidden;    font: inherit;    padding: 0 1px;    margin: 0 -1px;    text-indent: -1em;    -ms-user-select: text;    -moz-user-select: text;    -webkit-user-select: text;    user-select: text;    /*with `pre-line` chrome inserts &nbsp; instead of space*/    white-space: pre!important;}.ace_text-input.ace_composition {    background: inherit;    color: inherit;    z-index: 1000;    opacity: 1;    text-indent: 0;}.ace_layer {    z-index: 1;    position: absolute;    overflow: hidden;    /* workaround for chrome bug https://github.com/ajaxorg/ace/issues/2312*/    word-wrap: normal;    white-space: pre;    height: 100%;    width: 100%;    -moz-box-sizing: border-box;    -webkit-box-sizing: border-box;    box-sizing: border-box;    /* setting pointer-events: auto; on node under the mouse, which changes        during scroll, will break mouse wheel scrolling in Safari */    pointer-events: none;}.ace_gutter-layer {    position: relative;    width: auto;    text-align: right;    pointer-events: auto;}.ace_text-layer {    font: inherit !important;}.ace_cjk {    display: inline-block;    text-align: center;}.ace_cursor-layer {    z-index: 4;}.ace_cursor {    z-index: 4;    position: absolute;    -moz-box-sizing: border-box;    -webkit-box-sizing: border-box;    box-sizing: border-box;    border-left: 2px solid;    /* workaround for smooth cursor repaintng whole screen in chrome */    transform: translatez(0);}.ace_slim-cursors .ace_cursor {    border-left-width: 1px;}.ace_overwrite-cursors .ace_cursor {    border-left-width: 0;    border-bottom: 1px solid;}.ace_hidden-cursors .ace_cursor {    opacity: 0.2;}.ace_smooth-blinking .ace_cursor {    -webkit-transition: opacity 0.18s;            transition: opacity 0.18s;}.ace_editor.ace_multiselect .ace_cursor {    border-left-width: 1px;}.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {    position: absolute;    z-index: 3;}.ace_marker-layer .ace_selection {    position: absolute;    z-index: 5;}.ace_marker-layer .ace_bracket {    position: absolute;    z-index: 6;}.ace_marker-layer .ace_active-line {    position: absolute;    z-index: 2;}.ace_marker-layer .ace_selected-word {    position: absolute;    z-index: 4;    -moz-box-sizing: border-box;    -webkit-box-sizing: border-box;    box-sizing: border-box;}.ace_line .ace_fold {    -moz-box-sizing: border-box;    -webkit-box-sizing: border-box;    box-sizing: border-box;    display: inline-block;    height: 11px;    margin-top: -2px;    vertical-align: middle;    background-image:        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=");    background-repeat: no-repeat, repeat-x;    background-position: center center, top left;    color: transparent;    border: 1px solid black;    border-radius: 2px;    cursor: pointer;    pointer-events: auto;}.ace_dark .ace_fold {}.ace_fold:hover{    background-image:        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC");}.ace_tooltip {    background-color: #FFF;    background-image: -webkit-linear-gradient(top, transparent, rgba(0, 0, 0, 0.1));    background-image: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.1));    border: 1px solid gray;    border-radius: 1px;    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);    color: black;    max-width: 100%;    padding: 3px 4px;    position: fixed;    z-index: 999999;    -moz-box-sizing: border-box;    -webkit-box-sizing: border-box;    box-sizing: border-box;    cursor: default;    white-space: pre;    word-wrap: break-word;    line-height: normal;    font-style: normal;    font-weight: normal;    letter-spacing: normal;    pointer-events: none;}.ace_folding-enabled > .ace_gutter-cell {    padding-right: 13px;}.ace_fold-widget {    -moz-box-sizing: border-box;    -webkit-box-sizing: border-box;    box-sizing: border-box;    margin: 0 -12px 0 1px;    display: none;    width: 11px;    vertical-align: top;    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==");    background-repeat: no-repeat;    background-position: center;    border-radius: 3px;        border: 1px solid transparent;    cursor: pointer;}.ace_folding-enabled .ace_fold-widget {    display: inline-block;   }.ace_fold-widget.ace_end {    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==");}.ace_fold-widget.ace_closed {    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==");}.ace_fold-widget:hover {    border: 1px solid rgba(0, 0, 0, 0.3);    background-color: rgba(255, 255, 255, 0.2);    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);}.ace_fold-widget:active {    border: 1px solid rgba(0, 0, 0, 0.4);    background-color: rgba(0, 0, 0, 0.05);    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);}/** * Dark version for fold widgets */.ace_dark .ace_fold-widget {    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC");}.ace_dark .ace_fold-widget.ace_end {    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==");}.ace_dark .ace_fold-widget.ace_closed {    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==");}.ace_dark .ace_fold-widget:hover {    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);    background-color: rgba(255, 255, 255, 0.1);}.ace_dark .ace_fold-widget:active {    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);}.ace_fold-widget.ace_invalid {    background-color: #FFB4B4;    border-color: #DE5555;}.ace_fade-fold-widgets .ace_fold-widget {    -webkit-transition: opacity 0.4s ease 0.05s;            transition: opacity 0.4s ease 0.05s;    opacity: 0;}.ace_fade-fold-widgets:hover .ace_fold-widget {    -webkit-transition: opacity 0.05s ease 0.05s;            transition: opacity 0.05s ease 0.05s;    opacity:1;}.ace_underline {    text-decoration: underline;}.ace_bold {    font-weight: bold;}.ace_nobold .ace_bold {    font-weight: normal;}.ace_italic {    font-style: italic;}.ace_error-marker {    background-color: rgba(255, 0, 0,0.2);    position: absolute;    z-index: 9;}.ace_highlight-marker {    background-color: rgba(255, 255, 0,0.2);    position: absolute;    z-index: 8;}/*styles = []for (var i = 1; i < 16; i++) {    styles.push(".ace_br" + i + "{" + (        ["top-left", "top-right", "bottom-right", "bottom-left"]    ).map(function(x, j) {        return i & (1<<j) ? "border-" + x + "-radius: 3px;" : ""     }).filter(Boolean).join(" ") + "}")}styles.join("\n")*/.ace_br1 {border-top-left-radius    : 3px;}.ace_br2 {border-top-right-radius   : 3px;}.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}.ace_br4 {border-bottom-right-radius: 3px;}.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}.ace_br8 {border-bottom-left-radius : 3px;}.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}';
 	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });

(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/document.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var oop = require("./lib/oop");
		var applyDelta = require("./apply_delta").applyDelta;
		var EventEmitter = require("./lib/event_emitter").EventEmitter;
		var Range = require("./range").Range;
		var Anchor = require("./anchor").Anchor;
		
		/**
		 * Contains the text of the document. Document can be attached to several [[EditSession `EditSession`]]s. 
		 * At its core, `Document`s are just an array of strings, with each row in the document matching up to the array index.
		 *
		 * @class Document
		 **/
		
		/**
		 *
		 * Creates a new `Document`. If `text` is included, the `Document` contains those strings; otherwise, it's empty.
		 * @param {String | Array} text The starting text
		 * @constructor
		 **/
		
		var Document = function(textOrLines) {
		    this.$lines = [""];
		
		    // There has to be one line at least in the document. If you pass an empty
		    // string to the insert function, nothing will happen. Workaround.
		    if (textOrLines.length === 0) {
		        this.$lines = [""];
		    } else if (Array.isArray(textOrLines)) {
		        this.insertMergedLines({row: 0, column: 0}, textOrLines);
		    } else {
		        this.insert({row: 0, column:0}, textOrLines);
		    }
		};
		
		(function() {
		
		    oop.implement(this, EventEmitter);
		
		    /**
		     * Replaces all the lines in the current `Document` with the value of `text`.
		     *
		     * @param {String} text The text to use
		     **/
		    this.setValue = function(text) {
		        var len = this.getLength() - 1;
		        this.remove(new Range(0, 0, len, this.getLine(len).length));
		        this.insert({row: 0, column: 0}, text);
		    };
		
		    /**
		     * Returns all the lines in the document as a single string, joined by the new line character.
		     **/
		    this.getValue = function() {
		        return this.getAllLines().join(this.getNewLineCharacter());
		    };
		
		    /** 
		     * Creates a new `Anchor` to define a floating point in the document.
		     * @param {Number} row The row number to use
		     * @param {Number} column The column number to use
		     *
		     **/
		    this.createAnchor = function(row, column) {
		        return new Anchor(this, row, column);
		    };
		
		    /** 
		     * Splits a string of text on any newline (`\n`) or carriage-return (`\r`) characters.
		     *
		     * @method $split
		     * @param {String} text The text to work with
		     * @returns {String} A String array, with each index containing a piece of the original `text` string.
		     *
		     **/
		
		    // check for IE split bug
		    if ("aaa".split(/a/).length === 0) {
		        this.$split = function(text) {
		            return text.replace(/\r\n|\r/g, "\n").split("\n");
		        };
		    } else {
		        this.$split = function(text) {
		            return text.split(/\r\n|\r|\n/);
		        };
		    }
		
		
		    this.$detectNewLine = function(text) {
		        var match = text.match(/^.*?(\r\n|\r|\n)/m);
		        this.$autoNewLine = match ? match[1] : "\n";
		        this._signal("changeNewLineMode");
		    };
		
		    /**
		     * Returns the newline character that's being used, depending on the value of `newLineMode`. 
		     * @returns {String} If `newLineMode == windows`, `\r\n` is returned.  
		     *  If `newLineMode == unix`, `\n` is returned.  
		     *  If `newLineMode == auto`, the value of `autoNewLine` is returned.
		     *
		     **/
		    this.getNewLineCharacter = function() {
		        switch (this.$newLineMode) {
		          case "windows":
		            return "\r\n";
		          case "unix":
		            return "\n";
		          default:
		            return this.$autoNewLine || "\n";
		        }
		    };
		
		    this.$autoNewLine = "";
		    this.$newLineMode = "auto";
		    /**
		     * [Sets the new line mode.]{: #Document.setNewLineMode.desc}
		     * @param {String} newLineMode [The newline mode to use; can be either `windows`, `unix`, or `auto`]{: #Document.setNewLineMode.param}
		     *
		     **/
		    this.setNewLineMode = function(newLineMode) {
		        if (this.$newLineMode === newLineMode)
		            return;
		
		        this.$newLineMode = newLineMode;
		        this._signal("changeNewLineMode");
		    };
		
		    /**
		     * [Returns the type of newlines being used; either `windows`, `unix`, or `auto`]{: #Document.getNewLineMode}
		     * @returns {String}
		     **/
		    this.getNewLineMode = function() {
		        return this.$newLineMode;
		    };
		
		    /**
		     * Returns `true` if `text` is a newline character (either `\r\n`, `\r`, or `\n`).
		     * @param {String} text The text to check
		     *
		     **/
		    this.isNewLine = function(text) {
		        return (text == "\r\n" || text == "\r" || text == "\n");
		    };
		
		    /**
		     * Returns a verbatim copy of the given line as it is in the document
		     * @param {Number} row The row index to retrieve
		     *
		     **/
		    this.getLine = function(row) {
		        return this.$lines[row] || "";
		    };
		
		    /**
		     * Returns an array of strings of the rows between `firstRow` and `lastRow`. This function is inclusive of `lastRow`.
		     * @param {Number} firstRow The first row index to retrieve
		     * @param {Number} lastRow The final row index to retrieve
		     *
		     **/
		    this.getLines = function(firstRow, lastRow) {
		        return this.$lines.slice(firstRow, lastRow + 1);
		    };
		
		    /**
		     * Returns all lines in the document as string array.
		     **/
		    this.getAllLines = function() {
		        return this.getLines(0, this.getLength());
		    };
		
		    /**
		     * Returns the number of rows in the document.
		     **/
		    this.getLength = function() {
		        return this.$lines.length;
		    };
		
		    /**
		     * Returns all the text within `range` as a single string.
		     * @param {Range} range The range to work with.
		     * 
		     * @returns {String}
		     **/
		    this.getTextRange = function(range) {
		        return this.getLinesForRange(range).join(this.getNewLineCharacter());
		    };
		    
		    /**
		     * Returns all the text within `range` as an array of lines.
		     * @param {Range} range The range to work with.
		     * 
		     * @returns {Array}
		     **/
		    this.getLinesForRange = function(range) {
		        var lines;
		        if (range.start.row === range.end.row) {
		            // Handle a single-line range.
		            lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
		        } else {
		            // Handle a multi-line range.
		            lines = this.getLines(range.start.row, range.end.row);
		            lines[0] = (lines[0] || "").substring(range.start.column);
		            var l = lines.length - 1;
		            if (range.end.row - range.start.row == l)
		                lines[l] = lines[l].substring(0, range.end.column);
		        }
		        return lines;
		    };
		
		    // Deprecated methods retained for backwards compatibility.
		    this.insertLines = function(row, lines) {
		        console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead.");
		        return this.insertFullLines(row, lines);
		    };
		    this.removeLines = function(firstRow, lastRow) {
		        console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead.");
		        return this.removeFullLines(firstRow, lastRow);
		    };
		    this.insertNewLine = function(position) {
		        console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.");
		        return this.insertMergedLines(position, ["", ""]);
		    };
		
		    /**
		     * Inserts a block of `text` at the indicated `position`.
		     * @param {Object} position The position to start inserting at; it's an object that looks like `{ row: row, column: column}`
		     * @param {String} text A chunk of text to insert
		     * @returns {Object} The position ({row, column}) of the last line of `text`. If the length of `text` is 0, this function simply returns `position`. 
		     *
		     **/
		    this.insert = function(position, text) {
		        // Only detect new lines if the document has no line break yet.
		        if (this.getLength() <= 1)
		            this.$detectNewLine(text);
		        
		        return this.insertMergedLines(position, this.$split(text));
		    };
		    
		    /**
		     * Inserts `text` into the `position` at the current row. This method also triggers the `"change"` event.
		     * 
		     * This differs from the `insert` method in two ways:
		     *   1. This does NOT handle newline characters (single-line text only).
		     *   2. This is faster than the `insert` method for single-line text insertions.
		     * 
		     * @param {Object} position The position to insert at; it's an object that looks like `{ row: row, column: column}`
		     * @param {String} text A chunk of text
		     * @returns {Object} Returns an object containing the final row and column, like this:  
		     *     ```
		     *     {row: endRow, column: 0}
		     *     ```
		     **/
		    this.insertInLine = function(position, text) {
		        var start = this.clippedPos(position.row, position.column);
		        var end = this.pos(position.row, position.column + text.length);
		        
		        this.applyDelta({
		            start: start,
		            end: end,
		            action: "insert",
		            lines: [text]
		        }, true);
		        
		        return this.clonePos(end);
		    };
		    
		    this.clippedPos = function(row, column) {
		        var length = this.getLength();
		        if (row === undefined) {
		            row = length;
		        } else if (row < 0) {
		            row = 0;
		        } else if (row >= length) {
		            row = length - 1;
		            column = undefined;
		        }
		        var line = this.getLine(row);
		        if (column == undefined)
		            column = line.length;
		        column = Math.min(Math.max(column, 0), line.length);
		        return {row: row, column: column};
		    };
		    
		    this.clonePos = function(pos) {
		        return {row: pos.row, column: pos.column};
		    };
		    
		    this.pos = function(row, column) {
		        return {row: row, column: column};
		    };
		    
		    this.$clipPosition = function(position) {
		        var length = this.getLength();
		        if (position.row >= length) {
		            position.row = Math.max(0, length - 1);
		            position.column = this.getLine(length - 1).length;
		        } else {
		            position.row = Math.max(0, position.row);
		            position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
		        }
		        return position;
		    };
		
		    /**
		     * Fires whenever the document changes.
		     *
		     * Several methods trigger different `"change"` events. Below is a list of each action type, followed by each property that's also available:
		     *
		     *  * `"insert"`
		     *    * `range`: the [[Range]] of the change within the document
		     *    * `lines`: the lines being added
		     *  * `"remove"`
		     *    * `range`: the [[Range]] of the change within the document
		     *    * `lines`: the lines being removed
		     *
		     * @event change
		     * @param {Object} e Contains at least one property called `"action"`. `"action"` indicates the action that triggered the change. Each action also has a set of additional properties.
		     *
		     **/
		    
		    /**
		     * Inserts the elements in `lines` into the document as full lines (does not merge with existing line), starting at the row index given by `row`. This method also triggers the `"change"` event.
		     * @param {Number} row The index of the row to insert at
		     * @param {Array} lines An array of strings
		     * @returns {Object} Contains the final row and column, like this:  
		     *   ```
		     *   {row: endRow, column: 0}
		     *   ```  
		     *   If `lines` is empty, this function returns an object containing the current row, and column, like this:  
		     *   ``` 
		     *   {row: row, column: 0}
		     *   ```
		     *
		     **/
		    this.insertFullLines = function(row, lines) {
		        // Clip to document.
		        // Allow one past the document end.
		        row = Math.min(Math.max(row, 0), this.getLength());
		        
		        // Calculate insertion point.
		        var column = 0;
		        if (row < this.getLength()) {
		            // Insert before the specified row.
		            lines = lines.concat([""]);
		            column = 0;
		        } else {
		            // Insert after the last row in the document.
		            lines = [""].concat(lines);
		            row--;
		            column = this.$lines[row].length;
		        }
		        
		        // Insert.
		        this.insertMergedLines({row: row, column: column}, lines);
		    };
		
		    /**
		     * Inserts the elements in `lines` into the document, starting at the position index given by `row`. This method also triggers the `"change"` event.
		     * @param {Number} row The index of the row to insert at
		     * @param {Array} lines An array of strings
		     * @returns {Object} Contains the final row and column, like this:  
		     *   ```
		     *   {row: endRow, column: 0}
		     *   ```  
		     *   If `lines` is empty, this function returns an object containing the current row, and column, like this:  
		     *   ``` 
		     *   {row: row, column: 0}
		     *   ```
		     *
		     **/    
		    this.insertMergedLines = function(position, lines) {
		        var start = this.clippedPos(position.row, position.column);
		        var end = {
		            row: start.row + lines.length - 1,
		            column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
		        };
		        
		        this.applyDelta({
		            start: start,
		            end: end,
		            action: "insert",
		            lines: lines
		        });
		        
		        return this.clonePos(end);
		    };
		
		    /**
		     * Removes the `range` from the document.
		     * @param {Range} range A specified Range to remove
		     * @returns {Object} Returns the new `start` property of the range, which contains `startRow` and `startColumn`. If `range` is empty, this function returns the unmodified value of `range.start`.
		     *
		     **/
		    this.remove = function(range) {
		        var start = this.clippedPos(range.start.row, range.start.column);
		        var end = this.clippedPos(range.end.row, range.end.column);
		        this.applyDelta({
		            start: start,
		            end: end,
		            action: "remove",
		            lines: this.getLinesForRange({start: start, end: end})
		        });
		        return this.clonePos(start);
		    };
		
		    /**
		     * Removes the specified columns from the `row`. This method also triggers a `"change"` event.
		     * @param {Number} row The row to remove from
		     * @param {Number} startColumn The column to start removing at 
		     * @param {Number} endColumn The column to stop removing at
		     * @returns {Object} Returns an object containing `startRow` and `startColumn`, indicating the new row and column values.<br/>If `startColumn` is equal to `endColumn`, this function returns nothing.
		     *
		     **/
		    this.removeInLine = function(row, startColumn, endColumn) {
		        var start = this.clippedPos(row, startColumn);
		        var end = this.clippedPos(row, endColumn);
		        
		        this.applyDelta({
		            start: start,
		            end: end,
		            action: "remove",
		            lines: this.getLinesForRange({start: start, end: end})
		        }, true);
		        
		        return this.clonePos(start);
		    };
		
		    /**
		     * Removes a range of full lines. This method also triggers the `"change"` event.
		     * @param {Number} firstRow The first row to be removed
		     * @param {Number} lastRow The last row to be removed
		     * @returns {[String]} Returns all the removed lines.
		     *
		     **/
		    this.removeFullLines = function(firstRow, lastRow) {
		        // Clip to document.
		        firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
		        lastRow  = Math.min(Math.max(0, lastRow ), this.getLength() - 1);
		        
		        // Calculate deletion range.
		        // Delete the ending new line unless we're at the end of the document.
		        // If we're at the end of the document, delete the starting new line.
		        var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;
		        var deleteLastNewLine  = lastRow  < this.getLength() - 1;
		        var startRow = ( deleteFirstNewLine ? firstRow - 1                  : firstRow                    );
		        var startCol = ( deleteFirstNewLine ? this.getLine(startRow).length : 0                           );
		        var endRow   = ( deleteLastNewLine  ? lastRow + 1                   : lastRow                     );
		        var endCol   = ( deleteLastNewLine  ? 0                             : this.getLine(endRow).length ); 
		        var range = new Range(startRow, startCol, endRow, endCol);
		        
		        // Store delelted lines with bounding newlines ommitted (maintains previous behavior).
		        var deletedLines = this.$lines.slice(firstRow, lastRow + 1);
		        
		        this.applyDelta({
		            start: range.start,
		            end: range.end,
		            action: "remove",
		            lines: this.getLinesForRange(range)
		        });
		        
		        // Return the deleted lines.
		        return deletedLines;
		    };
		
		    /**
		     * Removes the new line between `row` and the row immediately following it. This method also triggers the `"change"` event.
		     * @param {Number} row The row to check
		     *
		     **/
		    this.removeNewLine = function(row) {
		        if (row < this.getLength() - 1 && row >= 0) {
		            this.applyDelta({
		                start: this.pos(row, this.getLine(row).length),
		                end: this.pos(row + 1, 0),
		                action: "remove",
		                lines: ["", ""]
		            });
		        }
		    };
		
		    /**
		     * Replaces a range in the document with the new `text`.
		     * @param {Range} range A specified Range to replace
		     * @param {String} text The new text to use as a replacement
		     * @returns {Object} Returns an object containing the final row and column, like this:
		     *     {row: endRow, column: 0}
		     * If the text and range are empty, this function returns an object containing the current `range.start` value.
		     * If the text is the exact same as what currently exists, this function returns an object containing the current `range.end` value.
		     *
		     **/
		    this.replace = function(range, text) {
		        if (!(range instanceof Range))
		            range = Range.fromPoints(range.start, range.end);
		        if (text.length === 0 && range.isEmpty())
		            return range.start;
		
		        // Shortcut: If the text we want to insert is the same as it is already
		        // in the document, we don't have to replace anything.
		        if (text == this.getTextRange(range))
		            return range.end;
		
		        this.remove(range);
		        var end;
		        if (text) {
		            end = this.insert(range.start, text);
		        }
		        else {
		            end = range.start;
		        }
		        
		        return end;
		    };
		
		    /**
		     * Applies all changes in `deltas` to the document.
		     * @param {Array} deltas An array of delta objects (can include "insert" and "remove" actions)
		     **/
		    this.applyDeltas = function(deltas) {
		        for (var i=0; i<deltas.length; i++) {
		            this.applyDelta(deltas[i]);
		        }
		    };
		    
		    /**
		     * Reverts all changes in `deltas` from the document.
		     * @param {Array} deltas An array of delta objects (can include "insert" and "remove" actions)
		     **/
		    this.revertDeltas = function(deltas) {
		        for (var i=deltas.length-1; i>=0; i--) {
		            this.revertDelta(deltas[i]);
		        }
		    };
		    
		    /**
		     * Applies `delta` to the document.
		     * @param {Object} delta A delta object (can include "insert" and "remove" actions)
		     **/
		    this.applyDelta = function(delta, doNotValidate) {
		        var isInsert = delta.action == "insert";
		        // An empty range is a NOOP.
		        if (isInsert ? delta.lines.length <= 1 && !delta.lines[0]
		            : !Range.comparePoints(delta.start, delta.end)) {
		            return;
		        }
		        
		        if (isInsert && delta.lines.length > 20000)
		            this.$splitAndapplyLargeDelta(delta, 20000);
		        
		        // Apply.
		        applyDelta(this.$lines, delta, doNotValidate);
		        this._signal("change", delta);
		    };
		    
		    this.$splitAndapplyLargeDelta = function(delta, MAX) {
		        // Split large insert deltas. This is necessary because:
		        //    1. We need to support splicing delta lines into the document via $lines.splice.apply(...)
		        //    2. fn.apply() doesn't work for a large number of params. The smallest threshold is on chrome 40 ~42000.
		        // we use 20000 to leave some space for actual stack
		        // 
		        // To Do: Ideally we'd be consistent and also split 'delete' deltas. We don't do this now, because delete
		        //        delta handling is too slow. If we make delete delta handling faster we can split all large deltas
		        //        as shown in https://gist.github.com/aldendaniels/8367109#file-document-snippet-js
		        //        If we do this, update validateDelta() to limit the number of lines in a delete delta.
		        var lines = delta.lines;
		        var l = lines.length;
		        var row = delta.start.row; 
		        var column = delta.start.column;
		        var from = 0, to = 0;
		        do {
		            from = to;
		            to += MAX - 1;
		            var chunk = lines.slice(from, to);
		            if (to > l) {
		                // Update remaining delta.
		                delta.lines = chunk;
		                delta.start.row = row + from;
		                delta.start.column = column;
		                break;
		            }
		            chunk.push("");
		            this.applyDelta({
		                start: this.pos(row + from, column),
		                end: this.pos(row + to, column = 0),
		                action: delta.action,
		                lines: chunk
		            }, true);
		        } while(true);
		    };
		    
		    /**
		     * Reverts `delta` from the document.
		     * @param {Object} delta A delta object (can include "insert" and "remove" actions)
		     **/
		    this.revertDelta = function(delta) {
		        this.applyDelta({
		            start: this.clonePos(delta.start),
		            end: this.clonePos(delta.end),
		            action: (delta.action == "insert" ? "remove" : "insert"),
		            lines: delta.lines.slice()
		        });
		    };
		    
		    /**
		     * Converts an index position in a document to a `{row, column}` object.
		     *
		     * Index refers to the "absolute position" of a character in the document. For example:
		     *
		     * ```javascript
		     * var x = 0; // 10 characters, plus one for newline
		     * var y = -1;
		     * ```
		     * 
		     * Here, `y` is an index 15: 11 characters for the first row, and 5 characters until `y` in the second.
		     *
		     * @param {Number} index An index to convert
		     * @param {Number} startRow=0 The row from which to start the conversion
		     * @returns {Object} A `{row, column}` object of the `index` position
		     */
		    this.indexToPosition = function(index, startRow) {
		        var lines = this.$lines || this.getAllLines();
		        var newlineLength = this.getNewLineCharacter().length;
		        for (var i = startRow || 0, l = lines.length; i < l; i++) {
		            index -= lines[i].length + newlineLength;
		            if (index < 0)
		                return {row: i, column: index + lines[i].length + newlineLength};
		        }
		        return {row: l-1, column: lines[l-1].length};
		    };
		
		    /**
		     * Converts the `{row, column}` position in a document to the character's index.
		     *
		     * Index refers to the "absolute position" of a character in the document. For example:
		     *
		     * ```javascript
		     * var x = 0; // 10 characters, plus one for newline
		     * var y = -1;
		     * ```
		     * 
		     * Here, `y` is an index 15: 11 characters for the first row, and 5 characters until `y` in the second.
		     *
		     * @param {Object} pos The `{row, column}` to convert
		     * @param {Number} startRow=0 The row from which to start the conversion
		     * @returns {Number} The index position in the document
		     */
		    this.positionToIndex = function(pos, startRow) {
		        var lines = this.$lines || this.getAllLines();
		        var newlineLength = this.getNewLineCharacter().length;
		        var index = 0;
		        var row = Math.min(pos.row, lines.length);
		        for (var i = startRow || 0; i < row; ++i)
		            index += lines[i].length + newlineLength;
		
		        return index + pos.column;
		    };
		
		}).call(Document.prototype);
		
		exports.Document = Document;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/edit_session/bracket_match.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var TokenIterator = require("../token_iterator").TokenIterator;
		var Range = require("../range").Range;
		
		
		function BracketMatch() {
		
		    this.findMatchingBracket = function(position, chr) {
		        if (position.column == 0) return null;
		
		        var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column-1);
		        if (charBeforeCursor == "") return null;
		
		        var match = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
		        if (!match)
		            return null;
		
		        if (match[1])
		            return this.$findClosingBracket(match[1], position);
		        else
		            return this.$findOpeningBracket(match[2], position);
		    };
		    
		    this.getBracketRange = function(pos) {
		        var line = this.getLine(pos.row);
		        var before = true, range;
		
		        var chr = line.charAt(pos.column-1);
		        var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
		        if (!match) {
		            chr = line.charAt(pos.column);
		            pos = {row: pos.row, column: pos.column + 1};
		            match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
		            before = false;
		        }
		        if (!match)
		            return null;
		
		        if (match[1]) {
		            var bracketPos = this.$findClosingBracket(match[1], pos);
		            if (!bracketPos)
		                return null;
		            range = Range.fromPoints(pos, bracketPos);
		            if (!before) {
		                range.end.column++;
		                range.start.column--;
		            }
		            range.cursor = range.end;
		        } else {
		            var bracketPos = this.$findOpeningBracket(match[2], pos);
		            if (!bracketPos)
		                return null;
		            range = Range.fromPoints(bracketPos, pos);
		            if (!before) {
		                range.start.column++;
		                range.end.column--;
		            }
		            range.cursor = range.start;
		        }
		        
		        return range;
		    };
		
		    this.$brackets = {
		        ")": "(",
		        "(": ")",
		        "]": "[",
		        "[": "]",
		        "{": "}",
		        "}": "{"
		    };
		
		    this.$findOpeningBracket = function(bracket, position, typeRe) {
		        var openBracket = this.$brackets[bracket];
		        var depth = 1;
		
		        var iterator = new TokenIterator(this, position.row, position.column);
		        var token = iterator.getCurrentToken();
		        if (!token)
		            token = iterator.stepForward();
		        if (!token)
		            return;
		        
		         if (!typeRe){
		            typeRe = new RegExp(
		                "(\\.?" +
		                token.type.replace(".", "\\.").replace("rparen", ".paren")
		                    .replace(/\b(?:end)\b/, "(?:start|begin|end)")
		                + ")+"
		            );
		        }
		        
		        // Start searching in token, just before the character at position.column
		        var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
		        var value = token.value;
		        
		        while (true) {
		        
		            while (valueIndex >= 0) {
		                var chr = value.charAt(valueIndex);
		                if (chr == openBracket) {
		                    depth -= 1;
		                    if (depth == 0) {
		                        return {row: iterator.getCurrentTokenRow(),
		                            column: valueIndex + iterator.getCurrentTokenColumn()};
		                    }
		                }
		                else if (chr == bracket) {
		                    depth += 1;
		                }
		                valueIndex -= 1;
		            }
		
		            // Scan backward through the document, looking for the next token
		            // whose type matches typeRe
		            do {
		                token = iterator.stepBackward();
		            } while (token && !typeRe.test(token.type));
		
		            if (token == null)
		                break;
		                
		            value = token.value;
		            valueIndex = value.length - 1;
		        }
		        
		        return null;
		    };
		
		    this.$findClosingBracket = function(bracket, position, typeRe) {
		        var closingBracket = this.$brackets[bracket];
		        var depth = 1;
		
		        var iterator = new TokenIterator(this, position.row, position.column);
		        var token = iterator.getCurrentToken();
		        if (!token)
		            token = iterator.stepForward();
		        if (!token)
		            return;
		
		        if (!typeRe){
		            typeRe = new RegExp(
		                "(\\.?" +
		                token.type.replace(".", "\\.").replace("lparen", ".paren")
		                    .replace(/\b(?:start|begin)\b/, "(?:start|begin|end)")
		                + ")+"
		            );
		        }
		
		        // Start searching in token, after the character at position.column
		        var valueIndex = position.column - iterator.getCurrentTokenColumn();
		
		        while (true) {
		
		            var value = token.value;
		            var valueLength = value.length;
		            while (valueIndex < valueLength) {
		                var chr = value.charAt(valueIndex);
		                if (chr == closingBracket) {
		                    depth -= 1;
		                    if (depth == 0) {
		                        return {row: iterator.getCurrentTokenRow(),
		                            column: valueIndex + iterator.getCurrentTokenColumn()};
		                    }
		                }
		                else if (chr == bracket) {
		                    depth += 1;
		                }
		                valueIndex += 1;
		            }
		
		            // Scan forward through the document, looking for the next token
		            // whose type matches typeRe
		            do {
		                token = iterator.stepForward();
		            } while (token && !typeRe.test(token.type));
		
		            if (token == null)
		                break;
		
		            valueIndex = 0;
		        }
		        
		        return null;
		    };
		}
		exports.BracketMatch = BracketMatch;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/edit_session/fold.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var Range = require("../range").Range;
		var RangeList = require("../range_list").RangeList;
		var oop = require("../lib/oop")
		/*
		 * Simple fold-data struct.
		 **/
		var Fold = exports.Fold = function(range, placeholder) {
		    this.foldLine = null;
		    this.placeholder = placeholder;
		    this.range = range;
		    this.start = range.start;
		    this.end = range.end;
		
		    this.sameRow = range.start.row == range.end.row;
		    this.subFolds = this.ranges = [];
		};
		
		oop.inherits(Fold, RangeList);
		
		(function() {
		
		    this.toString = function() {
		        return '"' + this.placeholder + '" ' + this.range.toString();
		    };
		
		    this.setFoldLine = function(foldLine) {
		        this.foldLine = foldLine;
		        this.subFolds.forEach(function(fold) {
		            fold.setFoldLine(foldLine);
		        });
		    };
		
		    this.clone = function() {
		        var range = this.range.clone();
		        var fold = new Fold(range, this.placeholder);
		        this.subFolds.forEach(function(subFold) {
		            fold.subFolds.push(subFold.clone());
		        });
		        fold.collapseChildren = this.collapseChildren;
		        return fold;
		    };
		
		    this.addSubFold = function(fold) {
		        if (this.range.isEqual(fold))
		            return;
		
		        if (!this.range.containsRange(fold))
		            throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);
		
		        // transform fold to local coordinates
		        consumeRange(fold, this.start);
		
		        var row = fold.start.row, column = fold.start.column;
		        for (var i = 0, cmp = -1; i < this.subFolds.length; i++) {
		            cmp = this.subFolds[i].range.compare(row, column);
		            if (cmp != 1)
		                break;
		        }
		        var afterStart = this.subFolds[i];
		
		        if (cmp == 0)
		            return afterStart.addSubFold(fold);
		
		        // cmp == -1
		        var row = fold.range.end.row, column = fold.range.end.column;
		        for (var j = i, cmp = -1; j < this.subFolds.length; j++) {
		            cmp = this.subFolds[j].range.compare(row, column);
		            if (cmp != 1)
		                break;
		        }
		        var afterEnd = this.subFolds[j];
		
		        if (cmp == 0)
		            throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);
		
		        var consumedFolds = this.subFolds.splice(i, j - i, fold);
		        fold.setFoldLine(this.foldLine);
		
		        return fold;
		    };
		    
		    this.restoreRange = function(range) {
		        return restoreRange(range, this.start);
		    };
		
		}).call(Fold.prototype);
		
		function consumePoint(point, anchor) {
		    point.row -= anchor.row;
		    if (point.row == 0)
		        point.column -= anchor.column;
		}
		function consumeRange(range, anchor) {
		    consumePoint(range.start, anchor);
		    consumePoint(range.end, anchor);
		}
		function restorePoint(point, anchor) {
		    if (point.row == 0)
		        point.column += anchor.column;
		    point.row += anchor.row;
		}
		function restoreRange(range, anchor) {
		    restorePoint(range.start, anchor);
		    restorePoint(range.end, anchor);
		}
		
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/edit_session/fold_line.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var Range = require("../range").Range;
		
		/*
		 * If an array is passed in, the folds are expected to be sorted already.
		 */
		function FoldLine(foldData, folds) {
		    this.foldData = foldData;
		    if (Array.isArray(folds)) {
		        this.folds = folds;
		    } else {
		        folds = this.folds = [ folds ];
		    }
		
		    var last = folds[folds.length - 1];
		    this.range = new Range(folds[0].start.row, folds[0].start.column,
		                           last.end.row, last.end.column);
		    this.start = this.range.start;
		    this.end   = this.range.end;
		
		    this.folds.forEach(function(fold) {
		        fold.setFoldLine(this);
		    }, this);
		}
		
		(function() {
		    /*
		     * Note: This doesn't update wrapData!
		     */
		    this.shiftRow = function(shift) {
		        this.start.row += shift;
		        this.end.row += shift;
		        this.folds.forEach(function(fold) {
		            fold.start.row += shift;
		            fold.end.row += shift;
		        });
		    };
		
		    this.addFold = function(fold) {
		        if (fold.sameRow) {
		            if (fold.start.row < this.startRow || fold.endRow > this.endRow) {
		                throw new Error("Can't add a fold to this FoldLine as it has no connection");
		            }
		            this.folds.push(fold);
		            this.folds.sort(function(a, b) {
		                return -a.range.compareEnd(b.start.row, b.start.column);
		            });
		            if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {
		                this.end.row = fold.end.row;
		                this.end.column =  fold.end.column;
		            } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {
		                this.start.row = fold.start.row;
		                this.start.column = fold.start.column;
		            }
		        } else if (fold.start.row == this.end.row) {
		            this.folds.push(fold);
		            this.end.row = fold.end.row;
		            this.end.column = fold.end.column;
		        } else if (fold.end.row == this.start.row) {
		            this.folds.unshift(fold);
		            this.start.row = fold.start.row;
		            this.start.column = fold.start.column;
		        } else {
		            throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
		        }
		        fold.foldLine = this;
		    };
		
		    this.containsRow = function(row) {
		        return row >= this.start.row && row <= this.end.row;
		    };
		
		    this.walk = function(callback, endRow, endColumn) {
		        var lastEnd = 0,
		            folds = this.folds,
		            fold,
		            cmp, stop, isNewRow = true;
		
		        if (endRow == null) {
		            endRow = this.end.row;
		            endColumn = this.end.column;
		        }
		
		        for (var i = 0; i < folds.length; i++) {
		            fold = folds[i];
		
		            cmp = fold.range.compareStart(endRow, endColumn);
		            // This fold is after the endRow/Column.
		            if (cmp == -1) {
		                callback(null, endRow, endColumn, lastEnd, isNewRow);
		                return;
		            }
		
		            stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
		            stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);
		
		            // If the user requested to stop the walk or endRow/endColumn is
		            // inside of this fold (cmp == 0), then end here.
		            if (stop || cmp === 0) {
		                return;
		            }
		
		            // Note the new lastEnd might not be on the same line. However,
		            // it's the callback's job to recognize this.
		            isNewRow = !fold.sameRow;
		            lastEnd = fold.end.column;
		        }
		        callback(null, endRow, endColumn, lastEnd, isNewRow);
		    };
		
		    this.getNextFoldTo = function(row, column) {
		        var fold, cmp;
		        for (var i = 0; i < this.folds.length; i++) {
		            fold = this.folds[i];
		            cmp = fold.range.compareEnd(row, column);
		            if (cmp == -1) {
		                return {
		                    fold: fold,
		                    kind: "after"
		                };
		            } else if (cmp === 0) {
		                return {
		                    fold: fold,
		                    kind: "inside"
		                };
		            }
		        }
		        return null;
		    };
		
		    this.addRemoveChars = function(row, column, len) {
		        var ret = this.getNextFoldTo(row, column),
		            fold, folds;
		        if (ret) {
		            fold = ret.fold;
		            if (ret.kind == "inside"
		                && fold.start.column != column
		                && fold.start.row != row)
		            {
		                //throwing here breaks whole editor
		                //TODO: properly handle this
		                window.console && window.console.log(row, column, fold);
		            } else if (fold.start.row == row) {
		                folds = this.folds;
		                var i = folds.indexOf(fold);
		                if (i === 0) {
		                    this.start.column += len;
		                }
		                for (i; i < folds.length; i++) {
		                    fold = folds[i];
		                    fold.start.column += len;
		                    if (!fold.sameRow) {
		                        return;
		                    }
		                    fold.end.column += len;
		                }
		                this.end.column += len;
		            }
		        }
		    };
		
		    this.split = function(row, column) {
		        var pos = this.getNextFoldTo(row, column);
		        
		        if (!pos || pos.kind == "inside")
		            return null;
		            
		        var fold = pos.fold;
		        var folds = this.folds;
		        var foldData = this.foldData;
		        
		        var i = folds.indexOf(fold);
		        var foldBefore = folds[i - 1];
		        this.end.row = foldBefore.end.row;
		        this.end.column = foldBefore.end.column;
		
		        // Remove the folds after row/column and create a new FoldLine
		        // containing these removed folds.
		        folds = folds.splice(i, folds.length - i);
		
		        var newFoldLine = new FoldLine(foldData, folds);
		        foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
		        return newFoldLine;
		    };
		
		    this.merge = function(foldLineNext) {
		        var folds = foldLineNext.folds;
		        for (var i = 0; i < folds.length; i++) {
		            this.addFold(folds[i]);
		        }
		        // Remove the foldLineNext - no longer needed, as
		        // it's merged now with foldLineNext.
		        var foldData = this.foldData;
		        foldData.splice(foldData.indexOf(foldLineNext), 1);
		    };
		
		    this.toString = function() {
		        var ret = [this.range.toString() + ": [" ];
		
		        this.folds.forEach(function(fold) {
		            ret.push("  " + fold.toString());
		        });
		        ret.push("]");
		        return ret.join("\n");
		    };
		
		    this.idxToPosition = function(idx) {
		        var lastFoldEndColumn = 0;
		
		        for (var i = 0; i < this.folds.length; i++) {
		            var fold = this.folds[i];
		
		            idx -= fold.start.column - lastFoldEndColumn;
		            if (idx < 0) {
		                return {
		                    row: fold.start.row,
		                    column: fold.start.column + idx
		                };
		            }
		
		            idx -= fold.placeholder.length;
		            if (idx < 0) {
		                return fold.start;
		            }
		
		            lastFoldEndColumn = fold.end.column;
		        }
		
		        return {
		            row: this.end.row,
		            column: this.end.column + idx
		        };
		    };
		}).call(FoldLine.prototype);
		
		exports.FoldLine = FoldLine;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/edit_session/folding.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var Range = require("../range").Range;
		var FoldLine = require("./fold_line").FoldLine;
		var Fold = require("./fold").Fold;
		var TokenIterator = require("../token_iterator").TokenIterator;
		
		function Folding() {
		    /*
		     * Looks up a fold at a given row/column. Possible values for side:
		     *   -1: ignore a fold if fold.start = row/column
		     *   +1: ignore a fold if fold.end = row/column
		     */
		    this.getFoldAt = function(row, column, side) {
		        var foldLine = this.getFoldLine(row);
		        if (!foldLine)
		            return null;
		
		        var folds = foldLine.folds;
		        for (var i = 0; i < folds.length; i++) {
		            var fold = folds[i];
		            if (fold.range.contains(row, column)) {
		                if (side == 1 && fold.range.isEnd(row, column)) {
		                    continue;
		                } else if (side == -1 && fold.range.isStart(row, column)) {
		                    continue;
		                }
		                return fold;
		            }
		        }
		    };
		
		    /*
		     * Returns all folds in the given range. Note, that this will return folds
		     *
		     */
		    this.getFoldsInRange = function(range) {
		        var start = range.start;
		        var end = range.end;
		        var foldLines = this.$foldData;
		        var foundFolds = [];
		
		        start.column += 1;
		        end.column -= 1;
		
		        for (var i = 0; i < foldLines.length; i++) {
		            var cmp = foldLines[i].range.compareRange(range);
		            if (cmp == 2) {
		                // Range is before foldLine. No intersection. This means,
		                // there might be other foldLines that intersect.
		                continue;
		            }
		            else if (cmp == -2) {
		                // Range is after foldLine. There can't be any other foldLines then,
		                // so let's give up.
		                break;
		            }
		
		            var folds = foldLines[i].folds;
		            for (var j = 0; j < folds.length; j++) {
		                var fold = folds[j];
		                cmp = fold.range.compareRange(range);
		                if (cmp == -2) {
		                    break;
		                } else if (cmp == 2) {
		                    continue;
		                } else
		                // WTF-state: Can happen due to -1/+1 to start/end column.
		                if (cmp == 42) {
		                    break;
		                }
		                foundFolds.push(fold);
		            }
		        }
		        start.column -= 1;
		        end.column += 1;
		
		        return foundFolds;
		    };
		
		    this.getFoldsInRangeList = function(ranges) {
		        if (Array.isArray(ranges)) {
		            var folds = [];
		            ranges.forEach(function(range) {
		                folds = folds.concat(this.getFoldsInRange(range));
		            }, this);
		        } else {
		            var folds = this.getFoldsInRange(ranges);
		        }
		        return folds;
		    };
		    
		    /*
		     * Returns all folds in the document
		     */
		    this.getAllFolds = function() {
		        var folds = [];
		        var foldLines = this.$foldData;
		        
		        for (var i = 0; i < foldLines.length; i++)
		            for (var j = 0; j < foldLines[i].folds.length; j++)
		                folds.push(foldLines[i].folds[j]);
		
		        return folds;
		    };
		
		    /*
		     * Returns the string between folds at the given position.
		     * E.g.
		     *  foo<fold>b|ar<fold>wolrd -> "bar"
		     *  foo<fold>bar<fold>wol|rd -> "world"
		     *  foo<fold>bar<fo|ld>wolrd -> <null>
		     *
		     * where | means the position of row/column
		     *
		     * The trim option determs if the return string should be trimed according
		     * to the "side" passed with the trim value:
		     *
		     * E.g.
		     *  foo<fold>b|ar<fold>wolrd -trim=-1> "b"
		     *  foo<fold>bar<fold>wol|rd -trim=+1> "rld"
		     *  fo|o<fold>bar<fold>wolrd -trim=00> "foo"
		     */
		    this.getFoldStringAt = function(row, column, trim, foldLine) {
		        foldLine = foldLine || this.getFoldLine(row);
		        if (!foldLine)
		            return null;
		
		        var lastFold = {
		            end: { column: 0 }
		        };
		        // TODO: Refactor to use getNextFoldTo function.
		        var str, fold;
		        for (var i = 0; i < foldLine.folds.length; i++) {
		            fold = foldLine.folds[i];
		            var cmp = fold.range.compareEnd(row, column);
		            if (cmp == -1) {
		                str = this
		                    .getLine(fold.start.row)
		                    .substring(lastFold.end.column, fold.start.column);
		                break;
		            }
		            else if (cmp === 0) {
		                return null;
		            }
		            lastFold = fold;
		        }
		        if (!str)
		            str = this.getLine(fold.start.row).substring(lastFold.end.column);
		
		        if (trim == -1)
		            return str.substring(0, column - lastFold.end.column);
		        else if (trim == 1)
		            return str.substring(column - lastFold.end.column);
		        else
		            return str;
		    };
		
		    this.getFoldLine = function(docRow, startFoldLine) {
		        var foldData = this.$foldData;
		        var i = 0;
		        if (startFoldLine)
		            i = foldData.indexOf(startFoldLine);
		        if (i == -1)
		            i = 0;
		        for (i; i < foldData.length; i++) {
		            var foldLine = foldData[i];
		            if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {
		                return foldLine;
		            } else if (foldLine.end.row > docRow) {
		                return null;
		            }
		        }
		        return null;
		    };
		
		    // returns the fold which starts after or contains docRow
		    this.getNextFoldLine = function(docRow, startFoldLine) {
		        var foldData = this.$foldData;
		        var i = 0;
		        if (startFoldLine)
		            i = foldData.indexOf(startFoldLine);
		        if (i == -1)
		            i = 0;
		        for (i; i < foldData.length; i++) {
		            var foldLine = foldData[i];
		            if (foldLine.end.row >= docRow) {
		                return foldLine;
		            }
		        }
		        return null;
		    };
		
		    this.getFoldedRowCount = function(first, last) {
		        var foldData = this.$foldData, rowCount = last-first+1;
		        for (var i = 0; i < foldData.length; i++) {
		            var foldLine = foldData[i],
		                end = foldLine.end.row,
		                start = foldLine.start.row;
		            if (end >= last) {
		                if (start < last) {
		                    if (start >= first)
		                        rowCount -= last-start;
		                    else
		                        rowCount = 0; // in one fold
		                }
		                break;
		            } else if (end >= first){
		                if (start >= first) // fold inside range
		                    rowCount -=  end-start;
		                else
		                    rowCount -=  end-first+1;
		            }
		        }
		        return rowCount;
		    };
		
		    this.$addFoldLine = function(foldLine) {
		        this.$foldData.push(foldLine);
		        this.$foldData.sort(function(a, b) {
		            return a.start.row - b.start.row;
		        });
		        return foldLine;
		    };
		
		    /**
		     * Adds a new fold.
		     *
		     * @returns
		     *      The new created Fold object or an existing fold object in case the
		     *      passed in range fits an existing fold exactly.
		     */
		    this.addFold = function(placeholder, range) {
		        var foldData = this.$foldData;
		        var added = false;
		        var fold;
		        
		        if (placeholder instanceof Fold)
		            fold = placeholder;
		        else {
		            fold = new Fold(range, placeholder);
		            fold.collapseChildren = range.collapseChildren;
		        }
		        this.$clipRangeToDocument(fold.range);
		
		        var startRow = fold.start.row;
		        var startColumn = fold.start.column;
		        var endRow = fold.end.row;
		        var endColumn = fold.end.column;
		
		        // --- Some checking ---
		        if (!(startRow < endRow || 
		            startRow == endRow && startColumn <= endColumn - 2))
		            throw new Error("The range has to be at least 2 characters width");
		
		        var startFold = this.getFoldAt(startRow, startColumn, 1);
		        var endFold = this.getFoldAt(endRow, endColumn, -1);
		        if (startFold && endFold == startFold)
		            return startFold.addSubFold(fold);
		
		        if (startFold && !startFold.range.isStart(startRow, startColumn))
		            this.removeFold(startFold);
		        
		        if (endFold && !endFold.range.isEnd(endRow, endColumn))
		            this.removeFold(endFold);
		        
		        // Check if there are folds in the range we create the new fold for.
		        var folds = this.getFoldsInRange(fold.range);
		        if (folds.length > 0) {
		            // Remove the folds from fold data.
		            this.removeFolds(folds);
		            // Add the removed folds as subfolds on the new fold.
		            folds.forEach(function(subFold) {
		                fold.addSubFold(subFold);
		            });
		        }
		
		        for (var i = 0; i < foldData.length; i++) {
		            var foldLine = foldData[i];
		            if (endRow == foldLine.start.row) {
		                foldLine.addFold(fold);
		                added = true;
		                break;
		            } else if (startRow == foldLine.end.row) {
		                foldLine.addFold(fold);
		                added = true;
		                if (!fold.sameRow) {
		                    // Check if we might have to merge two FoldLines.
		                    var foldLineNext = foldData[i + 1];
		                    if (foldLineNext && foldLineNext.start.row == endRow) {
		                        // We need to merge!
		                        foldLine.merge(foldLineNext);
		                        break;
		                    }
		                }
		                break;
		            } else if (endRow <= foldLine.start.row) {
		                break;
		            }
		        }
		
		        if (!added)
		            foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));
		
		        if (this.$useWrapMode)
		            this.$updateWrapData(foldLine.start.row, foldLine.start.row);
		        else
		            this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);
		
		        // Notify that fold data has changed.
		        this.$modified = true;
		        this._signal("changeFold", { data: fold, action: "add" });
		
		        return fold;
		    };
		
		    this.addFolds = function(folds) {
		        folds.forEach(function(fold) {
		            this.addFold(fold);
		        }, this);
		    };
		
		    this.removeFold = function(fold) {
		        var foldLine = fold.foldLine;
		        var startRow = foldLine.start.row;
		        var endRow = foldLine.end.row;
		
		        var foldLines = this.$foldData;
		        var folds = foldLine.folds;
		        // Simple case where there is only one fold in the FoldLine such that
		        // the entire fold line can get removed directly.
		        if (folds.length == 1) {
		            foldLines.splice(foldLines.indexOf(foldLine), 1);
		        } else
		        // If the fold is the last fold of the foldLine, just remove it.
		        if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
		            folds.pop();
		            foldLine.end.row = folds[folds.length - 1].end.row;
		            foldLine.end.column = folds[folds.length - 1].end.column;
		        } else
		        // If the fold is the first fold of the foldLine, just remove it.
		        if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
		            folds.shift();
		            foldLine.start.row = folds[0].start.row;
		            foldLine.start.column = folds[0].start.column;
		        } else
		        // We know there are more then 2 folds and the fold is not at the edge.
		        // This means, the fold is somewhere in between.
		        //
		        // If the fold is in one row, we just can remove it.
		        if (fold.sameRow) {
		            folds.splice(folds.indexOf(fold), 1);
		        } else
		        // The fold goes over more then one row. This means remvoing this fold
		        // will cause the fold line to get splitted up. newFoldLine is the second part
		        {
		            var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
		            folds = newFoldLine.folds;
		            folds.shift();
		            newFoldLine.start.row = folds[0].start.row;
		            newFoldLine.start.column = folds[0].start.column;
		        }
		
		        if (!this.$updating) {
		            if (this.$useWrapMode)
		                this.$updateWrapData(startRow, endRow);
		            else
		                this.$updateRowLengthCache(startRow, endRow);
		        }
		        
		        // Notify that fold data has changed.
		        this.$modified = true;
		        this._signal("changeFold", { data: fold, action: "remove" });
		    };
		
		    this.removeFolds = function(folds) {
		        // We need to clone the folds array passed in as it might be the folds
		        // array of a fold line and as we call this.removeFold(fold), folds
		        // are removed from folds and changes the current index.
		        var cloneFolds = [];
		        for (var i = 0; i < folds.length; i++) {
		            cloneFolds.push(folds[i]);
		        }
		
		        cloneFolds.forEach(function(fold) {
		            this.removeFold(fold);
		        }, this);
		        this.$modified = true;
		    };
		
		    this.expandFold = function(fold) {
		        this.removeFold(fold);
		        fold.subFolds.forEach(function(subFold) {
		            fold.restoreRange(subFold);
		            this.addFold(subFold);
		        }, this);
		        if (fold.collapseChildren > 0) {
		            this.foldAll(fold.start.row+1, fold.end.row, fold.collapseChildren-1);
		        }
		        fold.subFolds = [];
		    };
		
		    this.expandFolds = function(folds) {
		        folds.forEach(function(fold) {
		            this.expandFold(fold);
		        }, this);
		    };
		
		    this.unfold = function(location, expandInner) {
		        var range, folds;
		        if (location == null) {
		            range = new Range(0, 0, this.getLength(), 0);
		            expandInner = true;
		        } else if (typeof location == "number")
		            range = new Range(location, 0, location, this.getLine(location).length);
		        else if ("row" in location)
		            range = Range.fromPoints(location, location);
		        else
		            range = location;
		        
		        folds = this.getFoldsInRangeList(range);
		        if (expandInner) {
		            this.removeFolds(folds);
		        } else {
		            var subFolds = folds;
		            // TODO: might be better to remove and add folds in one go instead of using
		            // expandFolds several times.
		            while (subFolds.length) {
		                this.expandFolds(subFolds);
		                subFolds = this.getFoldsInRangeList(range);
		            }
		        }
		        if (folds.length)
		            return folds;
		    };
		
		    /*
		     * Checks if a given documentRow is folded. This is true if there are some
		     * folded parts such that some parts of the line is still visible.
		     **/
		    this.isRowFolded = function(docRow, startFoldRow) {
		        return !!this.getFoldLine(docRow, startFoldRow);
		    };
		
		    this.getRowFoldEnd = function(docRow, startFoldRow) {
		        var foldLine = this.getFoldLine(docRow, startFoldRow);
		        return foldLine ? foldLine.end.row : docRow;
		    };
		
		    this.getRowFoldStart = function(docRow, startFoldRow) {
		        var foldLine = this.getFoldLine(docRow, startFoldRow);
		        return foldLine ? foldLine.start.row : docRow;
		    };
		
		    this.getFoldDisplayLine = function(foldLine, endRow, endColumn, startRow, startColumn) {
		        if (startRow == null)
		            startRow = foldLine.start.row;
		        if (startColumn == null)
		            startColumn = 0;
		        if (endRow == null)
		            endRow = foldLine.end.row;
		        if (endColumn == null)
		            endColumn = this.getLine(endRow).length;
		        
		
		        // Build the textline using the FoldLine walker.
		        var doc = this.doc;
		        var textLine = "";
		
		        foldLine.walk(function(placeholder, row, column, lastColumn) {
		            if (row < startRow)
		                return;
		            if (row == startRow) {
		                if (column < startColumn)
		                    return;
		                lastColumn = Math.max(startColumn, lastColumn);
		            }
		
		            if (placeholder != null) {
		                textLine += placeholder;
		            } else {
		                textLine += doc.getLine(row).substring(lastColumn, column);
		            }
		        }, endRow, endColumn);
		        return textLine;
		    };
		
		    this.getDisplayLine = function(row, endColumn, startRow, startColumn) {
		        var foldLine = this.getFoldLine(row);
		
		        if (!foldLine) {
		            var line;
		            line = this.doc.getLine(row);
		            return line.substring(startColumn || 0, endColumn || line.length);
		        } else {
		            return this.getFoldDisplayLine(
		                foldLine, row, endColumn, startRow, startColumn);
		        }
		    };
		
		    this.$cloneFoldData = function() {
		        var fd = [];
		        fd = this.$foldData.map(function(foldLine) {
		            var folds = foldLine.folds.map(function(fold) {
		                return fold.clone();
		            });
		            return new FoldLine(fd, folds);
		        });
		
		        return fd;
		    };
		
		    this.toggleFold = function(tryToUnfold) {
		        var selection = this.selection;
		        var range = selection.getRange();
		        var fold;
		        var bracketPos;
		
		        if (range.isEmpty()) {
		            var cursor = range.start;
		            fold = this.getFoldAt(cursor.row, cursor.column);
		
		            if (fold) {
		                this.expandFold(fold);
		                return;
		            } else if (bracketPos = this.findMatchingBracket(cursor)) {
		                if (range.comparePoint(bracketPos) == 1) {
		                    range.end = bracketPos;
		                } else {
		                    range.start = bracketPos;
		                    range.start.column++;
		                    range.end.column--;
		                }
		            } else if (bracketPos = this.findMatchingBracket({row: cursor.row, column: cursor.column + 1})) {
		                if (range.comparePoint(bracketPos) == 1)
		                    range.end = bracketPos;
		                else
		                    range.start = bracketPos;
		
		                range.start.column++;
		            } else {
		                range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
		            }
		        } else {
		            var folds = this.getFoldsInRange(range);
		            if (tryToUnfold && folds.length) {
		                this.expandFolds(folds);
		                return;
		            } else if (folds.length == 1 ) {
		                fold = folds[0];
		            }
		        }
		
		        if (!fold)
		            fold = this.getFoldAt(range.start.row, range.start.column);
		
		        if (fold && fold.range.toString() == range.toString()) {
		            this.expandFold(fold);
		            return;
		        }
		
		        var placeholder = "...";
		        if (!range.isMultiLine()) {
		            placeholder = this.getTextRange(range);
		            if (placeholder.length < 4)
		                return;
		            placeholder = placeholder.trim().substring(0, 2) + "..";
		        }
		
		        this.addFold(placeholder, range);
		    };
		
		    this.getCommentFoldRange = function(row, column, dir) {
		        var iterator = new TokenIterator(this, row, column);
		        var token = iterator.getCurrentToken();
		        if (token && /^comment|string/.test(token.type)) {
		            var range = new Range();
		            var re = new RegExp(token.type.replace(/\..*/, "\\."));
		            if (dir != 1) {
		                do {
		                    token = iterator.stepBackward();
		                } while (token && re.test(token.type));
		                iterator.stepForward();
		            }
		            
		            range.start.row = iterator.getCurrentTokenRow();
		            range.start.column = iterator.getCurrentTokenColumn() + 2;
		
		            iterator = new TokenIterator(this, row, column);
		            
		            if (dir != -1) {
		                do {
		                    token = iterator.stepForward();
		                } while (token && re.test(token.type));
		                token = iterator.stepBackward();
		            } else
		                token = iterator.getCurrentToken();
		
		            range.end.row = iterator.getCurrentTokenRow();
		            range.end.column = iterator.getCurrentTokenColumn() + token.value.length - 2;
		            return range;
		        }
		    };
		
		    this.foldAll = function(startRow, endRow, depth) {
		        if (depth == undefined)
		            depth = 100000; // JSON.stringify doesn't hanle Infinity
		        var foldWidgets = this.foldWidgets;
		        if (!foldWidgets)
		            return; // mode doesn't support folding
		        endRow = endRow || this.getLength();
		        startRow = startRow || 0;
		        for (var row = startRow; row < endRow; row++) {
		            if (foldWidgets[row] == null)
		                foldWidgets[row] = this.getFoldWidget(row);
		            if (foldWidgets[row] != "start")
		                continue;
		
		            var range = this.getFoldWidgetRange(row);
		            // sometimes range can be incompatible with existing fold
		            // TODO change addFold to return null istead of throwing
		            if (range && range.isMultiLine()
		                && range.end.row <= endRow
		                && range.start.row >= startRow
		            ) {
		                row = range.end.row;
		                try {
		                    // addFold can change the range
		                    var fold = this.addFold("...", range);
		                    if (fold)
		                        fold.collapseChildren = depth;
		                } catch(e) {}
		            }
		        }
		    };
		    
		    // structured folding
		    this.$foldStyles = {
		        "manual": 1,
		        "markbegin": 1,
		        "markbeginend": 1
		    };
		    this.$foldStyle = "markbegin";
		    this.setFoldStyle = function(style) {
		        if (!this.$foldStyles[style])
		            throw new Error("invalid fold style: " + style + "[" + Object.keys(this.$foldStyles).join(", ") + "]");
		        
		        if (this.$foldStyle == style)
		            return;
		
		        this.$foldStyle = style;
		        
		        if (style == "manual")
		            this.unfold();
		        
		        // reset folding
		        var mode = this.$foldMode;
		        this.$setFolding(null);
		        this.$setFolding(mode);
		    };
		
		    this.$setFolding = function(foldMode) {
		        if (this.$foldMode == foldMode)
		            return;
		            
		        this.$foldMode = foldMode;
		        
		        this.off('change', this.$updateFoldWidgets);
		        this.off('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
		        this._signal("changeAnnotation");
		        
		        if (!foldMode || this.$foldStyle == "manual") {
		            this.foldWidgets = null;
		            return;
		        }
		        
		        this.foldWidgets = [];
		        this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
		        this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);
		        
		        this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
		        this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);
		        this.on('change', this.$updateFoldWidgets);
		        this.on('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
		    };
		
		    this.getParentFoldRangeData = function (row, ignoreCurrent) {
		        var fw = this.foldWidgets;
		        if (!fw || (ignoreCurrent && fw[row]))
		            return {};
		
		        var i = row - 1, firstRange;
		        while (i >= 0) {
		            var c = fw[i];
		            if (c == null)
		                c = fw[i] = this.getFoldWidget(i);
		
		            if (c == "start") {
		                var range = this.getFoldWidgetRange(i);
		                if (!firstRange)
		                    firstRange = range;
		                if (range && range.end.row >= row)
		                    break;
		            }
		            i--;
		        }
		
		        return {
		            range: i !== -1 && range,
		            firstRange: firstRange
		        };
		    };
		
		    this.onFoldWidgetClick = function(row, e) {
		        e = e.domEvent;
		        var options = {
		            children: e.shiftKey,
		            all: e.ctrlKey || e.metaKey,
		            siblings: e.altKey
		        };
		        
		        var range = this.$toggleFoldWidget(row, options);
		        if (!range) {
		            var el = (e.target || e.srcElement);
		            if (el && /ace_fold-widget/.test(el.className))
		                el.className += " ace_invalid";
		        }
		    };
		    
		    this.$toggleFoldWidget = function(row, options) {
		        if (!this.getFoldWidget)
		            return;
		        var type = this.getFoldWidget(row);
		        var line = this.getLine(row);
		
		        var dir = type === "end" ? -1 : 1;
		        var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);
		
		        if (fold) {
		            if (options.children || options.all)
		                this.removeFold(fold);
		            else
		                this.expandFold(fold);
		            return;
		        }
		
		        var range = this.getFoldWidgetRange(row, true);
		        // sometimes singleline folds can be missed by the code above
		        if (range && !range.isMultiLine()) {
		            fold = this.getFoldAt(range.start.row, range.start.column, 1);
		            if (fold && range.isEqual(fold.range)) {
		                this.removeFold(fold);
		                return;
		            }
		        }
		        
		        if (options.siblings) {
		            var data = this.getParentFoldRangeData(row);
		            if (data.range) {
		                var startRow = data.range.start.row + 1;
		                var endRow = data.range.end.row;
		            }
		            this.foldAll(startRow, endRow, options.all ? 10000 : 0);
		        } else if (options.children) {
		            endRow = range ? range.end.row : this.getLength();
		            this.foldAll(row + 1, endRow, options.all ? 10000 : 0);
		        } else if (range) {
		            if (options.all) 
		                range.collapseChildren = 10000;
		            this.addFold("...", range);
		        }
		        
		        return range;
		    };
		    
		    
		    
		    this.toggleFoldWidget = function(toggleParent) {
		        var row = this.selection.getCursor().row;
		        row = this.getRowFoldStart(row);
		        var range = this.$toggleFoldWidget(row, {});
		        
		        if (range)
		            return;
		        // handle toggleParent
		        var data = this.getParentFoldRangeData(row, true);
		        range = data.range || data.firstRange;
		        
		        if (range) {
		            row = range.start.row;
		            var fold = this.getFoldAt(row, this.getLine(row).length, 1);
		
		            if (fold) {
		                this.removeFold(fold);
		            } else {
		                this.addFold("...", range);
		            }
		        }
		    };
		
		    this.updateFoldWidgets = function(delta) {
		        var firstRow = delta.start.row;
		        var len = delta.end.row - firstRow;
		
		        if (len === 0) {
		            this.foldWidgets[firstRow] = null;
		        } else if (delta.action == 'remove') {
		            this.foldWidgets.splice(firstRow, len + 1, null);
		        } else {
		            var args = Array(len + 1);
		            args.unshift(firstRow, 1);
		            this.foldWidgets.splice.apply(this.foldWidgets, args);
		        }
		    };
		    this.tokenizerUpdateFoldWidgets = function(e) {
		        var rows = e.data;
		        if (rows.first != rows.last) {
		            if (this.foldWidgets.length > rows.first)
		                this.foldWidgets.splice(rows.first, this.foldWidgets.length);
		        }
		    };
		}
		
		exports.Folding = Folding;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/edit_session.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var oop = require("./lib/oop");
		var lang = require("./lib/lang");
		var BidiHandler = require("./bidihandler").BidiHandler;
		var config = require("./config");
		var EventEmitter = require("./lib/event_emitter").EventEmitter;
		var Selection = require("./selection").Selection;
		var TextMode = require("./mode/text").Mode;
		var Range = require("./range").Range;
		var Document = require("./document").Document;
		var BackgroundTokenizer = require("./background_tokenizer").BackgroundTokenizer;
		var SearchHighlight = require("./search_highlight").SearchHighlight;
		
		/**
		 * Stores all the data about [[Editor `Editor`]] state providing easy way to change editors state.
		 *
		 * `EditSession` can be attached to only one [[Document `Document`]]. Same `Document` can be attached to several `EditSession`s.
		 * @class EditSession
		 **/
		
		//{ events
		/**
		 *
		 * Emitted when the document changes.
		 * @event change
		 * @param {Object} e An object containing a `delta` of information about the change.
		 **/
		/**
		 * Emitted when the tab size changes, via [[EditSession.setTabSize]].
		 *
		 * @event changeTabSize
		 **/
		/**
		 * Emitted when the ability to overwrite text changes, via [[EditSession.setOverwrite]].
		 *
		 * @event changeOverwrite
		 **/
		/**
		 * Emitted when the gutter changes, either by setting or removing breakpoints, or when the gutter decorations change.
		 *
		 * @event changeBreakpoint
		 **/
		/**
		 * Emitted when a front marker changes.
		 *
		 * @event changeFrontMarker
		 **/
		/**
		 * Emitted when a back marker changes.
		 *
		 * @event changeBackMarker
		 **/
		/**
		 * Emitted when an annotation changes, like through [[EditSession.setAnnotations]].
		 *
		 * @event changeAnnotation
		 **/
		/**
		 * Emitted when a background tokenizer asynchronously processes new rows.
		 * @event tokenizerUpdate
		 *
		 * @param {Object} e An object containing one property, `"data"`, that contains information about the changing rows
		 *
		 **/
		/**
		 * Emitted when the current mode changes.
		 *
		 * @event changeMode
		 *
		 **/
		/**
		 * Emitted when the wrap mode changes.
		 *
		 * @event changeWrapMode
		 *
		 **/
		/**
		 * Emitted when the wrapping limit changes.
		 *
		 * @event changeWrapLimit
		 *
		 **/
		/**
		 * Emitted when a code fold is added or removed.
		 *
		 * @event changeFold
		 *
		 **/
		 /**
		 * Emitted when the scroll top changes.
		 * @event changeScrollTop
		 *
		 * @param {Number} scrollTop The new scroll top value
		 **/
		/**
		 * Emitted when the scroll left changes.
		 * @event changeScrollLeft
		 *
		 * @param {Number} scrollLeft The new scroll left value
		 **/
		//}
		
		/**
		 * Sets up a new `EditSession` and associates it with the given `Document` and `TextMode`.
		 * @param {Document | String} text [If `text` is a `Document`, it associates the `EditSession` with it. Otherwise, a new `Document` is created, with the initial text]{: #textParam}
		 * @param {TextMode} mode [The initial language mode to use for the document]{: #modeParam}
		 *
		 * @constructor
		 **/
		
		var EditSession = function(text, mode) {
		    this.$breakpoints = [];
		    this.$decorations = [];
		    this.$frontMarkers = {};
		    this.$backMarkers = {};
		    this.$markerId = 1;
		    this.$undoSelect = true;
		
		    this.$foldData = [];
		    this.id = "session" + (++EditSession.$uid);
		    this.$foldData.toString = function() {
		        return this.join("\n");
		    };
		    this.on("changeFold", this.onChangeFold.bind(this));
		    this.$onChange = this.onChange.bind(this);
		
		    if (typeof text != "object" || !text.getLine)
		        text = new Document(text);
		
		    this.$bidiHandler = new BidiHandler(this);
		    this.setDocument(text);
		    this.selection = new Selection(this);
		
		    config.resetOptions(this);
		    this.setMode(mode);
		    config._signal("session", this);
		};
		
		
		EditSession.$uid = 0;
		
		(function() {
		
		    oop.implement(this, EventEmitter);
		
		    /**
		     * Sets the `EditSession` to point to a new `Document`. If a `BackgroundTokenizer` exists, it also points to `doc`.
		     *
		     * @param {Document} doc The new `Document` to use
		     *
		     **/
		    this.setDocument = function(doc) {
		        if (this.doc)
		            this.doc.removeListener("change", this.$onChange);
		
		        this.doc = doc;
		        doc.on("change", this.$onChange);
		
		        if (this.bgTokenizer)
		            this.bgTokenizer.setDocument(this.getDocument());
		
		        this.resetCaches();
		    };
		
		    /**
		     * Returns the `Document` associated with this session.
		     * @return {Document}
		     **/
		    this.getDocument = function() {
		        return this.doc;
		    };
		
		    /**
		     * @param {Number} row The row to work with
		     *
		     **/
		    this.$resetRowCache = function(docRow) {
		        if (!docRow) {
		            this.$docRowCache = [];
		            this.$screenRowCache = [];
		            return;
		        }
		        var l = this.$docRowCache.length;
		        var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
		        if (l > i) {
		            this.$docRowCache.splice(i, l);
		            this.$screenRowCache.splice(i, l);
		        }
		    };
		
		    this.$getRowCacheIndex = function(cacheArray, val) {
		        var low = 0;
		        var hi = cacheArray.length - 1;
		
		        while (low <= hi) {
		            var mid = (low + hi) >> 1;
		            var c = cacheArray[mid];
		
		            if (val > c)
		                low = mid + 1;
		            else if (val < c)
		                hi = mid - 1;
		            else
		                return mid;
		        }
		
		        return low -1;
		    };
		
		    this.resetCaches = function() {
		        this.$modified = true;
		        this.$wrapData = [];
		        this.$rowLengthCache = [];
		        this.$resetRowCache(0);
		        if (this.bgTokenizer)
		            this.bgTokenizer.start(0);
		    };
		
		    this.onChangeFold = function(e) {
		        var fold = e.data;
		        this.$resetRowCache(fold.start.row);
		    };
		
		    this.onChange = function(delta) {
		        this.$modified = true;
		        this.$bidiHandler.onChange(delta);
		        this.$resetRowCache(delta.start.row);
		
		        var removedFolds = this.$updateInternalDataOnChange(delta);
		        if (!this.$fromUndo && this.$undoManager) {
		            if (removedFolds && removedFolds.length) {
		                this.$undoManager.add({
		                    action: "removeFolds",
		                    folds:  removedFolds
		                }, this.mergeUndoDeltas);
		                this.mergeUndoDeltas = true;
		            }
		            this.$undoManager.add(delta, this.mergeUndoDeltas);
		            this.mergeUndoDeltas = true;
		            
		            this.$informUndoManager.schedule();
		        }
		
		        this.bgTokenizer && this.bgTokenizer.$updateOnChange(delta);
		        this._signal("change", delta);
		    };
		
		    /**
		     * Sets the session text.
		     * @param {String} text The new text to place
		     *
		     **/
		    this.setValue = function(text) {
		        this.doc.setValue(text);
		        this.selection.moveTo(0, 0);
		
		        this.$resetRowCache(0);
		        this.setUndoManager(this.$undoManager);
		        this.getUndoManager().reset();
		    };
		
		    /**
		     * Returns the current [[Document `Document`]] as a string.
		     * @method toString
		     * @returns {String}
		     * @alias EditSession.getValue
		     *
		     **/
		
		    /**
		     * Returns the current [[Document `Document`]] as a string.
		     * @method getValue
		     * @returns {String}
		     * @alias EditSession.toString
		     **/
		    this.getValue =
		    this.toString = function() {
		        return this.doc.getValue();
		    };
		
		    /**
		     * Returns selection object.
		     **/
		    this.getSelection = function() {
		        return this.selection;
		    };
		
		    /**
		     * {:BackgroundTokenizer.getState}
		     * @param {Number} row The row to start at
		     *
		     * @related BackgroundTokenizer.getState
		     **/
		    this.getState = function(row) {
		        return this.bgTokenizer.getState(row);
		    };
		
		    /**
		     * Starts tokenizing at the row indicated. Returns a list of objects of the tokenized rows.
		     * @param {Number} row The row to start at
		     *
		     *
		     *
		     **/
		    this.getTokens = function(row) {
		        return this.bgTokenizer.getTokens(row);
		    };
		
		    /**
		     * Returns an object indicating the token at the current row. The object has two properties: `index` and `start`.
		     * @param {Number} row The row number to retrieve from
		     * @param {Number} column The column number to retrieve from
		     *
		     *
		     **/
		    this.getTokenAt = function(row, column) {
		        var tokens = this.bgTokenizer.getTokens(row);
		        var token, c = 0;
		        if (column == null) {
		            var i = tokens.length - 1;
		            c = this.getLine(row).length;
		        } else {
		            for (var i = 0; i < tokens.length; i++) {
		                c += tokens[i].value.length;
		                if (c >= column)
		                    break;
		            }
		        }
		        token = tokens[i];
		        if (!token)
		            return null;
		        token.index = i;
		        token.start = c - token.value.length;
		        return token;
		    };
		
		    /**
		     * Sets the undo manager.
		     * @param {UndoManager} undoManager The new undo manager
		     *
		     *
		     **/
		    this.setUndoManager = function(undoManager) {
		        this.$undoManager = undoManager;
		        
		        if (this.$informUndoManager)
		            this.$informUndoManager.cancel();
		        
		        if (undoManager) {
		            var self = this;
		            undoManager.addSession(this);
		            this.$syncInformUndoManager = function() {
		                self.$informUndoManager.cancel();
		                self.mergeUndoDeltas = false;
		            };
		            this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);
		        } else {
		            this.$syncInformUndoManager = function() {};
		        }
		    };
		
		    /**
		     * starts a new group in undo history
		     **/
		    this.markUndoGroup = function() {
		        if (this.$syncInformUndoManager)
		            this.$syncInformUndoManager();
		    };
		    
		    this.$defaultUndoManager = {
		        undo: function() {},
		        redo: function() {},
		        reset: function() {},
		        add: function() {},
		        addSelection: function() {},
		        startNewGroup: function() {},
		        addSession: function() {}
		    };
		
		    /**
		     * Returns the current undo manager.
		     **/
		    this.getUndoManager = function() {
		        return this.$undoManager || this.$defaultUndoManager;
		    };
		
		    /**
		     * Returns the current value for tabs. If the user is using soft tabs, this will be a series of spaces (defined by [[EditSession.getTabSize `getTabSize()`]]); otherwise it's simply `'\t'`.
		     **/
		    this.getTabString = function() {
		        if (this.getUseSoftTabs()) {
		            return lang.stringRepeat(" ", this.getTabSize());
		        } else {
		            return "\t";
		        }
		    };
		
		    /**
		     * Pass `true` to enable the use of soft tabs. Soft tabs means you're using spaces instead of the tab character (`'\t'`).
		     * @param {Boolean} useSoftTabs Value indicating whether or not to use soft tabs
		     **/
		    this.setUseSoftTabs = function(val) {
		        this.setOption("useSoftTabs", val);
		    };
		    /**
		     * Returns `true` if soft tabs are being used, `false` otherwise.
		     * @returns {Boolean}
		     **/
		    this.getUseSoftTabs = function() {
		        // todo might need more general way for changing settings from mode, but this is ok for now
		        return this.$useSoftTabs && !this.$mode.$indentWithTabs;
		    };
		    /**
		     * Set the number of spaces that define a soft tab; for example, passing in `4` transforms the soft tabs to be equivalent to four spaces. This function also emits the `changeTabSize` event.
		     * @param {Number} tabSize The new tab size
		     **/
		    this.setTabSize = function(tabSize) {
		        this.setOption("tabSize", tabSize);
		    };
		    /**
		     * Returns the current tab size.
		     **/
		    this.getTabSize = function() {
		        return this.$tabSize;
		    };
		
		    /**
		     * Returns `true` if the character at the position is a soft tab.
		     * @param {Object} position The position to check
		     *
		     **/
		    this.isTabStop = function(position) {
		        return this.$useSoftTabs && (position.column % this.$tabSize === 0);
		    };
		
		    /**
		     * Set whether keyboard navigation of soft tabs moves the cursor within the soft tab, rather than over
		     * @param {Boolean} navigateWithinSoftTabs Value indicating whether or not to navigate within soft tabs
		     **/
		    this.setNavigateWithinSoftTabs = function (navigateWithinSoftTabs) {
		        this.setOption("navigateWithinSoftTabs", navigateWithinSoftTabs);
		    };
		    /**
		     * Returns `true` if keyboard navigation moves the cursor within soft tabs, `false` if it moves the cursor over soft tabs.
		     * @returns {Boolean}
		     **/
		    this.getNavigateWithinSoftTabs = function() {
		        return this.$navigateWithinSoftTabs;
		    };
		
		    this.$overwrite = false;
		    /**
		     * Pass in `true` to enable overwrites in your session, or `false` to disable.
		     *
		     * If overwrites is enabled, any text you enter will type over any text after it. If the value of `overwrite` changes, this function also emits the `changeOverwrite` event.
		     *
		     * @param {Boolean} overwrite Defines whether or not to set overwrites
		     *
		     *
		     **/
		    this.setOverwrite = function(overwrite) {
		        this.setOption("overwrite", overwrite);
		    };
		
		    /**
		     * Returns `true` if overwrites are enabled; `false` otherwise.
		     **/
		    this.getOverwrite = function() {
		        return this.$overwrite;
		    };
		
		    /**
		     * Sets the value of overwrite to the opposite of whatever it currently is.
		     **/
		    this.toggleOverwrite = function() {
		        this.setOverwrite(!this.$overwrite);
		    };
		
		    /**
		     * Adds `className` to the `row`, to be used for CSS stylings and whatnot.
		     * @param {Number} row The row number
		     * @param {String} className The class to add
		     *
		     **/
		    this.addGutterDecoration = function(row, className) {
		        if (!this.$decorations[row])
		            this.$decorations[row] = "";
		        this.$decorations[row] += " " + className;
		        this._signal("changeBreakpoint", {});
		    };
		
		    /**
		     * Removes `className` from the `row`.
		     * @param {Number} row The row number
		     * @param {String} className The class to add
		     *
		     **/
		    this.removeGutterDecoration = function(row, className) {
		        this.$decorations[row] = (this.$decorations[row] || "").replace(" " + className, "");
		        this._signal("changeBreakpoint", {});
		    };
		
		    /**
		     * Returns an array of strings, indicating the breakpoint class (if any) applied to each row.
		     * @returns {[String]}
		     **/
		    this.getBreakpoints = function() {
		        return this.$breakpoints;
		    };
		
		    /**
		     * Sets a breakpoint on every row number given by `rows`. This function also emites the `'changeBreakpoint'` event.
		     * @param {Array} rows An array of row indices
		     *
		     **/
		    this.setBreakpoints = function(rows) {
		        this.$breakpoints = [];
		        for (var i=0; i<rows.length; i++) {
		            this.$breakpoints[rows[i]] = "ace_breakpoint";
		        }
		        this._signal("changeBreakpoint", {});
		    };
		
		    /**
		     * Removes all breakpoints on the rows. This function also emits the `'changeBreakpoint'` event.
		     **/
		    this.clearBreakpoints = function() {
		        this.$breakpoints = [];
		        this._signal("changeBreakpoint", {});
		    };
		
		    /**
		     * Sets a breakpoint on the row number given by `row`. This function also emits the `'changeBreakpoint'` event.
		     * @param {Number} row A row index
		     * @param {String} className Class of the breakpoint
		     *
		     **/
		    this.setBreakpoint = function(row, className) {
		        if (className === undefined)
		            className = "ace_breakpoint";
		        if (className)
		            this.$breakpoints[row] = className;
		        else
		            delete this.$breakpoints[row];
		        this._signal("changeBreakpoint", {});
		    };
		
		    /**
		     * Removes a breakpoint on the row number given by `row`. This function also emits the `'changeBreakpoint'` event.
		     * @param {Number} row A row index
		     *
		     **/
		    this.clearBreakpoint = function(row) {
		        delete this.$breakpoints[row];
		        this._signal("changeBreakpoint", {});
		    };
		
		    /**
		     * Adds a new marker to the given `Range`. If `inFront` is `true`, a front marker is defined, and the `'changeFrontMarker'` event fires; otherwise, the `'changeBackMarker'` event fires.
		     * @param {Range} range Define the range of the marker
		     * @param {String} clazz Set the CSS class for the marker
		     * @param {Function | String} type Identify the type of the marker
		     * @param {Boolean} inFront Set to `true` to establish a front marker
		     *
		     * @return {Number} The new marker id
		     **/
		    this.addMarker = function(range, clazz, type, inFront) {
		        var id = this.$markerId++;
		
		        var marker = {
		            range : range,
		            type : type || "line",
		            renderer: typeof type == "function" ? type : null,
		            clazz : clazz,
		            inFront: !!inFront,
		            id: id
		        };
		
		        if (inFront) {
		            this.$frontMarkers[id] = marker;
		            this._signal("changeFrontMarker");
		        } else {
		            this.$backMarkers[id] = marker;
		            this._signal("changeBackMarker");
		        }
		
		        return id;
		    };
		
		    /**
		     * Adds a dynamic marker to the session.
		     * @param {Object} marker object with update method
		     * @param {Boolean} inFront Set to `true` to establish a front marker
		     *
		     * @return {Object} The added marker
		     **/
		    this.addDynamicMarker = function(marker, inFront) {
		        if (!marker.update)
		            return;
		        var id = this.$markerId++;
		        marker.id = id;
		        marker.inFront = !!inFront;
		
		        if (inFront) {
		            this.$frontMarkers[id] = marker;
		            this._signal("changeFrontMarker");
		        } else {
		            this.$backMarkers[id] = marker;
		            this._signal("changeBackMarker");
		        }
		
		        return marker;
		    };
		
		    /**
		     * Removes the marker with the specified ID. If this marker was in front, the `'changeFrontMarker'` event is emitted. If the marker was in the back, the `'changeBackMarker'` event is emitted.
		     * @param {Number} markerId A number representing a marker
		     *
		     **/
		    this.removeMarker = function(markerId) {
		        var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
		        if (!marker)
		            return;
		
		        var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
		        delete (markers[markerId]);
		        this._signal(marker.inFront ? "changeFrontMarker" : "changeBackMarker");
		    };
		
		    /**
		     * Returns an object containing all of the markers, either front or back.
		     * @param {Boolean} inFront If `true`, indicates you only want front markers; `false` indicates only back markers
		     *
		     * @returns {Object}
		     **/
		    this.getMarkers = function(inFront) {
		        return inFront ? this.$frontMarkers : this.$backMarkers;
		    };
		
		    this.highlight = function(re) {
		        if (!this.$searchHighlight) {
		            var highlight = new SearchHighlight(null, "ace_selected-word", "text");
		            this.$searchHighlight = this.addDynamicMarker(highlight);
		        }
		        this.$searchHighlight.setRegexp(re);
		    };
		
		    // experimental
		    this.highlightLines = function(startRow, endRow, clazz, inFront) {
		        if (typeof endRow != "number") {
		            clazz = endRow;
		            endRow = startRow;
		        }
		        if (!clazz)
		            clazz = "ace_step";
		
		        var range = new Range(startRow, 0, endRow, Infinity);
		        range.id = this.addMarker(range, clazz, "fullLine", inFront);
		        return range;
		    };
		
		    /*
		     * Error:
		     *  {
		     *    row: 12,
		     *    column: 2, //can be undefined
		     *    text: "Missing argument",
		     *    type: "error" // or "warning" or "info"
		     *  }
		     */
		    /**
		     * Sets annotations for the `EditSession`. This functions emits the `'changeAnnotation'` event.
		     * @param {Array} annotations A list of annotations
		     *
		     **/
		    this.setAnnotations = function(annotations) {
		        this.$annotations = annotations;
		        this._signal("changeAnnotation", {});
		    };
		
		    /**
		     * Returns the annotations for the `EditSession`.
		     * @returns {Array}
		     **/
		    this.getAnnotations = function() {
		        return this.$annotations || [];
		    };
		
		    /**
		     * Clears all the annotations for this session. This function also triggers the `'changeAnnotation'` event.
		     **/
		    this.clearAnnotations = function() {
		        this.setAnnotations([]);
		    };
		
		    /**
		     * If `text` contains either the newline (`\n`) or carriage-return ('\r') characters, `$autoNewLine` stores that value.
		     * @param {String} text A block of text
		     *
		     **/
		    this.$detectNewLine = function(text) {
		        var match = text.match(/^.*?(\r?\n)/m);
		        if (match) {
		            this.$autoNewLine = match[1];
		        } else {
		            this.$autoNewLine = "\n";
		        }
		    };
		
		    /**
		     * Given a starting row and column, this method returns the `Range` of the first word boundary it finds.
		     * @param {Number} row The row to start at
		     * @param {Number} column The column to start at
		     *
		     * @returns {Range}
		     **/
		    this.getWordRange = function(row, column) {
		        var line = this.getLine(row);
		
		        var inToken = false;
		        if (column > 0)
		            inToken = !!line.charAt(column - 1).match(this.tokenRe);
		
		        if (!inToken)
		            inToken = !!line.charAt(column).match(this.tokenRe);
		
		        if (inToken)
		            var re = this.tokenRe;
		        else if (/^\s+$/.test(line.slice(column-1, column+1)))
		            var re = /\s/;
		        else
		            var re = this.nonTokenRe;
		
		        var start = column;
		        if (start > 0) {
		            do {
		                start--;
		            }
		            while (start >= 0 && line.charAt(start).match(re));
		            start++;
		        }
		
		        var end = column;
		        while (end < line.length && line.charAt(end).match(re)) {
		            end++;
		        }
		
		        return new Range(row, start, row, end);
		    };
		
		    /**
		     * Gets the range of a word, including its right whitespace.
		     * @param {Number} row The row number to start from
		     * @param {Number} column The column number to start from
		     *
		     * @return {Range}
		     **/
		    this.getAWordRange = function(row, column) {
		        var wordRange = this.getWordRange(row, column);
		        var line = this.getLine(wordRange.end.row);
		
		        while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
		            wordRange.end.column += 1;
		        }
		        return wordRange;
		    };
		
		    /**
		     * {:Document.setNewLineMode.desc}
		     * @param {String} newLineMode {:Document.setNewLineMode.param}
		     *
		     *
		     * @related Document.setNewLineMode
		     **/
		    this.setNewLineMode = function(newLineMode) {
		        this.doc.setNewLineMode(newLineMode);
		    };
		
		    /**
		     *
		     * Returns the current new line mode.
		     * @returns {String}
		     * @related Document.getNewLineMode
		     **/
		    this.getNewLineMode = function() {
		        return this.doc.getNewLineMode();
		    };
		
		    /**
		     * Identifies if you want to use a worker for the `EditSession`.
		     * @param {Boolean} useWorker Set to `true` to use a worker
		     *
		     **/
		    this.setUseWorker = function(useWorker) { this.setOption("useWorker", useWorker); };
		
		    /**
		     * Returns `true` if workers are being used.
		     **/
		    this.getUseWorker = function() { return this.$useWorker; };
		
		    /**
		     * Reloads all the tokens on the current session. This function calls [[BackgroundTokenizer.start `BackgroundTokenizer.start ()`]] to all the rows; it also emits the `'tokenizerUpdate'` event.
		     **/
		    this.onReloadTokenizer = function(e) {
		        var rows = e.data;
		        this.bgTokenizer.start(rows.first);
		        this._signal("tokenizerUpdate", e);
		    };
		
		    this.$modes = {};
		
		    /**
		     * Sets a new text mode for the `EditSession`. This method also emits the `'changeMode'` event. If a [[BackgroundTokenizer `BackgroundTokenizer`]] is set, the `'tokenizerUpdate'` event is also emitted.
		     * @param {TextMode} mode Set a new text mode
		     * @param {cb} optional callback
		     *
		     **/
		    this.$mode = null;
		    this.$modeId = null;
		    this.setMode = function(mode, cb) {
		        if (mode && typeof mode === "object") {
		            if (mode.getTokenizer)
		                return this.$onChangeMode(mode);
		            var options = mode;
		            var path = options.path;
		        } else {
		            path = mode || "ace/mode/text";
		        }
		
		        // this is needed if ace isn't on require path (e.g tests in node)
		        if (!this.$modes["ace/mode/text"])
		            this.$modes["ace/mode/text"] = new TextMode();
		
		        if (this.$modes[path] && !options) {
		            this.$onChangeMode(this.$modes[path]);
		            cb && cb();
		            return;
		        }
		        // load on demand
		        this.$modeId = path;
		        config.loadModule(["mode", path], function(m) {
		            if (this.$modeId !== path)
		                return cb && cb();
		            if (this.$modes[path] && !options) {
		                this.$onChangeMode(this.$modes[path]);
		            } else if (m && m.Mode) {
		                m = new m.Mode(options);
		                if (!options) {
		                    this.$modes[path] = m;
		                    m.$id = path;
		                }
		                this.$onChangeMode(m);
		            }
		            cb && cb();
		        }.bind(this));
		
		        // set mode to text until loading is finished
		        if (!this.$mode)
		            this.$onChangeMode(this.$modes["ace/mode/text"], true);
		    };
		
		    this.$onChangeMode = function(mode, $isPlaceholder) {
		        if (!$isPlaceholder)
		            this.$modeId = mode.$id;
		        if (this.$mode === mode) 
		            return;
		
		        this.$mode = mode;
		
		        this.$stopWorker();
		
		        if (this.$useWorker)
		            this.$startWorker();
		
		        var tokenizer = mode.getTokenizer();
		
		        if(tokenizer.addEventListener !== undefined) {
		            var onReloadTokenizer = this.onReloadTokenizer.bind(this);
		            tokenizer.addEventListener("update", onReloadTokenizer);
		        }
		
		        if (!this.bgTokenizer) {
		            this.bgTokenizer = new BackgroundTokenizer(tokenizer);
		            var _self = this;
		            this.bgTokenizer.addEventListener("update", function(e) {
		                _self._signal("tokenizerUpdate", e);
		            });
		        } else {
		            this.bgTokenizer.setTokenizer(tokenizer);
		        }
		
		        this.bgTokenizer.setDocument(this.getDocument());
		
		        this.tokenRe = mode.tokenRe;
		        this.nonTokenRe = mode.nonTokenRe;
		
		        
		        if (!$isPlaceholder) {
		            // experimental method, used by c9 findiniles
		            if (mode.attachToSession)
		                mode.attachToSession(this);
		            this.$options.wrapMethod.set.call(this, this.$wrapMethod);
		            this.$setFolding(mode.foldingRules);
		            this.bgTokenizer.start(0);
		            this._emit("changeMode");
		        }
		    };
		
		    this.$stopWorker = function() {
		        if (this.$worker) {
		            this.$worker.terminate();
		            this.$worker = null;
		        }
		    };
		
		    this.$startWorker = function() {
		        try {
		            this.$worker = this.$mode.createWorker(this);
		        } catch (e) {
		            config.warn("Could not load worker", e);
		            this.$worker = null;
		        }
		    };
		
		    /**
		     * Returns the current text mode.
		     * @returns {TextMode} The current text mode
		     **/
		    this.getMode = function() {
		        return this.$mode;
		    };
		
		    this.$scrollTop = 0;
		    /**
		     * This function sets the scroll top value. It also emits the `'changeScrollTop'` event.
		     * @param {Number} scrollTop The new scroll top value
		     *
		     **/
		    this.setScrollTop = function(scrollTop) {
		        // TODO: should we force integer lineheight instead? scrollTop = Math.round(scrollTop); 
		        if (this.$scrollTop === scrollTop || isNaN(scrollTop))
		            return;
		
		        this.$scrollTop = scrollTop;
		        this._signal("changeScrollTop", scrollTop);
		    };
		
		    /**
		     * [Returns the value of the distance between the top of the editor and the topmost part of the visible content.]{: #EditSession.getScrollTop}
		     * @returns {Number}
		     **/
		    this.getScrollTop = function() {
		        return this.$scrollTop;
		    };
		
		    this.$scrollLeft = 0;
		    /**
		     * [Sets the value of the distance between the left of the editor and the leftmost part of the visible content.]{: #EditSession.setScrollLeft}
		     **/
		    this.setScrollLeft = function(scrollLeft) {
		        // scrollLeft = Math.round(scrollLeft);
		        if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))
		            return;
		
		        this.$scrollLeft = scrollLeft;
		        this._signal("changeScrollLeft", scrollLeft);
		    };
		
		    /**
		     * [Returns the value of the distance between the left of the editor and the leftmost part of the visible content.]{: #EditSession.getScrollLeft}
		     * @returns {Number}
		     **/
		    this.getScrollLeft = function() {
		        return this.$scrollLeft;
		    };
		
		    /**
		     * Returns the width of the screen.
		     * @returns {Number}
		     **/
		    this.getScreenWidth = function() {
		        this.$computeWidth();
		        if (this.lineWidgets) 
		            return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
		        return this.screenWidth;
		    };
		    
		    this.getLineWidgetMaxWidth = function() {
		        if (this.lineWidgetsWidth != null) return this.lineWidgetsWidth;
		        var width = 0;
		        this.lineWidgets.forEach(function(w) {
		            if (w && w.screenWidth > width)
		                width = w.screenWidth;
		        });
		        return this.lineWidgetWidth = width;
		    };
		
		    this.$computeWidth = function(force) {
		        if (this.$modified || force) {
		            this.$modified = false;
		
		            if (this.$useWrapMode)
		                return this.screenWidth = this.$wrapLimit;
		
		            var lines = this.doc.getAllLines();
		            var cache = this.$rowLengthCache;
		            var longestScreenLine = 0;
		            var foldIndex = 0;
		            var foldLine = this.$foldData[foldIndex];
		            var foldStart = foldLine ? foldLine.start.row : Infinity;
		            var len = lines.length;
		
		            for (var i = 0; i < len; i++) {
		                if (i > foldStart) {
		                    i = foldLine.end.row + 1;
		                    if (i >= len)
		                        break;
		                    foldLine = this.$foldData[foldIndex++];
		                    foldStart = foldLine ? foldLine.start.row : Infinity;
		                }
		
		                if (cache[i] == null)
		                    cache[i] = this.$getStringScreenWidth(lines[i])[0];
		
		                if (cache[i] > longestScreenLine)
		                    longestScreenLine = cache[i];
		            }
		            this.screenWidth = longestScreenLine;
		        }
		    };
		
		    /**
		     * Returns a verbatim copy of the given line as it is in the document
		     * @param {Number} row The row to retrieve from
		     *
		     * @returns {String}
		     **/
		    this.getLine = function(row) {
		        return this.doc.getLine(row);
		    };
		
		    /**
		     * Returns an array of strings of the rows between `firstRow` and `lastRow`. This function is inclusive of `lastRow`.
		     * @param {Number} firstRow The first row index to retrieve
		     * @param {Number} lastRow The final row index to retrieve
		     *
		     * @returns {[String]}
		     *
		     **/
		    this.getLines = function(firstRow, lastRow) {
		        return this.doc.getLines(firstRow, lastRow);
		    };
		
		    /**
		     * Returns the number of rows in the document.
		     * @returns {Number}
		     **/
		    this.getLength = function() {
		        return this.doc.getLength();
		    };
		
		    /**
		     * {:Document.getTextRange.desc}
		     * @param {Range} range The range to work with
		     *
		     * @returns {String}
		     **/
		    this.getTextRange = function(range) {
		        return this.doc.getTextRange(range || this.selection.getRange());
		    };
		
		    /**
		     * Inserts a block of `text` and the indicated `position`.
		     * @param {Object} position The position {row, column} to start inserting at
		     * @param {String} text A chunk of text to insert
		     * @returns {Object} The position of the last line of `text`. If the length of `text` is 0, this function simply returns `position`.
		     *
		     *
		     **/
		    this.insert = function(position, text) {
		        return this.doc.insert(position, text);
		    };
		
		    /**
		     * Removes the `range` from the document.
		     * @param {Range} range A specified Range to remove
		     * @returns {Object} The new `start` property of the range, which contains `startRow` and `startColumn`. If `range` is empty, this function returns the unmodified value of `range.start`.
		     *
		     * @related Document.remove
		     *
		     **/
		    this.remove = function(range) {
		        return this.doc.remove(range);
		    };
		    
		    /**
		     * Removes a range of full lines. This method also triggers the `'change'` event.
		     * @param {Number} firstRow The first row to be removed
		     * @param {Number} lastRow The last row to be removed
		     * @returns {[String]} Returns all the removed lines.
		     *
		     * @related Document.removeFullLines
		     *
		     **/
		    this.removeFullLines = function(firstRow, lastRow){
		        return this.doc.removeFullLines(firstRow, lastRow);
		    };
		
		    /**
		     * Reverts previous changes to your document.
		     * @param {Array} deltas An array of previous changes
		     * @param {Boolean} dontSelect [If `true`, doesn't select the range of where the change occured]{: #dontSelect}
		     *
		     * @returns {Range}
		     **/
		    this.undoChanges = function(deltas, dontSelect) {
		        if (!deltas.length)
		            return;
		
		        this.$fromUndo = true;
		        for (var i = deltas.length - 1; i != -1; i--) {
		            var delta = deltas[i];
		            if (delta.action == "insert" || delta.action == "remove") {
		                this.doc.revertDelta(delta);
		            } else if (delta.folds) {
		                this.addFolds(delta.folds);
		            }
		        }
		        if (!dontSelect && this.$undoSelect) {
		            // console.log(deltas.selectionBefore + "uuu")
		            if (deltas.selectionBefore)
		                this.selection.fromJSON(deltas.selectionBefore);
		            else
		                this.selection.setRange(this.$getUndoSelection(deltas, true));
		        }
		        this.$fromUndo = false;
		    };
		
		    /**
		     * Re-implements a previously undone change to your document.
		     * @param {Array} deltas An array of previous changes
		     * @param {Boolean} dontSelect {:dontSelect}
		     *
		     * @returns {Range}
		     **/
		    this.redoChanges = function(deltas, dontSelect) {
		        if (!deltas.length)
		            return;
		
		        this.$fromUndo = true;
		        for (var i = 0; i < deltas.length; i++) {
		            var delta = deltas[i];
		            if (delta.action == "insert" || delta.action == "remove") {
		                this.doc.applyDelta(delta);
		            }
		        }
		
		        if (!dontSelect && this.$undoSelect) {
		            if (deltas.selectionAfter)
		                this.selection.fromJSON(deltas.selectionAfter);
		            else
		                this.selection.setRange(this.$getUndoSelection(deltas, false));
		        }
		        this.$fromUndo = false;
		    };
		
		    /**
		     * Enables or disables highlighting of the range where an undo occurred.
		     * @param {Boolean} enable If `true`, selects the range of the reinserted change
		     *      
		     **/
		    this.setUndoSelect = function(enable) {
		        this.$undoSelect = enable;
		    };
		
		    this.$getUndoSelection = function(deltas, isUndo) {
		        function isInsert(delta) {
		            return isUndo ? delta.action !== "insert" : delta.action === "insert";
		        }
		
		        var range, point;
		        var lastDeltaIsInsert;
		
		        for (var i = 0; i < deltas.length; i++) {
		            var delta = deltas[i];
		            if (!delta.start) continue; // skip folds
		            if (!range) {
		                if (isInsert(delta)) {
		                    range = Range.fromPoints(delta.start, delta.end);
		                    lastDeltaIsInsert = true;
		                } else {
		                    range = Range.fromPoints(delta.start, delta.start);
		                    lastDeltaIsInsert = false;
		                }
		                continue;
		            }
		            
		            if (isInsert(delta)) {
		                point = delta.start;
		                if (range.compare(point.row, point.column) == -1) {
		                    range.setStart(point);
		                }
		                point = delta.end;
		                if (range.compare(point.row, point.column) == 1) {
		                    range.setEnd(point);
		                }
		                lastDeltaIsInsert = true;
		            } else {
		                point = delta.start;
		                if (range.compare(point.row, point.column) == -1) {
		                    range = Range.fromPoints(delta.start, delta.start);
		                }
		                lastDeltaIsInsert = false;
		            }
		        }
		        return range;
		    };
		
		    /**
		     * Replaces a range in the document with the new `text`.
		     *
		     * @param {Range} range A specified Range to replace
		     * @param {String} text The new text to use as a replacement
		     * @returns {Object} An object containing the final row and column, like this:
		     * ```
		     * {row: endRow, column: 0}
		     * ```
		     * If the text and range are empty, this function returns an object containing the current `range.start` value.
		     * If the text is the exact same as what currently exists, this function returns an object containing the current `range.end` value.
		     *
		     * @related Document.replace
		     **/
		    this.replace = function(range, text) {
		        return this.doc.replace(range, text);
		    };
		
		    /**
		     * Moves a range of text from the given range to the given position. `toPosition` is an object that looks like this:
		     *  ```json
		     *    { row: newRowLocation, column: newColumnLocation }
		     *  ```
		     * @param {Range} fromRange The range of text you want moved within the document
		     * @param {Object} toPosition The location (row and column) where you want to move the text to
		     * @returns {Range} The new range where the text was moved to.
		     **/
		    this.moveText = function(fromRange, toPosition, copy) {
		        var text = this.getTextRange(fromRange);
		        var folds = this.getFoldsInRange(fromRange);
		
		        var toRange = Range.fromPoints(toPosition, toPosition);
		        if (!copy) {
		            this.remove(fromRange);
		            var rowDiff = fromRange.start.row - fromRange.end.row;
		            var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
		            if (collDiff) {
		                if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column)
		                    toRange.start.column += collDiff;
		                if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column)
		                    toRange.end.column += collDiff;
		            }
		            if (rowDiff && toRange.start.row >= fromRange.end.row) {
		                toRange.start.row += rowDiff;
		                toRange.end.row += rowDiff;
		            }
		        }
		
		        toRange.end = this.insert(toRange.start, text);
		        if (folds.length) {
		            var oldStart = fromRange.start;
		            var newStart = toRange.start;
		            var rowDiff = newStart.row - oldStart.row;
		            var collDiff = newStart.column - oldStart.column;
		            this.addFolds(folds.map(function(x) {
		                x = x.clone();
		                if (x.start.row == oldStart.row)
		                    x.start.column += collDiff;
		                if (x.end.row == oldStart.row)
		                    x.end.column += collDiff;
		                x.start.row += rowDiff;
		                x.end.row += rowDiff;
		                return x;
		            }));
		        }
		
		        return toRange;
		    };
		
		    /**
		     * Indents all the rows, from `startRow` to `endRow` (inclusive), by prefixing each row with the token in `indentString`.
		     *
		     * If `indentString` contains the `'\t'` character, it's replaced by whatever is defined by [[EditSession.getTabString `getTabString()`]].
		     * @param {Number} startRow Starting row
		     * @param {Number} endRow Ending row
		     * @param {String} indentString The indent token
		     *
		     *
		     **/
		    this.indentRows = function(startRow, endRow, indentString) {
		        indentString = indentString.replace(/\t/g, this.getTabString());
		        for (var row=startRow; row<=endRow; row++)
		            this.doc.insertInLine({row: row, column: 0}, indentString);
		    };
		
		    /**
		     * Outdents all the rows defined by the `start` and `end` properties of `range`.
		     * @param {Range} range A range of rows
		     *
		     **/
		    this.outdentRows = function (range) {
		        var rowRange = range.collapseRows();
		        var deleteRange = new Range(0, 0, 0, 0);
		        var size = this.getTabSize();
		
		        for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {
		            var line = this.getLine(i);
		
		            deleteRange.start.row = i;
		            deleteRange.end.row = i;
		            for (var j = 0; j < size; ++j)
		                if (line.charAt(j) != ' ')
		                    break;
		            if (j < size && line.charAt(j) == '\t') {
		                deleteRange.start.column = j;
		                deleteRange.end.column = j + 1;
		            } else {
		                deleteRange.start.column = 0;
		                deleteRange.end.column = j;
		            }
		            this.remove(deleteRange);
		        }
		    };
		
		    this.$moveLines = function(firstRow, lastRow, dir) {
		        firstRow = this.getRowFoldStart(firstRow);
		        lastRow = this.getRowFoldEnd(lastRow);
		        if (dir < 0) {
		            var row = this.getRowFoldStart(firstRow + dir);
		            if (row < 0) return 0;
		            var diff = row-firstRow;
		        } else if (dir > 0) {
		            var row = this.getRowFoldEnd(lastRow + dir);
		            if (row > this.doc.getLength()-1) return 0;
		            var diff = row-lastRow;
		        } else {
		            firstRow = this.$clipRowToDocument(firstRow);
		            lastRow = this.$clipRowToDocument(lastRow);
		            var diff = lastRow - firstRow + 1;
		        }
		
		        var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
		        var folds = this.getFoldsInRange(range).map(function(x){
		            x = x.clone();
		            x.start.row += diff;
		            x.end.row += diff;
		            return x;
		        });
		        
		        var lines = dir == 0
		            ? this.doc.getLines(firstRow, lastRow)
		            : this.doc.removeFullLines(firstRow, lastRow);
		        this.doc.insertFullLines(firstRow+diff, lines);
		        folds.length && this.addFolds(folds);
		        return diff;
		    };
		    /**
		     * Shifts all the lines in the document up one, starting from `firstRow` and ending at `lastRow`.
		     * @param {Number} firstRow The starting row to move up
		     * @param {Number} lastRow The final row to move up
		     * @returns {Number} If `firstRow` is less-than or equal to 0, this function returns 0. Otherwise, on success, it returns -1.
		     *
		     **/
		    this.moveLinesUp = function(firstRow, lastRow) {
		        return this.$moveLines(firstRow, lastRow, -1);
		    };
		
		    /**
		     * Shifts all the lines in the document down one, starting from `firstRow` and ending at `lastRow`.
		     * @param {Number} firstRow The starting row to move down
		     * @param {Number} lastRow The final row to move down
		     * @returns {Number} If `firstRow` is less-than or equal to 0, this function returns 0. Otherwise, on success, it returns -1.
		     **/
		    this.moveLinesDown = function(firstRow, lastRow) {
		        return this.$moveLines(firstRow, lastRow, 1);
		    };
		
		    /**
		     * Duplicates all the text between `firstRow` and `lastRow`.
		     * @param {Number} firstRow The starting row to duplicate
		     * @param {Number} lastRow The final row to duplicate
		     * @returns {Number} Returns the number of new rows added; in other words, `lastRow - firstRow + 1`.
		     *
		     *
		     **/
		    this.duplicateLines = function(firstRow, lastRow) {
		        return this.$moveLines(firstRow, lastRow, 0);
		    };
		
		
		    this.$clipRowToDocument = function(row) {
		        return Math.max(0, Math.min(row, this.doc.getLength()-1));
		    };
		
		    this.$clipColumnToRow = function(row, column) {
		        if (column < 0)
		            return 0;
		        return Math.min(this.doc.getLine(row).length, column);
		    };
		
		
		    this.$clipPositionToDocument = function(row, column) {
		        column = Math.max(0, column);
		
		        if (row < 0) {
		            row = 0;
		            column = 0;
		        } else {
		            var len = this.doc.getLength();
		            if (row >= len) {
		                row = len - 1;
		                column = this.doc.getLine(len-1).length;
		            } else {
		                column = Math.min(this.doc.getLine(row).length, column);
		            }
		        }
		
		        return {
		            row: row,
		            column: column
		        };
		    };
		
		    this.$clipRangeToDocument = function(range) {
		        if (range.start.row < 0) {
		            range.start.row = 0;
		            range.start.column = 0;
		        } else {
		            range.start.column = this.$clipColumnToRow(
		                range.start.row,
		                range.start.column
		            );
		        }
		
		        var len = this.doc.getLength() - 1;
		        if (range.end.row > len) {
		            range.end.row = len;
		            range.end.column = this.doc.getLine(len).length;
		        } else {
		            range.end.column = this.$clipColumnToRow(
		                range.end.row,
		                range.end.column
		            );
		        }
		        return range;
		    };
		
		    // WRAPMODE
		    this.$wrapLimit = 80;
		    this.$useWrapMode = false;
		    this.$wrapLimitRange = {
		        min : null,
		        max : null
		    };
		
		    /**
		     * Sets whether or not line wrapping is enabled. If `useWrapMode` is different than the current value, the `'changeWrapMode'` event is emitted.
		     * @param {Boolean} useWrapMode Enable (or disable) wrap mode
		     *
		     **/
		    this.setUseWrapMode = function(useWrapMode) {
		        if (useWrapMode != this.$useWrapMode) {
		            this.$useWrapMode = useWrapMode;
		            this.$modified = true;
		            this.$resetRowCache(0);
		
		            // If wrapMode is activaed, the wrapData array has to be initialized.
		            if (useWrapMode) {
		                var len = this.getLength();
		                this.$wrapData = Array(len);
		                this.$updateWrapData(0, len - 1);
		            }
		
		            this._signal("changeWrapMode");
		        }
		    };
		
		    /**
		     * Returns `true` if wrap mode is being used; `false` otherwise.
		     * @returns {Boolean}
		     **/
		    this.getUseWrapMode = function() {
		        return this.$useWrapMode;
		    };
		
		    // Allow the wrap limit to move freely between min and max. Either
		    // parameter can be null to allow the wrap limit to be unconstrained
		    // in that direction. Or set both parameters to the same number to pin
		    // the limit to that value.
		    /**
		     * Sets the boundaries of wrap. Either value can be `null` to have an unconstrained wrap, or, they can be the same number to pin the limit. If the wrap limits for `min` or `max` are different, this method also emits the `'changeWrapMode'` event.
		     * @param {Number} min The minimum wrap value (the left side wrap)
		     * @param {Number} max The maximum wrap value (the right side wrap)
		     *
		     **/
		    this.setWrapLimitRange = function(min, max) {
		        if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
		            this.$wrapLimitRange = { min: min, max: max };
		            this.$modified = true;
		            this.$bidiHandler.markAsDirty();
		
		            // This will force a recalculation of the wrap limit
		            if (this.$useWrapMode)
		                this._signal("changeWrapMode");
		        }
		    };
		
		    /**
		     * This should generally only be called by the renderer when a resize is detected.
		     * @param {Number} desiredLimit The new wrap limit
		     * @returns {Boolean}
		     *
		     * @private
		     **/
		    this.adjustWrapLimit = function(desiredLimit, $printMargin) {
		        var limits = this.$wrapLimitRange;
		        if (limits.max < 0)
		            limits = {min: $printMargin, max: $printMargin};
		        var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
		        if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {
		            this.$wrapLimit = wrapLimit;
		            this.$modified = true;
		            if (this.$useWrapMode) {
		                this.$updateWrapData(0, this.getLength() - 1);
		                this.$resetRowCache(0);
		                this._signal("changeWrapLimit");
		            }
		            return true;
		        }
		        return false;
		    };
		
		    this.$constrainWrapLimit = function(wrapLimit, min, max) {
		        if (min)
		            wrapLimit = Math.max(min, wrapLimit);
		
		        if (max)
		            wrapLimit = Math.min(max, wrapLimit);
		
		        return wrapLimit;
		    };
		
		    /**
		     * Returns the value of wrap limit.
		     * @returns {Number} The wrap limit.
		     **/
		    this.getWrapLimit = function() {
		        return this.$wrapLimit;
		    };
		    
		    /**
		     * Sets the line length for soft wrap in the editor. Lines will break
		     *  at a minimum of the given length minus 20 chars and at a maximum
		     *  of the given number of chars.
		     * @param {number} limit The maximum line length in chars, for soft wrapping lines.
		     */
		    this.setWrapLimit = function (limit) {
		        this.setWrapLimitRange(limit, limit);
		    };
		    
		    /**
		     * Returns an object that defines the minimum and maximum of the wrap limit; it looks something like this:
		     *
		     *     { min: wrapLimitRange_min, max: wrapLimitRange_max }
		     *
		     * @returns {Object}
		     **/
		    this.getWrapLimitRange = function() {
		        // Avoid unexpected mutation by returning a copy
		        return {
		            min : this.$wrapLimitRange.min,
		            max : this.$wrapLimitRange.max
		        };
		    };
		
		    this.$updateInternalDataOnChange = function(delta) {
		        var useWrapMode = this.$useWrapMode;
		        var action = delta.action;
		        var start = delta.start;
		        var end = delta.end;
		        var firstRow = start.row;
		        var lastRow = end.row;
		        var len = lastRow - firstRow;
		        var removedFolds = null;
		        
		        this.$updating = true;
		        if (len != 0) {
		            if (action === "remove") {
		                this[useWrapMode ? "$wrapData" : "$rowLengthCache"].splice(firstRow, len);
		
		                var foldLines = this.$foldData;
		                removedFolds = this.getFoldsInRange(delta);
		                this.removeFolds(removedFolds);
		
		                var foldLine = this.getFoldLine(end.row);
		                var idx = 0;
		                if (foldLine) {
		                    foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
		                    foldLine.shiftRow(-len);
		
		                    var foldLineBefore = this.getFoldLine(firstRow);
		                    if (foldLineBefore && foldLineBefore !== foldLine) {
		                        foldLineBefore.merge(foldLine);
		                        foldLine = foldLineBefore;
		                    }
		                    idx = foldLines.indexOf(foldLine) + 1;
		                }
		
		                for (idx; idx < foldLines.length; idx++) {
		                    var foldLine = foldLines[idx];
		                    if (foldLine.start.row >= end.row) {
		                        foldLine.shiftRow(-len);
		                    }
		                }
		
		                lastRow = firstRow;
		            } else {
		                var args = Array(len);
		                args.unshift(firstRow, 0);
		                var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache;
		                arr.splice.apply(arr, args);
		
		                // If some new line is added inside of a foldLine, then split
		                // the fold line up.
		                var foldLines = this.$foldData;
		                var foldLine = this.getFoldLine(firstRow);
		                var idx = 0;
		                if (foldLine) {
		                    var cmp = foldLine.range.compareInside(start.row, start.column);
		                    // Inside of the foldLine range. Need to split stuff up.
		                    if (cmp == 0) {
		                        foldLine = foldLine.split(start.row, start.column);
		                        if (foldLine) {
		                            foldLine.shiftRow(len);
		                            foldLine.addRemoveChars(lastRow, 0, end.column - start.column);
		                        }
		                    } else
		                    // Infront of the foldLine but same row. Need to shift column.
		                    if (cmp == -1) {
		                        foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
		                        foldLine.shiftRow(len);
		                    }
		                    // Nothing to do if the insert is after the foldLine.
		                    idx = foldLines.indexOf(foldLine) + 1;
		                }
		
		                for (idx; idx < foldLines.length; idx++) {
		                    var foldLine = foldLines[idx];
		                    if (foldLine.start.row >= firstRow) {
		                        foldLine.shiftRow(len);
		                    }
		                }
		            }
		        } else {
		            // Realign folds. E.g. if you add some new chars before a fold, the
		            // fold should "move" to the right.
		            len = Math.abs(delta.start.column - delta.end.column);
		            if (action === "remove") {
		                // Get all the folds in the change range and remove them.
		                removedFolds = this.getFoldsInRange(delta);
		                this.removeFolds(removedFolds);
		
		                len = -len;
		            }
		            var foldLine = this.getFoldLine(firstRow);
		            if (foldLine) {
		                foldLine.addRemoveChars(firstRow, start.column, len);
		            }
		        }
		
		        if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {
		            console.error("doc.getLength() and $wrapData.length have to be the same!");
		        }
		        this.$updating = false;
		
		        if (useWrapMode)
		            this.$updateWrapData(firstRow, lastRow);
		        else
		            this.$updateRowLengthCache(firstRow, lastRow);
		
		        return removedFolds;
		    };
		
		    this.$updateRowLengthCache = function(firstRow, lastRow, b) {
		        this.$rowLengthCache[firstRow] = null;
		        this.$rowLengthCache[lastRow] = null;
		    };
		
		    this.$updateWrapData = function(firstRow, lastRow) {
		        var lines = this.doc.getAllLines();
		        var tabSize = this.getTabSize();
		        var wrapData = this.$wrapData;
		        var wrapLimit = this.$wrapLimit;
		        var tokens;
		        var foldLine;
		
		        var row = firstRow;
		        lastRow = Math.min(lastRow, lines.length - 1);
		        while (row <= lastRow) {
		            foldLine = this.getFoldLine(row, foldLine);
		            if (!foldLine) {
		                tokens = this.$getDisplayTokens(lines[row]);
		                wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
		                row ++;
		            } else {
		                tokens = [];
		                foldLine.walk(function(placeholder, row, column, lastColumn) {
		                        var walkTokens;
		                        if (placeholder != null) {
		                            walkTokens = this.$getDisplayTokens(
		                                            placeholder, tokens.length);
		                            walkTokens[0] = PLACEHOLDER_START;
		                            for (var i = 1; i < walkTokens.length; i++) {
		                                walkTokens[i] = PLACEHOLDER_BODY;
		                            }
		                        } else {
		                            walkTokens = this.$getDisplayTokens(
		                                lines[row].substring(lastColumn, column),
		                                tokens.length);
		                        }
		                        tokens = tokens.concat(walkTokens);
		                    }.bind(this),
		                    foldLine.end.row,
		                    lines[foldLine.end.row].length + 1
		                );
		
		                wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
		                row = foldLine.end.row + 1;
		            }
		        }
		    };
		
		    // "Tokens"
		    var CHAR = 1,
		        CHAR_EXT = 2,
		        PLACEHOLDER_START = 3,
		        PLACEHOLDER_BODY =  4,
		        PUNCTUATION = 9,
		        SPACE = 10,
		        TAB = 11,
		        TAB_SPACE = 12;
		
		
		    this.$computeWrapSplits = function(tokens, wrapLimit, tabSize) {
		        if (tokens.length == 0) {
		            return [];
		        }
		
		        var splits = [];
		        var displayLength = tokens.length;
		        var lastSplit = 0, lastDocSplit = 0;
		
		        var isCode = this.$wrapAsCode;
		
		        var indentedSoftWrap = this.$indentedSoftWrap;
		        var maxIndent = wrapLimit <= Math.max(2 * tabSize, 8)
		            || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);
		
		        function getWrapIndent() {
		            var indentation = 0;
		            if (maxIndent === 0)
		                return indentation;
		            if (indentedSoftWrap) {
		                for (var i = 0; i < tokens.length; i++) {
		                    var token = tokens[i];
		                    if (token == SPACE)
		                        indentation += 1;
		                    else if (token == TAB)
		                        indentation += tabSize;
		                    else if (token == TAB_SPACE)
		                        continue;
		                    else
		                        break;
		                }
		            }
		            if (isCode && indentedSoftWrap !== false)
		                indentation += tabSize;
		            return Math.min(indentation, maxIndent);
		        }
		        function addSplit(screenPos) {
		            var displayed = tokens.slice(lastSplit, screenPos);
		
		            // The document size is the current size - the extra width for tabs
		            // and multipleWidth characters.
		            var len = displayed.length;
		            displayed.join("")
		                // Get all the TAB_SPACEs.
		                .replace(/12/g, function() {
		                    len -= 1;
		                })
		                // Get all the CHAR_EXT/multipleWidth characters.
		                .replace(/2/g, function() {
		                    len -= 1;
		                });
		
		            if (!splits.length) {
		                indent = getWrapIndent();
		                splits.indent = indent;
		            }
		            lastDocSplit += len;
		            splits.push(lastDocSplit);
		            lastSplit = screenPos;
		        }
		        var indent = 0;
		        while (displayLength - lastSplit > wrapLimit - indent) {
		            // This is, where the split should be.
		            var split = lastSplit + wrapLimit - indent;
		
		            // If there is a space or tab at this split position, then making
		            // a split is simple.
		            if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {
		                /* disabled see https://github.com/ajaxorg/ace/issues/1186
		                // Include all following spaces + tabs in this split as well.
		                while (tokens[split] >= SPACE) {
		                    split ++;
		                } */
		                addSplit(split);
		                continue;
		            }
		
		            // === ELSE ===
		            // Check if split is inside of a placeholder. Placeholder are
		            // not splitable. Therefore, seek the beginning of the placeholder
		            // and try to place the split before the placeholder's start.
		            if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {
		                // Seek the start of the placeholder and do the split
		                // before the placeholder. By definition there always
		                // a PLACEHOLDER_START between split and lastSplit.
		                for (split; split != lastSplit - 1; split--) {
		                    if (tokens[split] == PLACEHOLDER_START) {
		                        // split++; << No incremental here as we want to
		                        //  have the position before the Placeholder.
		                        break;
		                    }
		                }
		
		                // If the PLACEHOLDER_START is not the index of the
		                // last split, then we can do the split
		                if (split > lastSplit) {
		                    addSplit(split);
		                    continue;
		                }
		
		                // If the PLACEHOLDER_START IS the index of the last
		                // split, then we have to place the split after the
		                // placeholder. So, let's seek for the end of the placeholder.
		                split = lastSplit + wrapLimit;
		                for (split; split < tokens.length; split++) {
		                    if (tokens[split] != PLACEHOLDER_BODY) {
		                        break;
		                    }
		                }
		
		                // If spilt == tokens.length, then the placeholder is the last
		                // thing in the line and adding a new split doesn't make sense.
		                if (split == tokens.length) {
		                    break;  // Breaks the while-loop.
		                }
		
		                // Finally, add the split...
		                addSplit(split);
		                continue;
		            }
		
		            // === ELSE ===
		            // Search for the first non space/tab/placeholder/punctuation token backwards.
		            var minSplit = Math.max(split - (wrapLimit -(wrapLimit>>2)), lastSplit - 1);
		            while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
		                split --;
		            }
		            if (isCode) {
		                while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
		                    split --;
		                }
		                while (split > minSplit && tokens[split] == PUNCTUATION) {
		                    split --;
		                }
		            } else {
		                while (split > minSplit && tokens[split] < SPACE) {
		                    split --;
		                }
		            }
		            // If we found one, then add the split.
		            if (split > minSplit) {
		                addSplit(++split);
		                continue;
		            }
		
		            // === ELSE ===
		            split = lastSplit + wrapLimit;
		            // The split is inside of a CHAR or CHAR_EXT token and no space
		            // around -> force a split.
		            if (tokens[split] == CHAR_EXT)
		                split--;
		            addSplit(split - indent);
		        }
		        return splits;
		    };
		
		    /**
		     * Given a string, returns an array of the display characters, including tabs and spaces.
		     * @param {String} str The string to check
		     * @param {Number} offset The value to start at
		     *
		     **/
		    this.$getDisplayTokens = function(str, offset) {
		        var arr = [];
		        var tabSize;
		        offset = offset || 0;
		
		        for (var i = 0; i < str.length; i++) {
		            var c = str.charCodeAt(i);
		            // Tab
		            if (c == 9) {
		                tabSize = this.getScreenTabSize(arr.length + offset);
		                arr.push(TAB);
		                for (var n = 1; n < tabSize; n++) {
		                    arr.push(TAB_SPACE);
		                }
		            }
		            // Space
		            else if (c == 32) {
		                arr.push(SPACE);
		            } else if((c > 39 && c < 48) || (c > 57 && c < 64)) {
		                arr.push(PUNCTUATION);
		            }
		            // full width characters
		            else if (c >= 0x1100 && isFullWidth(c)) {
		                arr.push(CHAR, CHAR_EXT);
		            } else {
		                arr.push(CHAR);
		            }
		        }
		        return arr;
		    };
		
		    /**
		     * Calculates the width of the string `str` on the screen while assuming that the string starts at the first column on the screen.
		     * @param {String} str The string to calculate the screen width of
		     * @param {Number} maxScreenColumn
		     * @param {Number} screenColumn
		     * @returns {[Number]} Returns an `int[]` array with two elements:<br/>
		     * The first position indicates the number of columns for `str` on screen.<br/>
		     * The second value contains the position of the document column that this function read until.
		     *
		     **/
		    this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
		        if (maxScreenColumn == 0)
		            return [0, 0];
		        if (maxScreenColumn == null)
		            maxScreenColumn = Infinity;
		        screenColumn = screenColumn || 0;
		
		        var c, column;
		        for (column = 0; column < str.length; column++) {
		            c = str.charCodeAt(column);
		            // tab
		            if (c == 9) {
		                screenColumn += this.getScreenTabSize(screenColumn);
		            }
		            // full width characters
		            else if (c >= 0x1100 && isFullWidth(c)) {
		                screenColumn += 2;
		            } else {
		                screenColumn += 1;
		            }
		            if (screenColumn > maxScreenColumn) {
		                break;
		            }
		        }
		
		        return [screenColumn, column];
		    };
		
		    this.lineWidgets = null;
		    /**
		     * Returns number of screenrows in a wrapped line.
		     * @param {Number} row The row number to check
		     *
		     * @returns {Number}
		     **/
		    this.getRowLength = function(row) {
		        if (this.lineWidgets)
		            var h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
		        else 
		            h = 0;
		        if (!this.$useWrapMode || !this.$wrapData[row]) {
		            return 1 + h;
		        } else {
		            return this.$wrapData[row].length + 1 + h;
		        }
		    };
		    this.getRowLineCount = function(row) {
		        if (!this.$useWrapMode || !this.$wrapData[row]) {
		            return 1;
		        } else {
		            return this.$wrapData[row].length + 1;
		        }
		    };
		
		    this.getRowWrapIndent = function(screenRow) {
		        if (this.$useWrapMode) {
		            var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
		            var splits = this.$wrapData[pos.row];
		            return splits.length && splits[0] < pos.column ? splits.indent : 0;
		        } else {
		            return 0;
		        }
		    };
		
		    /**
		     * Returns the position (on screen) for the last character in the provided screen row.
		     * @param {Number} screenRow The screen row to check
		     * @returns {Number}
		     *
		     * @related EditSession.documentToScreenColumn
		     **/
		    this.getScreenLastRowColumn = function(screenRow) {
		        var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
		        return this.documentToScreenColumn(pos.row, pos.column);
		    };
		
		    /**
		     * For the given document row and column, this returns the column position of the last screen row.
		     * @param {Number} docRow
		     *
		     * @param {Number} docColumn
		     **/
		    this.getDocumentLastRowColumn = function(docRow, docColumn) {
		        var screenRow = this.documentToScreenRow(docRow, docColumn);
		        return this.getScreenLastRowColumn(screenRow);
		    };
		
		    /**
		     * For the given document row and column, this returns the document position of the last row.
		     * @param {Number} docRow
		     * @param {Number} docColumn
		     *
		     **/
		    this.getDocumentLastRowColumnPosition = function(docRow, docColumn) {
		        var screenRow = this.documentToScreenRow(docRow, docColumn);
		        return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
		    };
		
		    /**
		     * For the given row, this returns the split data.
		     * @returns {String}
		     **/
		    this.getRowSplitData = function(row) {
		        if (!this.$useWrapMode) {
		            return undefined;
		        } else {
		            return this.$wrapData[row];
		        }
		    };
		
		    /**
		     * The distance to the next tab stop at the specified screen column.
		     * @param {Number} screenColumn The screen column to check
		     *
		     * @returns {Number}
		     **/
		    this.getScreenTabSize = function(screenColumn) {
		        return this.$tabSize - screenColumn % this.$tabSize;
		    };
		
		
		    this.screenToDocumentRow = function(screenRow, screenColumn) {
		        return this.screenToDocumentPosition(screenRow, screenColumn).row;
		    };
		
		
		    this.screenToDocumentColumn = function(screenRow, screenColumn) {
		        return this.screenToDocumentPosition(screenRow, screenColumn).column;
		    };
		
		    /**
		     * Converts characters coordinates on the screen to characters coordinates within the document. [This takes into account code folding, word wrap, tab size, and any other visual modifications.]{: #conversionConsiderations}
		     * @param {Number} screenRow The screen row to check
		     * @param {Number} screenColumn The screen column to check
		     * @param {int} screen character x-offset [optional]
		     *
		     * @returns {Object} The object returned has two properties: `row` and `column`.
		     *
		     * @related EditSession.documentToScreenPosition
		     **/
		    this.screenToDocumentPosition = function(screenRow, screenColumn, offsetX) {
		        if (screenRow < 0)
		            return {row: 0, column: 0};
		
		        var line;
		        var docRow = 0;
		        var docColumn = 0;
		        var column;
		        var row = 0;
		        var rowLength = 0;
		
		        var rowCache = this.$screenRowCache;
		        var i = this.$getRowCacheIndex(rowCache, screenRow);
		        var l = rowCache.length;
		        if (l && i >= 0) {
		            var row = rowCache[i];
		            var docRow = this.$docRowCache[i];
		            var doCache = screenRow > rowCache[l - 1];
		        } else {
		            var doCache = !l;
		        }
		
		        var maxRow = this.getLength() - 1;
		        var foldLine = this.getNextFoldLine(docRow);
		        var foldStart = foldLine ? foldLine.start.row : Infinity;
		
		        while (row <= screenRow) {
		            rowLength = this.getRowLength(docRow);
		            if (row + rowLength > screenRow || docRow >= maxRow) {
		                break;
		            } else {
		                row += rowLength;
		                docRow++;
		                if (docRow > foldStart) {
		                    docRow = foldLine.end.row+1;
		                    foldLine = this.getNextFoldLine(docRow, foldLine);
		                    foldStart = foldLine ? foldLine.start.row : Infinity;
		                }
		            }
		
		            if (doCache) {
		                this.$docRowCache.push(docRow);
		                this.$screenRowCache.push(row);
		            }
		        }
		
		        if (foldLine && foldLine.start.row <= docRow) {
		            line = this.getFoldDisplayLine(foldLine);
		            docRow = foldLine.start.row;
		        } else if (row + rowLength <= screenRow || docRow > maxRow) {
		            // clip at the end of the document
		            return {
		                row: maxRow,
		                column: this.getLine(maxRow).length
		            };
		        } else {
		            line = this.getLine(docRow);
		            foldLine = null;
		        }
		        var wrapIndent = 0, splitIndex = Math.floor(screenRow - row);
		        if (this.$useWrapMode) {
		            var splits = this.$wrapData[docRow];
		            if (splits) {
		                column = splits[splitIndex];
		                if(splitIndex > 0 && splits.length) {
		                    wrapIndent = splits.indent;
		                    docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
		                    line = line.substring(docColumn);
		                }
		            }
		        }
		
		        if (offsetX !== undefined && this.$bidiHandler.isBidiRow(row + splitIndex, docRow, splitIndex))
		            screenColumn = this.$bidiHandler.offsetToCol(offsetX);
		
		        docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];
		
		        // We remove one character at the end so that the docColumn
		        // position returned is not associated to the next row on the screen.
		        if (this.$useWrapMode && docColumn >= column)
		            docColumn = column - 1;
		
		        if (foldLine)
		            return foldLine.idxToPosition(docColumn);
		
		        return {row: docRow, column: docColumn};
		    };
		
		    /**
		     * Converts document coordinates to screen coordinates. {:conversionConsiderations}
		     * @param {Number} docRow The document row to check
		     * @param {Number} docColumn The document column to check
		     * @returns {Object} The object returned by this method has two properties: `row` and `column`.
		     *
		     * @related EditSession.screenToDocumentPosition
		     **/
		    this.documentToScreenPosition = function(docRow, docColumn) {
		        // Normalize the passed in arguments.
		        if (typeof docColumn === "undefined")
		            var pos = this.$clipPositionToDocument(docRow.row, docRow.column);
		        else
		            pos = this.$clipPositionToDocument(docRow, docColumn);
		
		        docRow = pos.row;
		        docColumn = pos.column;
		
		        var screenRow = 0;
		        var foldStartRow = null;
		        var fold = null;
		
		        // Clamp the docRow position in case it's inside of a folded block.
		        fold = this.getFoldAt(docRow, docColumn, 1);
		        if (fold) {
		            docRow = fold.start.row;
		            docColumn = fold.start.column;
		        }
		
		        var rowEnd, row = 0;
		
		
		        var rowCache = this.$docRowCache;
		        var i = this.$getRowCacheIndex(rowCache, docRow);
		        var l = rowCache.length;
		        if (l && i >= 0) {
		            var row = rowCache[i];
		            var screenRow = this.$screenRowCache[i];
		            var doCache = docRow > rowCache[l - 1];
		        } else {
		            var doCache = !l;
		        }
		
		        var foldLine = this.getNextFoldLine(row);
		        var foldStart = foldLine ?foldLine.start.row :Infinity;
		
		        while (row < docRow) {
		            if (row >= foldStart) {
		                rowEnd = foldLine.end.row + 1;
		                if (rowEnd > docRow)
		                    break;
		                foldLine = this.getNextFoldLine(rowEnd, foldLine);
		                foldStart = foldLine ?foldLine.start.row :Infinity;
		            }
		            else {
		                rowEnd = row + 1;
		            }
		
		            screenRow += this.getRowLength(row);
		            row = rowEnd;
		
		            if (doCache) {
		                this.$docRowCache.push(row);
		                this.$screenRowCache.push(screenRow);
		            }
		        }
		
		        // Calculate the text line that is displayed in docRow on the screen.
		        var textLine = "";
		        // Check if the final row we want to reach is inside of a fold.
		        if (foldLine && row >= foldStart) {
		            textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
		            foldStartRow = foldLine.start.row;
		        } else {
		            textLine = this.getLine(docRow).substring(0, docColumn);
		            foldStartRow = docRow;
		        }
		        var wrapIndent = 0;
		        // Clamp textLine if in wrapMode.
		        if (this.$useWrapMode) {
		            var wrapRow = this.$wrapData[foldStartRow];
		            if (wrapRow) {
		                var screenRowOffset = 0;
		                while (textLine.length >= wrapRow[screenRowOffset]) {
		                    screenRow ++;
		                    screenRowOffset++;
		                }
		                textLine = textLine.substring(
		                    wrapRow[screenRowOffset - 1] || 0, textLine.length
		                );
		                wrapIndent = screenRowOffset > 0 ? wrapRow.indent : 0;
		            }
		        }
		
		        return {
		            row: screenRow,
		            column: wrapIndent + this.$getStringScreenWidth(textLine)[0]
		        };
		    };
		
		    /**
		     * For the given document row and column, returns the screen column.
		     * @param {Number} row
		     * @param {Number} docColumn
		     * @returns {Number}
		     *
		     **/
		    this.documentToScreenColumn = function(row, docColumn) {
		        return this.documentToScreenPosition(row, docColumn).column;
		    };
		
		    /**
		     * For the given document row and column, returns the screen row.
		     * @param {Number} docRow
		     * @param {Number} docColumn
		     *
		     **/
		    this.documentToScreenRow = function(docRow, docColumn) {
		        return this.documentToScreenPosition(docRow, docColumn).row;
		    };
		
		    /**
		     * Returns the length of the screen.
		     * @returns {Number}
		     **/
		    this.getScreenLength = function() {
		        var screenRows = 0;
		        var fold = null;
		        if (!this.$useWrapMode) {
		            screenRows = this.getLength();
		
		            // Remove the folded lines again.
		            var foldData = this.$foldData;
		            for (var i = 0; i < foldData.length; i++) {
		                fold = foldData[i];
		                screenRows -= fold.end.row - fold.start.row;
		            }
		        } else {
		            var lastRow = this.$wrapData.length;
		            var row = 0, i = 0;
		            var fold = this.$foldData[i++];
		            var foldStart = fold ? fold.start.row :Infinity;
		
		            while (row < lastRow) {
		                var splits = this.$wrapData[row];
		                screenRows += splits ? splits.length + 1 : 1;
		                row ++;
		                if (row > foldStart) {
		                    row = fold.end.row+1;
		                    fold = this.$foldData[i++];
		                    foldStart = fold ?fold.start.row :Infinity;
		                }
		            }
		        }
		
		        // todo
		        if (this.lineWidgets)
		            screenRows += this.$getWidgetScreenLength();
		
		        return screenRows;
		    };
		    
		    /**
		     * @private
		     *
		     */
		    this.$setFontMetrics = function(fm) {
		        if (!this.$enableVarChar) return;
		        this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
		            if (maxScreenColumn === 0)
		                return [0, 0];
		            if (!maxScreenColumn)
		                maxScreenColumn = Infinity;
		            screenColumn = screenColumn || 0;
		            
		            var c, column;
		            for (column = 0; column < str.length; column++) {
		                c = str.charAt(column);
		                // tab
		                if (c === "\t") {
		                    screenColumn += this.getScreenTabSize(screenColumn);
		                } else {
		                    screenColumn += fm.getCharacterWidth(c);
		                }
		                if (screenColumn > maxScreenColumn) {
		                    break;
		                }
		            }
		            
		            return [screenColumn, column];
		        };
		    };
		    
		    this.destroy = function() {
		        if (this.bgTokenizer) {
		            this.bgTokenizer.setDocument(null);
		            this.bgTokenizer = null;
		        }
		        this.$stopWorker();
		    };
		
		    this.isFullWidth = isFullWidth;
		
		    // For every keystroke this gets called once per char in the whole doc!!
		    // Wouldn't hurt to make it a bit faster for c >= 0x1100
		    function isFullWidth(c) {
		        if (c < 0x1100)
		            return false;
		        return c >= 0x1100 && c <= 0x115F ||
		               c >= 0x11A3 && c <= 0x11A7 ||
		               c >= 0x11FA && c <= 0x11FF ||
		               c >= 0x2329 && c <= 0x232A ||
		               c >= 0x2E80 && c <= 0x2E99 ||
		               c >= 0x2E9B && c <= 0x2EF3 ||
		               c >= 0x2F00 && c <= 0x2FD5 ||
		               c >= 0x2FF0 && c <= 0x2FFB ||
		               c >= 0x3000 && c <= 0x303E ||
		               c >= 0x3041 && c <= 0x3096 ||
		               c >= 0x3099 && c <= 0x30FF ||
		               c >= 0x3105 && c <= 0x312D ||
		               c >= 0x3131 && c <= 0x318E ||
		               c >= 0x3190 && c <= 0x31BA ||
		               c >= 0x31C0 && c <= 0x31E3 ||
		               c >= 0x31F0 && c <= 0x321E ||
		               c >= 0x3220 && c <= 0x3247 ||
		               c >= 0x3250 && c <= 0x32FE ||
		               c >= 0x3300 && c <= 0x4DBF ||
		               c >= 0x4E00 && c <= 0xA48C ||
		               c >= 0xA490 && c <= 0xA4C6 ||
		               c >= 0xA960 && c <= 0xA97C ||
		               c >= 0xAC00 && c <= 0xD7A3 ||
		               c >= 0xD7B0 && c <= 0xD7C6 ||
		               c >= 0xD7CB && c <= 0xD7FB ||
		               c >= 0xF900 && c <= 0xFAFF ||
		               c >= 0xFE10 && c <= 0xFE19 ||
		               c >= 0xFE30 && c <= 0xFE52 ||
		               c >= 0xFE54 && c <= 0xFE66 ||
		               c >= 0xFE68 && c <= 0xFE6B ||
		               c >= 0xFF01 && c <= 0xFF60 ||
		               c >= 0xFFE0 && c <= 0xFFE6;
		    }
		
		}).call(EditSession.prototype);
		
		require("./edit_session/folding").Folding.call(EditSession.prototype);
		require("./edit_session/bracket_match").BracketMatch.call(EditSession.prototype);
		
		
		config.defineOptions(EditSession.prototype, "session", {
		    wrap: {
		        set: function(value) {
		            if (!value || value == "off")
		                value = false;
		            else if (value == "free")
		                value = true;
		            else if (value == "printMargin")
		                value = -1;
		            else if (typeof value == "string")
		                value = parseInt(value, 10) || false;
		
		            if (this.$wrap == value)
		                return;
		            this.$wrap = value;
		            if (!value) {
		                this.setUseWrapMode(false);
		            } else {
		                var col = typeof value == "number" ? value : null;
		                this.setWrapLimitRange(col, col);
		                this.setUseWrapMode(true);
		            }
		        },
		        get: function() {
		            if (this.getUseWrapMode()) {
		                if (this.$wrap == -1)
		                    return "printMargin";
		                if (!this.getWrapLimitRange().min)
		                    return "free";
		                return this.$wrap;
		            }
		            return "off";
		        },
		        handlesSet: true
		    },    
		    wrapMethod: {
		        // code|text|auto
		        set: function(val) {
		            val = val == "auto"
		                ? this.$mode.type != "text"
		                : val != "text";
		            if (val != this.$wrapAsCode) {
		                this.$wrapAsCode = val;
		                if (this.$useWrapMode) {
		                    this.$modified = true;
		                    this.$resetRowCache(0);
		                    this.$updateWrapData(0, this.getLength() - 1);
		                }
		            }
		        },
		        initialValue: "auto"
		    },
		    indentedSoftWrap: { initialValue: true },
		    firstLineNumber: {
		        set: function() {this._signal("changeBreakpoint");},
		        initialValue: 1
		    },
		    useWorker: {
		        set: function(useWorker) {
		            this.$useWorker = useWorker;
		
		            this.$stopWorker();
		            if (useWorker)
		                this.$startWorker();
		        },
		        initialValue: true
		    },
		    useSoftTabs: {initialValue: true},
		    tabSize: {
		        set: function(tabSize) {
		            if (isNaN(tabSize) || this.$tabSize === tabSize) return;
		
		            this.$modified = true;
		            this.$rowLengthCache = [];
		            this.$tabSize = tabSize;
		            this._signal("changeTabSize");
		        },
		        initialValue: 4,
		        handlesSet: true
		    },
		    navigateWithinSoftTabs: {initialValue: false},
		    overwrite: {
		        set: function(val) {this._signal("changeOverwrite");},
		        initialValue: false
		    },
		    newLineMode: {
		        set: function(val) {this.doc.setNewLineMode(val);},
		        get: function() {return this.doc.getNewLineMode();},
		        handlesSet: true
		    },
		    mode: {
		        set: function(val) { this.setMode(val); },
		        get: function() { return this.$modeId; }
		    }
		});
		
		exports.EditSession = EditSession;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/editor.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		/* ***** BEGIN LICENSE BLOCK *****
		 * Distributed under the BSD license:
		 *
		 * Copyright (c) 2010, Ajax.org B.V.
		 * All rights reserved.
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are met:
		 *     * Redistributions of source code must retain the above copyright
		 *       notice, this list of conditions and the following disclaimer.
		 *     * Redistributions in binary form must reproduce the above copyright
		 *       notice, this list of conditions and the following disclaimer in the
		 *       documentation and/or other materials provided with the distribution.
		 *     * Neither the name of Ajax.org B.V. nor the
		 *       names of its contributors may be used to endorse or promote products
		 *       derived from this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
		 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
		 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
		 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
		 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
		 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
		 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
		 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
		 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 *
		 * ***** END LICENSE BLOCK ***** */
		
		
		require("./lib/fixoldbrowsers");
		
		var oop = require("./lib/oop");
		var dom = require("./lib/dom");
		var lang = require("./lib/lang");
		var useragent = require("./lib/useragent");
		var TextInput = require("./keyboard/textinput").TextInput;
		var MouseHandler = require("./mouse/mouse_handler").MouseHandler;
		var FoldHandler = require("./mouse/fold_handler").FoldHandler;
		var KeyBinding = require("./keyboard/keybinding").KeyBinding;
		var EditSession = require("./edit_session").EditSession;
		var Search = require("./search").Search;
		var Range = require("./range").Range;
		var EventEmitter = require("./lib/event_emitter").EventEmitter;
		var CommandManager = require("./commands/command_manager").CommandManager;
		var defaultCommands = require("./commands/default_commands").commands;
		var config = require("./config");
		var TokenIterator = require("./token_iterator").TokenIterator;
		
		var clipboard = require("./clipboard");
		
		/**
		 * The main entry point into the Ace functionality.
		 *
		 * The `Editor` manages the [[EditSession]] (which manages [[Document]]s), as well as the [[VirtualRenderer]], which draws everything to the screen.
		 *
		 * Event sessions dealing with the mouse and keyboard are bubbled up from `Document` to the `Editor`, which decides what to do with them.
		 * @class Editor
		 **/
		
		/**
		 * Creates a new `Editor` object.
		 *
		 * @param {VirtualRenderer} renderer Associated `VirtualRenderer` that draws everything
		 * @param {EditSession} session The `EditSession` to refer to
		 *
		 *
		 * @constructor
		 **/
		var Editor = function(renderer, session) {
		    var container = renderer.getContainerElement();
		    this.container = container;
		    this.renderer = renderer;
		    this.id = "editor" + (++Editor.$uid);
		
		    this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
		    if (typeof document == "object") {
		        this.textInput  = new TextInput(renderer.getTextAreaContainer(), this);
		        this.renderer.textarea = this.textInput.getElement();
		        // TODO detect touch event support
		        this.$mouseHandler = new MouseHandler(this);
		        new FoldHandler(this);
		    }
		
		    this.keyBinding = new KeyBinding(this);
		
		    this.$search = new Search().set({
		        wrap: true
		    });
		
		    this.$historyTracker = this.$historyTracker.bind(this);
		    this.commands.on("exec", this.$historyTracker);
		
		    this.$initOperationListeners();
		    
		    this._$emitInputEvent = lang.delayedCall(function() {
		        this._signal("input", {});
		        if (this.session && this.session.bgTokenizer)
		            this.session.bgTokenizer.scheduleStart();
		    }.bind(this));
		    
		    this.on("change", function(_, _self) {
		        _self._$emitInputEvent.schedule(31);
		    });
		
		    this.setSession(session || new EditSession(""));
		    config.resetOptions(this);
		    config._signal("editor", this);
		};
		
		Editor.$uid = 0;
		
		(function(){
		
		    oop.implement(this, EventEmitter);
		
		    this.$initOperationListeners = function() {
		        this.commands.on("exec", this.startOperation.bind(this), true);
		        this.commands.on("afterExec", this.endOperation.bind(this), true);
		
		        this.$opResetTimer = lang.delayedCall(this.endOperation.bind(this));
		        
		        // todo: add before change events?
		        this.on("change", function() {
		            if (!this.curOp) {
		                this.startOperation();
		                this.curOp.selectionBefore = this.$lastSel;
		            }
		            this.curOp.docChanged = true;
		        }.bind(this), true);
		        
		        this.on("changeSelection", function() {
		            if (!this.curOp) {
		                this.startOperation();
		                this.curOp.selectionBefore = this.$lastSel;
		            }
		            this.curOp.selectionChanged = true;
		        }.bind(this), true);
		    };
		
		    this.curOp = null;
		    this.prevOp = {};
		    this.startOperation = function(commadEvent) {
		        if (this.curOp) {
		            if (!commadEvent || this.curOp.command)
		                return;
		            this.prevOp = this.curOp;
		        }
		        if (!commadEvent) {
		            this.previousCommand = null;
		            commadEvent = {};
		        }
		
		        this.$opResetTimer.schedule();
		        this.curOp = this.session.curOp = {
		            command: commadEvent.command || {},
		            args: commadEvent.args,
		            scrollTop: this.renderer.scrollTop
		        };
		        this.curOp.selectionBefore = this.selection.toJSON();
		    };
		
		    this.endOperation = function(e) {
		        if (this.curOp) {
		            if (e && e.returnValue === false)
		                return (this.curOp = null);
		            this._signal("beforeEndOperation");
		            var command = this.curOp.command;
		            var scrollIntoView = command && command.scrollIntoView;
		            if (scrollIntoView) {
		                switch (scrollIntoView) {
		                    case "center-animate":
		                        scrollIntoView = "animate";
		                        /* fall through */
		                    case "center":
		                        this.renderer.scrollCursorIntoView(null, 0.5);
		                        break;
		                    case "animate":
		                    case "cursor":
		                        this.renderer.scrollCursorIntoView();
		                        break;
		                    case "selectionPart":
		                        var range = this.selection.getRange();
		                        var config = this.renderer.layerConfig;
		                        if (range.start.row >= config.lastRow || range.end.row <= config.firstRow) {
		                            this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
		                        }
		                        break;
		                    default:
		                        break;
		                }
		                if (scrollIntoView == "animate")
		                    this.renderer.animateScrolling(this.curOp.scrollTop);
		            }
		            var sel = this.selection.toJSON();
		            this.curOp.selectionAfter = sel;
		            this.$lastSel = this.selection.toJSON();
		            
		            // console.log(this.$lastSel+"  endOP")
		            this.session.getUndoManager().addSelection(sel);
		            this.prevOp = this.curOp;
		            this.curOp = null;
		        }
		    };
		
		    // TODO use property on commands instead of this
		    this.$mergeableCommands = ["backspace", "del", "insertstring"];
		    this.$historyTracker = function(e) {
		        if (!this.$mergeUndoDeltas)
		            return;
		
		        var prev = this.prevOp;
		        var mergeableCommands = this.$mergeableCommands;
		        // previous command was the same
		        var shouldMerge = prev.command && (e.command.name == prev.command.name);
		        if (e.command.name == "insertstring") {
		            var text = e.args;
		            if (this.mergeNextCommand === undefined)
		                this.mergeNextCommand = true;
		
		            shouldMerge = shouldMerge
		                && this.mergeNextCommand // previous command allows to coalesce with
		                && (!/\s/.test(text) || /\s/.test(prev.args)); // previous insertion was of same type
		
		            this.mergeNextCommand = true;
		        } else {
		            shouldMerge = shouldMerge
		                && mergeableCommands.indexOf(e.command.name) !== -1; // the command is mergeable
		        }
		
		        if (
		            this.$mergeUndoDeltas != "always"
		            && Date.now() - this.sequenceStartTime > 2000
		        ) {
		            shouldMerge = false; // the sequence is too long
		        }
		
		        if (shouldMerge)
		            this.session.mergeUndoDeltas = true;
		        else if (mergeableCommands.indexOf(e.command.name) !== -1)
		            this.sequenceStartTime = Date.now();
		    };
		
		    /**
		     * Sets a new key handler, such as "vim" or "windows".
		     * @param {String} keyboardHandler The new key handler
		     *
		     **/
		    this.setKeyboardHandler = function(keyboardHandler, cb) {
		        if (keyboardHandler && typeof keyboardHandler === "string") {
		            this.$keybindingId = keyboardHandler;
		            var _self = this;
		            config.loadModule(["keybinding", keyboardHandler], function(module) {
		                if (_self.$keybindingId == keyboardHandler)
		                    _self.keyBinding.setKeyboardHandler(module && module.handler);
		                cb && cb();
		            });
		        } else {
		            this.$keybindingId = null;
		            this.keyBinding.setKeyboardHandler(keyboardHandler);
		            cb && cb();
		        }
		    };
		
		    /**
		     * Returns the keyboard handler, such as "vim" or "windows".
		     *
		     * @returns {String}
		     *
		     **/
		    this.getKeyboardHandler = function() {
		        return this.keyBinding.getKeyboardHandler();
		    };
		
		
		    /**
		     * Emitted whenever the [[EditSession]] changes.
		     * @event changeSession
		     * @param {Object} e An object with two properties, `oldSession` and `session`, that represent the old and new [[EditSession]]s.
		     *
		     **/
		    /**
		     * Sets a new editsession to use. This method also emits the `'changeSession'` event.
		     * @param {EditSession} session The new session to use
		     *
		     **/
		    this.setSession = function(session) {
		        if (this.session == session)
		            return;
		        
		        // make sure operationEnd events are not emitted to wrong session
		        if (this.curOp) this.endOperation();
		        this.curOp = {};
		
		        var oldSession = this.session;
		        if (oldSession) {
		            this.session.off("change", this.$onDocumentChange);
		            this.session.off("changeMode", this.$onChangeMode);
		            this.session.off("tokenizerUpdate", this.$onTokenizerUpdate);
		            this.session.off("changeTabSize", this.$onChangeTabSize);
		            this.session.off("changeWrapLimit", this.$onChangeWrapLimit);
		            this.session.off("changeWrapMode", this.$onChangeWrapMode);
		            this.session.off("changeFold", this.$onChangeFold);
		            this.session.off("changeFrontMarker", this.$onChangeFrontMarker);
		            this.session.off("changeBackMarker", this.$onChangeBackMarker);
		            this.session.off("changeBreakpoint", this.$onChangeBreakpoint);
		            this.session.off("changeAnnotation", this.$onChangeAnnotation);
		            this.session.off("changeOverwrite", this.$onCursorChange);
		            this.session.off("changeScrollTop", this.$onScrollTopChange);
		            this.session.off("changeScrollLeft", this.$onScrollLeftChange);
		
		            var selection = this.session.getSelection();
		            selection.off("changeCursor", this.$onCursorChange);
		            selection.off("changeSelection", this.$onSelectionChange);
		        }
		
		        this.session = session;
		        if (session) {
		            this.$onDocumentChange = this.onDocumentChange.bind(this);
		            session.on("change", this.$onDocumentChange);
		            this.renderer.setSession(session);
		    
		            this.$onChangeMode = this.onChangeMode.bind(this);
		            session.on("changeMode", this.$onChangeMode);
		    
		            this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
		            session.on("tokenizerUpdate", this.$onTokenizerUpdate);
		    
		            this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
		            session.on("changeTabSize", this.$onChangeTabSize);
		    
		            this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
		            session.on("changeWrapLimit", this.$onChangeWrapLimit);
		    
		            this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
		            session.on("changeWrapMode", this.$onChangeWrapMode);
		    
		            this.$onChangeFold = this.onChangeFold.bind(this);
		            session.on("changeFold", this.$onChangeFold);
		    
		            this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
		            this.session.on("changeFrontMarker", this.$onChangeFrontMarker);
		    
		            this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
		            this.session.on("changeBackMarker", this.$onChangeBackMarker);
		    
		            this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
		            this.session.on("changeBreakpoint", this.$onChangeBreakpoint);
		    
		            this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
		            this.session.on("changeAnnotation", this.$onChangeAnnotation);
		    
		            this.$onCursorChange = this.onCursorChange.bind(this);
		            this.session.on("changeOverwrite", this.$onCursorChange);
		    
		            this.$onScrollTopChange = this.onScrollTopChange.bind(this);
		            this.session.on("changeScrollTop", this.$onScrollTopChange);
		    
		            this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
		            this.session.on("changeScrollLeft", this.$onScrollLeftChange);
		    
		            this.selection = session.getSelection();
		            this.selection.on("changeCursor", this.$onCursorChange);
		    
		            this.$onSelectionChange = this.onSelectionChange.bind(this);
		            this.selection.on("changeSelection", this.$onSelectionChange);
		    
		            this.onChangeMode();
		    
		            this.onCursorChange();
		    
		            this.onScrollTopChange();
		            this.onScrollLeftChange();
		            this.onSelectionChange();
		            this.onChangeFrontMarker();
		            this.onChangeBackMarker();
		            this.onChangeBreakpoint();
		            this.onChangeAnnotation();
		            this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();
		            this.renderer.updateFull();
		        } else {
		            this.selection = null;
		            this.renderer.setSession(session);
		        }
		
		        this._signal("changeSession", {
		            session: session,
		            oldSession: oldSession
		        });
		        
		        this.curOp = null;
		        
		        oldSession && oldSession._signal("changeEditor", {oldEditor: this});
		        session && session._signal("changeEditor", {editor: this});
		        
		        if (session && session.bgTokenizer)
		            session.bgTokenizer.scheduleStart();
		    };
		
		    /**
		     * Returns the current session being used.
		     * @returns {EditSession}
		     **/
		    this.getSession = function() {
		        return this.session;
		    };
		
		    /**
		     * Sets the current document to `val`.
		     * @param {String} val The new value to set for the document
		     * @param {Number} cursorPos Where to set the new value. `undefined` or 0 is selectAll, -1 is at the document start, and 1 is at the end
		     *
		     * @returns {String} The current document value
		     * @related Document.setValue
		     **/
		    this.setValue = function(val, cursorPos) {
		        this.session.doc.setValue(val);
		
		        if (!cursorPos)
		            this.selectAll();
		        else if (cursorPos == 1)
		            this.navigateFileEnd();
		        else if (cursorPos == -1)
		            this.navigateFileStart();
		
		        return val;
		    };
		
		    /**
		     * Returns the current session's content.
		     *
		     * @returns {String}
		     * @related EditSession.getValue
		     **/
		    this.getValue = function() {
		        return this.session.getValue();
		    };
		
		    /**
		     *
		     * Returns the currently highlighted selection.
		     * @returns {Selection} The selection object
		     **/
		    this.getSelection = function() {
		        return this.selection;
		    };
		
		    /**
		     * {:VirtualRenderer.onResize}
		     * @param {Boolean} force If `true`, recomputes the size, even if the height and width haven't changed
		     *
		     *
		     * @related VirtualRenderer.onResize
		     **/
		    this.resize = function(force) {
		        this.renderer.onResize(force);
		    };
		
		    /**
		     * {:VirtualRenderer.setTheme}
		     * @param {String} theme The path to a theme
		     * @param {Function} cb optional callback called when theme is loaded
		     **/
		    this.setTheme = function(theme, cb) {
		        this.renderer.setTheme(theme, cb);
		    };
		
		    /**
		     * {:VirtualRenderer.getTheme}
		     *
		     * @returns {String} The set theme
		     * @related VirtualRenderer.getTheme
		     **/
		    this.getTheme = function() {
		        return this.renderer.getTheme();
		    };
		
		    /**
		     * {:VirtualRenderer.setStyle}
		     * @param {String} style A class name
		     *
		     *
		     * @related VirtualRenderer.setStyle
		     **/
		    this.setStyle = function(style) {
		        this.renderer.setStyle(style);
		    };
		
		    /**
		     * {:VirtualRenderer.unsetStyle}
		     * @related VirtualRenderer.unsetStyle
		     **/
		    this.unsetStyle = function(style) {
		        this.renderer.unsetStyle(style);
		    };
		
		    /**
		     * Gets the current font size of the editor text.
		     */
		    this.getFontSize = function () {
		        return this.getOption("fontSize") ||
		           dom.computedStyle(this.container, "fontSize");
		    };
		
		    /**
		     * Set a new font size (in pixels) for the editor text.
		     * @param {String} size A font size ( _e.g._ "12px")
		     *
		     *
		     **/
		    this.setFontSize = function(size) {
		        this.setOption("fontSize", size);
		    };
		
		    this.$highlightBrackets = function() {
		        if (this.session.$bracketHighlight) {
		            this.session.removeMarker(this.session.$bracketHighlight);
		            this.session.$bracketHighlight = null;
		        }
		
		        if (this.$highlightPending) {
		            return;
		        }
		
		        // perform highlight async to not block the browser during navigation
		        var self = this;
		        this.$highlightPending = true;
		        setTimeout(function() {
		            self.$highlightPending = false;
		            var session = self.session;
		            if (!session || !session.bgTokenizer) return;
		            var pos = session.findMatchingBracket(self.getCursorPosition());
		            if (pos) {
		                var range = new Range(pos.row, pos.column, pos.row, pos.column + 1);
		            } else if (session.$mode.getMatching) {
		                var range = session.$mode.getMatching(self.session);
		            }
		            if (range)
		                session.$bracketHighlight = session.addMarker(range, "ace_bracket", "text");
		        }, 50);
		    };
		
		    // todo: move to mode.getMatching
		    this.$highlightTags = function() {
		        if (this.$highlightTagPending)
		            return;
		
		        // perform highlight async to not block the browser during navigation
		        var self = this;
		        this.$highlightTagPending = true;
		        setTimeout(function() {
		            self.$highlightTagPending = false;
		            
		            var session = self.session;
		            if (!session || !session.bgTokenizer) return;
		            
		            var pos = self.getCursorPosition();
		            var iterator = new TokenIterator(self.session, pos.row, pos.column);
		            var token = iterator.getCurrentToken();
		            
		            if (!token || !/\b(?:tag-open|tag-name)/.test(token.type)) {
		                session.removeMarker(session.$tagHighlight);
		                session.$tagHighlight = null;
		                return;
		            }
		            
		            if (token.type.indexOf("tag-open") != -1) {
		                token = iterator.stepForward();
		                if (!token)
		                    return;
		            }
		            
		            var tag = token.value;
		            var depth = 0;
		            var prevToken = iterator.stepBackward();
		            
		            if (prevToken.value == '<'){
		                //find closing tag
		                do {
		                    prevToken = token;
		                    token = iterator.stepForward();
		                    
		                    if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
		                        if (prevToken.value === '<'){
		                            depth++;
		                        } else if (prevToken.value === '</'){
		                            depth--;
		                        }
		                    }
		                    
		                } while (token && depth >= 0);
		            } else {
		                //find opening tag
		                do {
		                    token = prevToken;
		                    prevToken = iterator.stepBackward();
		                    
		                    if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
		                        if (prevToken.value === '<') {
		                            depth++;
		                        } else if (prevToken.value === '</') {
		                            depth--;
		                        }
		                    }
		                } while (prevToken && depth <= 0);
		                
		                //select tag again
		                iterator.stepForward();
		            }
		            
		            if (!token) {
		                session.removeMarker(session.$tagHighlight);
		                session.$tagHighlight = null;
		                return;
		            }
		            
		            var row = iterator.getCurrentTokenRow();
		            var column = iterator.getCurrentTokenColumn();
		            var range = new Range(row, column, row, column+token.value.length);
		            
		            //remove range if different
		            var sbm = session.$backMarkers[session.$tagHighlight];
		            if (session.$tagHighlight && sbm != undefined && range.compareRange(sbm.range) !== 0) {
		                session.removeMarker(session.$tagHighlight);
		                session.$tagHighlight = null;
		            }
		            
		            if (!session.$tagHighlight)
		                session.$tagHighlight = session.addMarker(range, "ace_bracket", "text");
		        }, 50);
		    };
		
		    /**
		     *
		     * Brings the current `textInput` into focus.
		     **/
		    this.focus = function() {
		        // Safari needs the timeout
		        // iOS and Firefox need it called immediately
		        // to be on the save side we do both
		        var _self = this;
		        setTimeout(function() {
		            _self.textInput.focus();
		        });
		        this.textInput.focus();
		    };
		
		    /**
		     * Returns `true` if the current `textInput` is in focus.
		     * @return {Boolean}
		     **/
		    this.isFocused = function() {
		        return this.textInput.isFocused();
		    };
		
		    /**
		     *
		     * Blurs the current `textInput`.
		     **/
		    this.blur = function() {
		        this.textInput.blur();
		    };
		
		    /**
		     * Emitted once the editor comes into focus.
		     * @event focus
		     *
		     *
		     **/
		    this.onFocus = function(e) {
		        if (this.$isFocused)
		            return;
		        this.$isFocused = true;
		        this.renderer.showCursor();
		        this.renderer.visualizeFocus();
		        this._emit("focus", e);
		    };
		
		    /**
		     * Emitted once the editor has been blurred.
		     * @event blur
		     *
		     *
		     **/
		    this.onBlur = function(e) {
		        if (!this.$isFocused)
		            return;
		        this.$isFocused = false;
		        this.renderer.hideCursor();
		        this.renderer.visualizeBlur();
		        this._emit("blur", e);
		    };
		
		    this.$cursorChange = function() {
		        this.renderer.updateCursor();
		    };
		
		    /**
		     * Emitted whenever the document is changed.
		     * @event change
		     * @param {Object} e Contains a single property, `data`, which has the delta of changes
		     *
		     *
		     *
		     **/
		    this.onDocumentChange = function(delta) {
		        // Rerender and emit "change" event.
		        var wrap = this.session.$useWrapMode;
		        var lastRow = (delta.start.row == delta.end.row ? delta.end.row : Infinity);
		        this.renderer.updateLines(delta.start.row, lastRow, wrap);
		
		        this._signal("change", delta);
		        
		        // Update cursor because tab characters can influence the cursor position.
		        this.$cursorChange();
		        this.$updateHighlightActiveLine();
		    };
		
		    this.onTokenizerUpdate = function(e) {
		        var rows = e.data;
		        this.renderer.updateLines(rows.first, rows.last);
		    };
		
		
		    this.onScrollTopChange = function() {
		        this.renderer.scrollToY(this.session.getScrollTop());
		    };
		
		    this.onScrollLeftChange = function() {
		        this.renderer.scrollToX(this.session.getScrollLeft());
		    };
		
		    /**
		     * Emitted when the selection changes.
		     *
		     **/
		    this.onCursorChange = function() {
		        this.$cursorChange();
		
		        this.$highlightBrackets();
		        this.$highlightTags();
		        this.$updateHighlightActiveLine();
		        this._signal("changeSelection");
		    };
		
		    this.$updateHighlightActiveLine = function() {
		        var session = this.getSession();
		
		        var highlight;
		        if (this.$highlightActiveLine) {
		            if ((this.$selectionStyle != "line" || !this.selection.isMultiLine()))
		                highlight = this.getCursorPosition();
		            if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1))
		                highlight = false;
		        }
		
		        if (session.$highlightLineMarker && !highlight) {
		            session.removeMarker(session.$highlightLineMarker.id);
		            session.$highlightLineMarker = null;
		        } else if (!session.$highlightLineMarker && highlight) {
		            var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
		            range.id = session.addMarker(range, "ace_active-line", "screenLine");
		            session.$highlightLineMarker = range;
		        } else if (highlight) {
		            session.$highlightLineMarker.start.row = highlight.row;
		            session.$highlightLineMarker.end.row = highlight.row;
		            session.$highlightLineMarker.start.column = highlight.column;
		            session._signal("changeBackMarker");
		        }
		    };
		
		    this.onSelectionChange = function(e) {
		        var session = this.session;
		
		        if (session.$selectionMarker) {
		            session.removeMarker(session.$selectionMarker);
		        }
		        session.$selectionMarker = null;
		
		        if (!this.selection.isEmpty()) {
		            var range = this.selection.getRange();
		            var style = this.getSelectionStyle();
		            session.$selectionMarker = session.addMarker(range, "ace_selection", style);
		        } else {
		            this.$updateHighlightActiveLine();
		        }
		
		        var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
		        this.session.highlight(re);
		
		        this._signal("changeSelection");
		    };
		
		    this.$getSelectionHighLightRegexp = function() {
		        var session = this.session;
		
		        var selection = this.getSelectionRange();
		        if (selection.isEmpty() || selection.isMultiLine())
		            return;
		
		        var startColumn = selection.start.column;
		        var endColumn = selection.end.column;
		        var line = session.getLine(selection.start.row);
		        
		        var needle = line.substring(startColumn, endColumn);
		        if (!/[\w\d]/.test(needle))
		            return;
		
		        var re = this.$search.$assembleRegExp({
		            wholeWord: true,
		            caseSensitive: true,
		            needle: needle
		        });
		        
		        var wordWithBoundary = line.substring(startColumn - 1, endColumn + 1);
		        if (!re.test(wordWithBoundary))
		            return;
		        
		        return re;
		    };
		
		
		    this.onChangeFrontMarker = function() {
		        this.renderer.updateFrontMarkers();
		    };
		
		    this.onChangeBackMarker = function() {
		        this.renderer.updateBackMarkers();
		    };
		
		
		    this.onChangeBreakpoint = function() {
		        this.renderer.updateBreakpoints();
		    };
		
		    this.onChangeAnnotation = function() {
		        this.renderer.setAnnotations(this.session.getAnnotations());
		    };
		
		
		    this.onChangeMode = function(e) {
		        this.renderer.updateText();
		        this._emit("changeMode", e);
		    };
		
		
		    this.onChangeWrapLimit = function() {
		        this.renderer.updateFull();
		    };
		
		    this.onChangeWrapMode = function() {
		        this.renderer.onResize(true);
		    };
		
		
		    this.onChangeFold = function() {
		        // Update the active line marker as due to folding changes the current
		        // line range on the screen might have changed.
		        this.$updateHighlightActiveLine();
		        // TODO: This might be too much updating. Okay for now.
		        this.renderer.updateFull();
		    };
		
		    
		    /**
		     * Returns the string of text currently highlighted.
		     * @returns {String}
		     **/
		    this.getSelectedText = function() {
		        return this.session.getTextRange(this.getSelectionRange());
		    };
		    
		    /**
		     * Emitted when text is copied.
		     * @event copy
		     * @param {String} text The copied text
		     *
		     **/
		    /**
		     * Returns the string of text currently highlighted.
		     * @returns {String}
		     **/
		    this.getCopyText = function() {
		        var text = this.getSelectedText();
		        var nl = this.session.doc.getNewLineCharacter();
		        var copyLine= false;
		        if (!text && this.$copyWithEmptySelection) {
		            copyLine = true;
		            var ranges = this.selection.getAllRanges();
		            for (var i = 0; i < ranges.length; i++) {
		                var range = ranges[i];
		                if (i && ranges[i - 1].start.row == range.start.row)
		                    continue;
		                text += this.session.getLine(range.start.row) + nl;
		            }
		        }
		        var e = {text: text};
		        this._signal("copy", e);
		        clipboard.lineMode = copyLine ? e.text : "";
		        return e.text;
		    };
		
		    /**
		     * Called whenever a text "copy" happens.
		     **/
		    this.onCopy = function() {
		        this.commands.exec("copy", this);
		    };
		
		    /**
		     * Called whenever a text "cut" happens.
		     **/
		    this.onCut = function() {
		        this.commands.exec("cut", this);
		    };
		
		    /**
		     * Emitted when text is pasted.
		     * @event paste
		     * @param {Object} an object which contains one property, `text`, that represents the text to be pasted. Editing this property will alter the text that is pasted.
		     *
		     *
		     **/
		    /**
		     * Called whenever a text "paste" happens.
		     * @param {String} text The pasted text
		     *
		     *
		     **/
		    this.onPaste = function(text, event) {
		        var e = {text: text, event: event};
		        this.commands.exec("paste", this, e);
		    };
		    
		    this.$handlePaste = function(e) {
		        if (typeof e == "string") 
		            e = {text: e};
		        this._signal("paste", e);
		        var text = e.text;
		
		        var lineMode = text == clipboard.lineMode;
		        var session = this.session;
		        if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {
		            if (lineMode)
		                session.insert({ row: this.selection.lead.row, column: 0 }, text);
		            else
		                this.insert(text);
		        } else if (lineMode) {
		            this.selection.rangeList.ranges.forEach(function(range) {
		                session.insert({ row: range.start.row, column: 0 }, text);
		            });
		        } else {
		            var lines = text.split(/\r\n|\r|\n/);
		            var ranges = this.selection.rangeList.ranges;
		    
		            if (lines.length > ranges.length || lines.length < 2 || !lines[1])
		                return this.commands.exec("insertstring", this, text);
		    
		            for (var i = ranges.length; i--;) {
		                var range = ranges[i];
		                if (!range.isEmpty())
		                    session.remove(range);
		    
		                session.insert(range.start, lines[i]);
		            }
		        }
		    };
		
		    this.execCommand = function(command, args) {
		        return this.commands.exec(command, this, args);
		    };
		
		    /**
		     * Inserts `text` into wherever the cursor is pointing.
		     * @param {String} text The new text to add
		     *
		     **/
		    this.insert = function(text, pasted) {
		        var session = this.session;
		        var mode = session.getMode();
		        var cursor = this.getCursorPosition();
		
		        if (this.getBehavioursEnabled() && !pasted) {
		            // Get a transform if the current mode wants one.
		            var transform = mode.transformAction(session.getState(cursor.row), 'insertion', this, session, text);
		            if (transform) {
		                if (text !== transform.text) {
		                    // keep automatic insertion in a separate delta, unless it is in multiselect mode
		                    if (!this.inVirtualSelectionMode) {
		                        this.session.mergeUndoDeltas = false;
		                        this.mergeNextCommand = false;
		                    }
		                }
		                text = transform.text;
		
		            }
		        }
		        
		        if (text == "\t")
		            text = this.session.getTabString();
		
		        // remove selected text
		        if (!this.selection.isEmpty()) {
		            var range = this.getSelectionRange();
		            cursor = this.session.remove(range);
		            this.clearSelection();
		        }
		        else if (this.session.getOverwrite() && text.indexOf("\n") == -1) {
		            var range = new Range.fromPoints(cursor, cursor);
		            range.end.column += text.length;
		            this.session.remove(range);
		        }
		
		        if (text == "\n" || text == "\r\n") {
		            var line = session.getLine(cursor.row);
		            if (cursor.column > line.search(/\S|$/)) {
		                var d = line.substr(cursor.column).search(/\S|$/);
		                session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);
		            }
		        }
		        this.clearSelection();
		
		        var start = cursor.column;
		        var lineState = session.getState(cursor.row);
		        var line = session.getLine(cursor.row);
		        var shouldOutdent = mode.checkOutdent(lineState, line, text);
		        var end = session.insert(cursor, text);
		
		        if (transform && transform.selection) {
		            if (transform.selection.length == 2) { // Transform relative to the current column
		                this.selection.setSelectionRange(
		                    new Range(cursor.row, start + transform.selection[0],
		                              cursor.row, start + transform.selection[1]));
		            } else { // Transform relative to the current row.
		                this.selection.setSelectionRange(
		                    new Range(cursor.row + transform.selection[0],
		                              transform.selection[1],
		                              cursor.row + transform.selection[2],
		                              transform.selection[3]));
		            }
		        }
		
		        if (session.getDocument().isNewLine(text)) {
		            var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());
		
		            session.insert({row: cursor.row+1, column: 0}, lineIndent);
		        }
		        if (shouldOutdent)
		            mode.autoOutdent(lineState, session, cursor.row);
		    };
		
		    this.onTextInput = function(text) {
		        this.keyBinding.onTextInput(text);
		    };
		
		    this.onCommandKey = function(e, hashId, keyCode) {
		        this.keyBinding.onCommandKey(e, hashId, keyCode);
		    };
		
		    /**
		     * Pass in `true` to enable overwrites in your session, or `false` to disable. If overwrites is enabled, any text you enter will type over any text after it. If the value of `overwrite` changes, this function also emits the `changeOverwrite` event.
		     * @param {Boolean} overwrite Defines whether or not to set overwrites
		     *
		     *
		     * @related EditSession.setOverwrite
		     **/
		    this.setOverwrite = function(overwrite) {
		        this.session.setOverwrite(overwrite);
		    };
		
		    /**
		     * Returns `true` if overwrites are enabled; `false` otherwise.
		     * @returns {Boolean}
		     * @related EditSession.getOverwrite
		     **/
		    this.getOverwrite = function() {
		        return this.session.getOverwrite();
		    };
		
		    /**
		     * Sets the value of overwrite to the opposite of whatever it currently is.
		     * @related EditSession.toggleOverwrite
		     **/
		    this.toggleOverwrite = function() {
		        this.session.toggleOverwrite();
		    };
		
		    /**
		     * Sets how fast the mouse scrolling should do.
		     * @param {Number} speed A value indicating the new speed (in milliseconds)
		     **/
		    this.setScrollSpeed = function(speed) {
		        this.setOption("scrollSpeed", speed);
		    };
		
		    /**
		     * Returns the value indicating how fast the mouse scroll speed is (in milliseconds).
		     * @returns {Number}
		     **/
		    this.getScrollSpeed = function() {
		        return this.getOption("scrollSpeed");
		    };
		
		    /**
		     * Sets the delay (in milliseconds) of the mouse drag.
		     * @param {Number} dragDelay A value indicating the new delay
		     **/
		    this.setDragDelay = function(dragDelay) {
		        this.setOption("dragDelay", dragDelay);
		    };
		
		    /**
		     * Returns the current mouse drag delay.
		     * @returns {Number}
		     **/
		    this.getDragDelay = function() {
		        return this.getOption("dragDelay");
		    };
		
		    /**
		     * Emitted when the selection style changes, via [[Editor.setSelectionStyle]].
		     * @event changeSelectionStyle
		     * @param {Object} data Contains one property, `data`, which indicates the new selection style
		     **/
		    /**
		     * Draw selection markers spanning whole line, or only over selected text. Default value is "line"
		     * @param {String} style The new selection style "line"|"text"
		     *
		     **/
		    this.setSelectionStyle = function(val) {
		        this.setOption("selectionStyle", val);
		    };
		
		    /**
		     * Returns the current selection style.
		     * @returns {String}
		     **/
		    this.getSelectionStyle = function() {
		        return this.getOption("selectionStyle");
		    };
		
		    /**
		     * Determines whether or not the current line should be highlighted.
		     * @param {Boolean} shouldHighlight Set to `true` to highlight the current line
		     **/
		    this.setHighlightActiveLine = function(shouldHighlight) {
		        this.setOption("highlightActiveLine", shouldHighlight);
		    };
		    /**
		     * Returns `true` if current lines are always highlighted.
		     * @return {Boolean}
		     **/
		    this.getHighlightActiveLine = function() {
		        return this.getOption("highlightActiveLine");
		    };
		    this.setHighlightGutterLine = function(shouldHighlight) {
		        this.setOption("highlightGutterLine", shouldHighlight);
		    };
		
		    this.getHighlightGutterLine = function() {
		        return this.getOption("highlightGutterLine");
		    };
		
		    /**
		     * Determines if the currently selected word should be highlighted.
		     * @param {Boolean} shouldHighlight Set to `true` to highlight the currently selected word
		     *
		     **/
		    this.setHighlightSelectedWord = function(shouldHighlight) {
		        this.setOption("highlightSelectedWord", shouldHighlight);
		    };
		
		    /**
		     * Returns `true` if currently highlighted words are to be highlighted.
		     * @returns {Boolean}
		     **/
		    this.getHighlightSelectedWord = function() {
		        return this.$highlightSelectedWord;
		    };
		
		    this.setAnimatedScroll = function(shouldAnimate){
		        this.renderer.setAnimatedScroll(shouldAnimate);
		    };
		
		    this.getAnimatedScroll = function(){
		        return this.renderer.getAnimatedScroll();
		    };
		
		    /**
		     * If `showInvisibles` is set to `true`, invisible characters&mdash;like spaces or new lines&mdash;are show in the editor.
		     * @param {Boolean} showInvisibles Specifies whether or not to show invisible characters
		     *
		     **/
		    this.setShowInvisibles = function(showInvisibles) {
		        this.renderer.setShowInvisibles(showInvisibles);
		    };
		
		    /**
		     * Returns `true` if invisible characters are being shown.
		     * @returns {Boolean}
		     **/
		    this.getShowInvisibles = function() {
		        return this.renderer.getShowInvisibles();
		    };
		
		    this.setDisplayIndentGuides = function(display) {
		        this.renderer.setDisplayIndentGuides(display);
		    };
		
		    this.getDisplayIndentGuides = function() {
		        return this.renderer.getDisplayIndentGuides();
		    };
		
		    /**
		     * If `showPrintMargin` is set to `true`, the print margin is shown in the editor.
		     * @param {Boolean} showPrintMargin Specifies whether or not to show the print margin
		     *
		     **/
		    this.setShowPrintMargin = function(showPrintMargin) {
		        this.renderer.setShowPrintMargin(showPrintMargin);
		    };
		
		    /**
		     * Returns `true` if the print margin is being shown.
		     * @returns {Boolean}
		     **/
		    this.getShowPrintMargin = function() {
		        return this.renderer.getShowPrintMargin();
		    };
		
		    /**
		     * Sets the column defining where the print margin should be.
		     * @param {Number} showPrintMargin Specifies the new print margin
		     *
		     **/
		    this.setPrintMarginColumn = function(showPrintMargin) {
		        this.renderer.setPrintMarginColumn(showPrintMargin);
		    };
		
		    /**
		     * Returns the column number of where the print margin is.
		     * @returns {Number}
		     **/
		    this.getPrintMarginColumn = function() {
		        return this.renderer.getPrintMarginColumn();
		    };
		
		    /**
		     * If `readOnly` is true, then the editor is set to read-only mode, and none of the content can change.
		     * @param {Boolean} readOnly Specifies whether the editor can be modified or not
		     *
		     **/
		    this.setReadOnly = function(readOnly) {
		        this.setOption("readOnly", readOnly);
		    };
		
		    /**
		     * Returns `true` if the editor is set to read-only mode.
		     * @returns {Boolean}
		     **/
		    this.getReadOnly = function() {
		        return this.getOption("readOnly");
		    };
		
		    /**
		     * Specifies whether to use behaviors or not. ["Behaviors" in this case is the auto-pairing of special characters, like quotation marks, parenthesis, or brackets.]{: #BehaviorsDef}
		     * @param {Boolean} enabled Enables or disables behaviors
		     *
		     **/
		    this.setBehavioursEnabled = function (enabled) {
		        this.setOption("behavioursEnabled", enabled);
		    };
		
		    /**
		     * Returns `true` if the behaviors are currently enabled. {:BehaviorsDef}
		     *
		     * @returns {Boolean}
		     **/
		    this.getBehavioursEnabled = function () {
		        return this.getOption("behavioursEnabled");
		    };
		
		    /**
		     * Specifies whether to use wrapping behaviors or not, i.e. automatically wrapping the selection with characters such as brackets
		     * when such a character is typed in.
		     * @param {Boolean} enabled Enables or disables wrapping behaviors
		     *
		     **/
		    this.setWrapBehavioursEnabled = function (enabled) {
		        this.setOption("wrapBehavioursEnabled", enabled);
		    };
		
		    /**
		     * Returns `true` if the wrapping behaviors are currently enabled.
		     **/
		    this.getWrapBehavioursEnabled = function () {
		        return this.getOption("wrapBehavioursEnabled");
		    };
		
		    /**
		     * Indicates whether the fold widgets should be shown or not.
		     * @param {Boolean} show Specifies whether the fold widgets are shown
		     **/
		    this.setShowFoldWidgets = function(show) {
		        this.setOption("showFoldWidgets", show);
		
		    };
		    /**
		     * Returns `true` if the fold widgets are shown.
		     * @return {Boolean}
		     **/
		    this.getShowFoldWidgets = function() {
		        return this.getOption("showFoldWidgets");
		    };
		
		    this.setFadeFoldWidgets = function(fade) {
		        this.setOption("fadeFoldWidgets", fade);
		    };
		
		    this.getFadeFoldWidgets = function() {
		        return this.getOption("fadeFoldWidgets");
		    };
		
		    /**
		     * Removes the current selection or one character.
		     * @param {String} dir The direction of the deletion to occur, either "left" or "right"
		     *
		     **/
		    this.remove = function(dir) {
		        if (this.selection.isEmpty()){
		            if (dir == "left")
		                this.selection.selectLeft();
		            else
		                this.selection.selectRight();
		        }
		
		        var range = this.getSelectionRange();
		        if (this.getBehavioursEnabled()) {
		            var session = this.session;
		            var state = session.getState(range.start.row);
		            var new_range = session.getMode().transformAction(state, 'deletion', this, session, range);
		
		            if (range.end.column === 0) {
		                var text = session.getTextRange(range);
		                if (text[text.length - 1] == "\n") {
		                    var line = session.getLine(range.end.row);
		                    if (/^\s+$/.test(line)) {
		                        range.end.column = line.length;
		                    }
		                }
		            }
		            if (new_range)
		                range = new_range;
		        }
		
		        this.session.remove(range);
		        this.clearSelection();
		    };
		
		    /**
		     * Removes the word directly to the right of the current selection.
		     **/
		    this.removeWordRight = function() {
		        if (this.selection.isEmpty())
		            this.selection.selectWordRight();
		
		        this.session.remove(this.getSelectionRange());
		        this.clearSelection();
		    };
		
		    /**
		     * Removes the word directly to the left of the current selection.
		     **/
		    this.removeWordLeft = function() {
		        if (this.selection.isEmpty())
		            this.selection.selectWordLeft();
		
		        this.session.remove(this.getSelectionRange());
		        this.clearSelection();
		    };
		
		    /**
		     * Removes all the words to the left of the current selection, until the start of the line.
		     **/
		    this.removeToLineStart = function() {
		        if (this.selection.isEmpty())
		            this.selection.selectLineStart();
		
		        this.session.remove(this.getSelectionRange());
		        this.clearSelection();
		    };
		
		    /**
		     * Removes all the words to the right of the current selection, until the end of the line.
		     **/
		    this.removeToLineEnd = function() {
		        if (this.selection.isEmpty())
		            this.selection.selectLineEnd();
		
		        var range = this.getSelectionRange();
		        if (range.start.column == range.end.column && range.start.row == range.end.row) {
		            range.end.column = 0;
		            range.end.row++;
		        }
		
		        this.session.remove(range);
		        this.clearSelection();
		    };
		
		    /**
		     * Splits the line at the current selection (by inserting an `'\n'`).
		     **/
		    this.splitLine = function() {
		        if (!this.selection.isEmpty()) {
		            this.session.remove(this.getSelectionRange());
		            this.clearSelection();
		        }
		
		        var cursor = this.getCursorPosition();
		        this.insert("\n");
		        this.moveCursorToPosition(cursor);
		    };
		
		    /**
		     * Transposes current line.
		     **/
		    this.transposeLetters = function() {
		        if (!this.selection.isEmpty()) {
		            return;
		        }
		
		        var cursor = this.getCursorPosition();
		        var column = cursor.column;
		        if (column === 0)
		            return;
		
		        var line = this.session.getLine(cursor.row);
		        var swap, range;
		        if (column < line.length) {
		            swap = line.charAt(column) + line.charAt(column-1);
		            range = new Range(cursor.row, column-1, cursor.row, column+1);
		        }
		        else {
		            swap = line.charAt(column-1) + line.charAt(column-2);
		            range = new Range(cursor.row, column-2, cursor.row, column);
		        }
		        this.session.replace(range, swap);
		        this.session.selection.moveToPosition(range.end);
		    };
		
		    /**
		     * Converts the current selection entirely into lowercase.
		     **/
		    this.toLowerCase = function() {
		        var originalRange = this.getSelectionRange();
		        if (this.selection.isEmpty()) {
		            this.selection.selectWord();
		        }
		
		        var range = this.getSelectionRange();
		        var text = this.session.getTextRange(range);
		        this.session.replace(range, text.toLowerCase());
		        this.selection.setSelectionRange(originalRange);
		    };
		
		    /**
		     * Converts the current selection entirely into uppercase.
		     **/
		    this.toUpperCase = function() {
		        var originalRange = this.getSelectionRange();
		        if (this.selection.isEmpty()) {
		            this.selection.selectWord();
		        }
		
		        var range = this.getSelectionRange();
		        var text = this.session.getTextRange(range);
		        this.session.replace(range, text.toUpperCase());
		        this.selection.setSelectionRange(originalRange);
		    };
		
		    /**
		     * Inserts an indentation into the current cursor position or indents the selected lines.
		     *
		     * @related EditSession.indentRows
		     **/
		    this.indent = function() {
		        var session = this.session;
		        var range = this.getSelectionRange();
		
		        if (range.start.row < range.end.row) {
		            var rows = this.$getSelectedRows();
		            session.indentRows(rows.first, rows.last, "\t");
		            return;
		        } else if (range.start.column < range.end.column) {
		            var text = session.getTextRange(range);
		            if (!/^\s+$/.test(text)) {
		                var rows = this.$getSelectedRows();
		                session.indentRows(rows.first, rows.last, "\t");
		                return;
		            }
		        }
		        
		        var line = session.getLine(range.start.row);
		        var position = range.start;
		        var size = session.getTabSize();
		        var column = session.documentToScreenColumn(position.row, position.column);
		
		        if (this.session.getUseSoftTabs()) {
		            var count = (size - column % size);
		            var indentString = lang.stringRepeat(" ", count);
		        } else {
		            var count = column % size;
		            while (line[range.start.column - 1] == " " && count) {
		                range.start.column--;
		                count--;
		            }
		            this.selection.setSelectionRange(range);
		            indentString = "\t";
		        }
		        return this.insert(indentString);
		    };
		
		    /**
		     * Indents the current line.
		     * @related EditSession.indentRows
		     **/
		    this.blockIndent = function() {
		        var rows = this.$getSelectedRows();
		        this.session.indentRows(rows.first, rows.last, "\t");
		    };
		
		    /**
		     * Outdents the current line.
		     * @related EditSession.outdentRows
		     **/
		    this.blockOutdent = function() {
		        var selection = this.session.getSelection();
		        this.session.outdentRows(selection.getRange());
		    };
		
		    // TODO: move out of core when we have good mechanism for managing extensions
		    this.sortLines = function() {
		        var rows = this.$getSelectedRows();
		        var session = this.session;
		
		        var lines = [];
		        for (var i = rows.first; i <= rows.last; i++)
		            lines.push(session.getLine(i));
		
		        lines.sort(function(a, b) {
		            if (a.toLowerCase() < b.toLowerCase()) return -1;
		            if (a.toLowerCase() > b.toLowerCase()) return 1;
		            return 0;
		        });
		
		        var deleteRange = new Range(0, 0, 0, 0);
		        for (var i = rows.first; i <= rows.last; i++) {
		            var line = session.getLine(i);
		            deleteRange.start.row = i;
		            deleteRange.end.row = i;
		            deleteRange.end.column = line.length;
		            session.replace(deleteRange, lines[i-rows.first]);
		        }
		    };
		
		    /**
		     * Given the currently selected range, this function either comments all the lines, or uncomments all of them.
		     **/
		    this.toggleCommentLines = function() {
		        var state = this.session.getState(this.getCursorPosition().row);
		        var rows = this.$getSelectedRows();
		        this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
		    };
		
		    this.toggleBlockComment = function() {
		        var cursor = this.getCursorPosition();
		        var state = this.session.getState(cursor.row);
		        var range = this.getSelectionRange();
		        this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
		    };
		
		    /**
		     * Works like [[EditSession.getTokenAt]], except it returns a number.
		     * @returns {Number}
		     **/
		    this.getNumberAt = function(row, column) {
		        var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
		        _numberRx.lastIndex = 0;
		
		        var s = this.session.getLine(row);
		        while (_numberRx.lastIndex < column) {
		            var m = _numberRx.exec(s);
		            if(m.index <= column && m.index+m[0].length >= column){
		                var number = {
		                    value: m[0],
		                    start: m.index,
		                    end: m.index+m[0].length
		                };
		                return number;
		            }
		        }
		        return null;
		    };
		
		    /**
		     * If the character before the cursor is a number, this functions changes its value by `amount`.
		     * @param {Number} amount The value to change the numeral by (can be negative to decrease value)
		     *
		     **/
		    this.modifyNumber = function(amount) {
		        var row = this.selection.getCursor().row;
		        var column = this.selection.getCursor().column;
		
		        // get the char before the cursor
		        var charRange = new Range(row, column-1, row, column);
		
		        var c = this.session.getTextRange(charRange);
		        // if the char is a digit
		        if (!isNaN(parseFloat(c)) && isFinite(c)) {
		            // get the whole number the digit is part of
		            var nr = this.getNumberAt(row, column);
		            // if number found
		            if (nr) {
		                var fp = nr.value.indexOf(".") >= 0 ? nr.start + nr.value.indexOf(".") + 1 : nr.end;
		                var decimals = nr.start + nr.value.length - fp;
		
		                var t = parseFloat(nr.value);
		                t *= Math.pow(10, decimals);
		
		
		                if(fp !== nr.end && column < fp){
		                    amount *= Math.pow(10, nr.end - column - 1);
		                } else {
		                    amount *= Math.pow(10, nr.end - column);
		                }
		
		                t += amount;
		                t /= Math.pow(10, decimals);
		                var nnr = t.toFixed(decimals);
		
		                //update number
		                var replaceRange = new Range(row, nr.start, row, nr.end);
		                this.session.replace(replaceRange, nnr);
		
		                //reposition the cursor
		                this.moveCursorTo(row, Math.max(nr.start +1, column + nnr.length - nr.value.length));
		
		            }
		        }
		    };
		
		    /**
		     * Removes all the lines in the current selection
		     * @related EditSession.remove
		     **/
		    this.removeLines = function() {
		        var rows = this.$getSelectedRows();
		        this.session.removeFullLines(rows.first, rows.last);
		        this.clearSelection();
		    };
		
		    this.duplicateSelection = function() {
		        var sel = this.selection;
		        var doc = this.session;
		        var range = sel.getRange();
		        var reverse = sel.isBackwards();
		        if (range.isEmpty()) {
		            var row = range.start.row;
		            doc.duplicateLines(row, row);
		        } else {
		            var point = reverse ? range.start : range.end;
		            var endPoint = doc.insert(point, doc.getTextRange(range), false);
		            range.start = point;
		            range.end = endPoint;
		
		            sel.setSelectionRange(range, reverse);
		        }
		    };
		
		    /**
		     * Shifts all the selected lines down one row.
		     *
		     * @returns {Number} On success, it returns -1.
		     * @related EditSession.moveLinesUp
		     **/
		    this.moveLinesDown = function() {
		        this.$moveLines(1, false);
		    };
		
		    /**
		     * Shifts all the selected lines up one row.
		     * @returns {Number} On success, it returns -1.
		     * @related EditSession.moveLinesDown
		     **/
		    this.moveLinesUp = function() {
		        this.$moveLines(-1, false);
		    };
		
		    /**
		     * Moves a range of text from the given range to the given position. `toPosition` is an object that looks like this:
		     * ```json
		     *    { row: newRowLocation, column: newColumnLocation }
		     * ```
		     * @param {Range} fromRange The range of text you want moved within the document
		     * @param {Object} toPosition The location (row and column) where you want to move the text to
		     *
		     * @returns {Range} The new range where the text was moved to.
		     * @related EditSession.moveText
		     **/
		    this.moveText = function(range, toPosition, copy) {
		        return this.session.moveText(range, toPosition, copy);
		    };
		
		    /**
		     * Copies all the selected lines up one row.
		     * @returns {Number} On success, returns 0.
		     *
		     **/
		    this.copyLinesUp = function() {
		        this.$moveLines(-1, true);
		    };
		
		    /**
		     * Copies all the selected lines down one row.
		     * @returns {Number} On success, returns the number of new rows added; in other words, `lastRow - firstRow + 1`.
		     * @related EditSession.duplicateLines
		     *
		     **/
		    this.copyLinesDown = function() {
		        this.$moveLines(1, true);
		    };
		
		    /**
		     * for internal use
		     * @ignore
		     *
		     **/
		    this.$moveLines = function(dir, copy) {
		        var rows, moved;
		        var selection = this.selection;
		        if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {
		            var range = selection.toOrientedRange();
		            rows = this.$getSelectedRows(range);
		            moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);
		            if (copy && dir == -1) moved = 0;
		            range.moveBy(moved, 0);
		            selection.fromOrientedRange(range);
		        } else {
		            var ranges = selection.rangeList.ranges;
		            selection.rangeList.detach(this.session);
		            this.inVirtualSelectionMode = true;
		            
		            var diff = 0;
		            var totalDiff = 0;
		            var l = ranges.length;
		            for (var i = 0; i < l; i++) {
		                var rangeIndex = i;
		                ranges[i].moveBy(diff, 0);
		                rows = this.$getSelectedRows(ranges[i]);
		                var first = rows.first;
		                var last = rows.last;
		                while (++i < l) {
		                    if (totalDiff) ranges[i].moveBy(totalDiff, 0);
		                    var subRows = this.$getSelectedRows(ranges[i]);
		                    if (copy && subRows.first != last)
		                        break;
		                    else if (!copy && subRows.first > last + 1)
		                        break;
		                    last = subRows.last;
		                }
		                i--;
		                diff = this.session.$moveLines(first, last, copy ? 0 : dir);
		                if (copy && dir == -1) rangeIndex = i + 1;
		                while (rangeIndex <= i) {
		                    ranges[rangeIndex].moveBy(diff, 0);
		                    rangeIndex++;
		                }
		                if (!copy) diff = 0;
		                totalDiff += diff;
		            }
		            
		            selection.fromOrientedRange(selection.ranges[0]);
		            selection.rangeList.attach(this.session);
		            this.inVirtualSelectionMode = false;
		        }
		    };
		
		    /**
		     * Returns an object indicating the currently selected rows. The object looks like this:
		     *
		     * ```json
		     * { first: range.start.row, last: range.end.row }
		     * ```
		     *
		     * @returns {Object}
		     **/
		    this.$getSelectedRows = function(range) {
		        range = (range || this.getSelectionRange()).collapseRows();
		
		        return {
		            first: this.session.getRowFoldStart(range.start.row),
		            last: this.session.getRowFoldEnd(range.end.row)
		        };
		    };
		
		    this.onCompositionStart = function(text) {
		        this.renderer.showComposition(this.getCursorPosition());
		    };
		
		    this.onCompositionUpdate = function(text) {
		        this.renderer.setCompositionText(text);
		    };
		
		    this.onCompositionEnd = function() {
		        this.renderer.hideComposition();
		    };
		
		    /**
		     * {:VirtualRenderer.getFirstVisibleRow}
		     *
		     * @returns {Number}
		     * @related VirtualRenderer.getFirstVisibleRow
		     **/
		    this.getFirstVisibleRow = function() {
		        return this.renderer.getFirstVisibleRow();
		    };
		
		    /**
		     * {:VirtualRenderer.getLastVisibleRow}
		     *
		     * @returns {Number}
		     * @related VirtualRenderer.getLastVisibleRow
		     **/
		    this.getLastVisibleRow = function() {
		        return this.renderer.getLastVisibleRow();
		    };
		
		    /**
		     * Indicates if the row is currently visible on the screen.
		     * @param {Number} row The row to check
		     *
		     * @returns {Boolean}
		     **/
		    this.isRowVisible = function(row) {
		        return (row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow());
		    };
		
		    /**
		     * Indicates if the entire row is currently visible on the screen.
		     * @param {Number} row The row to check
		     *
		     *
		     * @returns {Boolean}
		     **/
		    this.isRowFullyVisible = function(row) {
		        return (row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow());
		    };
		
		    /**
		     * Returns the number of currently visible rows.
		     * @returns {Number}
		     **/
		    this.$getVisibleRowCount = function() {
		        return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
		    };
		
		    this.$moveByPage = function(dir, select) {
		        var renderer = this.renderer;
		        var config = this.renderer.layerConfig;
		        var rows = dir * Math.floor(config.height / config.lineHeight);
		
		        if (select === true) {
		            this.selection.$moveSelection(function(){
		                this.moveCursorBy(rows, 0);
		            });
		        } else if (select === false) {
		            this.selection.moveCursorBy(rows, 0);
		            this.selection.clearSelection();
		        }
		
		        var scrollTop = renderer.scrollTop;
		
		        renderer.scrollBy(0, rows * config.lineHeight);
		        if (select != null)
		            renderer.scrollCursorIntoView(null, 0.5);
		
		        renderer.animateScrolling(scrollTop);
		    };
		
		    /**
		     * Selects the text from the current position of the document until where a "page down" finishes.
		     **/
		    this.selectPageDown = function() {
		        this.$moveByPage(1, true);
		    };
		
		    /**
		     * Selects the text from the current position of the document until where a "page up" finishes.
		     **/
		    this.selectPageUp = function() {
		        this.$moveByPage(-1, true);
		    };
		
		    /**
		     * Shifts the document to wherever "page down" is, as well as moving the cursor position.
		     **/
		    this.gotoPageDown = function() {
		       this.$moveByPage(1, false);
		    };
		
		    /**
		     * Shifts the document to wherever "page up" is, as well as moving the cursor position.
		     **/
		    this.gotoPageUp = function() {
		        this.$moveByPage(-1, false);
		    };
		
		    /**
		     * Scrolls the document to wherever "page down" is, without changing the cursor position.
		     **/
		    this.scrollPageDown = function() {
		        this.$moveByPage(1);
		    };
		
		    /**
		     * Scrolls the document to wherever "page up" is, without changing the cursor position.
		     **/
		    this.scrollPageUp = function() {
		        this.$moveByPage(-1);
		    };
		
		    /**
		     * Moves the editor to the specified row.
		     * @related VirtualRenderer.scrollToRow
		     **/
		    this.scrollToRow = function(row) {
		        this.renderer.scrollToRow(row);
		    };
		
		    /**
		     * Scrolls to a line. If `center` is `true`, it puts the line in middle of screen (or attempts to).
		     * @param {Number} line The line to scroll to
		     * @param {Boolean} center If `true`
		     * @param {Boolean} animate If `true` animates scrolling
		     * @param {Function} callback Function to be called when the animation has finished
		     *
		     *
		     * @related VirtualRenderer.scrollToLine
		     **/
		    this.scrollToLine = function(line, center, animate, callback) {
		        this.renderer.scrollToLine(line, center, animate, callback);
		    };
		
		    /**
		     * Attempts to center the current selection on the screen.
		     **/
		    this.centerSelection = function() {
		        var range = this.getSelectionRange();
		        var pos = {
		            row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
		            column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
		        };
		        this.renderer.alignCursor(pos, 0.5);
		    };
		
		    /**
		     * Gets the current position of the cursor.
		     * @returns {Object} An object that looks something like this:
		     *
		     * ```json
		     * { row: currRow, column: currCol }
		     * ```
		     *
		     * @related Selection.getCursor
		     **/
		    this.getCursorPosition = function() {
		        return this.selection.getCursor();
		    };
		
		    /**
		     * Returns the screen position of the cursor.
		     * @returns {Number}
		     * @related EditSession.documentToScreenPosition
		     **/
		    this.getCursorPositionScreen = function() {
		        return this.session.documentToScreenPosition(this.getCursorPosition());
		    };
		
		    /**
		     * {:Selection.getRange}
		     * @returns {Range}
		     * @related Selection.getRange
		     **/
		    this.getSelectionRange = function() {
		        return this.selection.getRange();
		    };
		
		
		    /**
		     * Selects all the text in editor.
		     * @related Selection.selectAll
		     **/
		    this.selectAll = function() {
		        this.selection.selectAll();
		    };
		
		    /**
		     * {:Selection.clearSelection}
		     * @related Selection.clearSelection
		     **/
		    this.clearSelection = function() {
		        this.selection.clearSelection();
		    };
		
		    /**
		     * Moves the cursor to the specified row and column. Note that this does not de-select the current selection.
		     * @param {Number} row The new row number
		     * @param {Number} column The new column number
		     *
		     *
		     * @related Selection.moveCursorTo
		     **/
		    this.moveCursorTo = function(row, column) {
		        this.selection.moveCursorTo(row, column);
		    };
		
		    /**
		     * Moves the cursor to the position indicated by `pos.row` and `pos.column`.
		     * @param {Object} pos An object with two properties, row and column
		     *
		     *
		     * @related Selection.moveCursorToPosition
		     **/
		    this.moveCursorToPosition = function(pos) {
		        this.selection.moveCursorToPosition(pos);
		    };
		
		    /**
		     * Moves the cursor's row and column to the next matching bracket or HTML tag.
		     *
		     **/
		    this.jumpToMatching = function(select, expand) {
		        var cursor = this.getCursorPosition();
		        var iterator = new TokenIterator(this.session, cursor.row, cursor.column);
		        var prevToken = iterator.getCurrentToken();
		        var token = prevToken || iterator.stepForward();
		
		        if (!token) return;
		
		        //get next closing tag or bracket
		        var matchType;
		        var found = false;
		        var depth = {};
		        var i = cursor.column - token.start;
		        var bracketType;
		        var brackets = {
		            ")": "(",
		            "(": "(",
		            "]": "[",
		            "[": "[",
		            "{": "{",
		            "}": "{"
		        };
		        
		        do {
		            if (token.value.match(/[{}()\[\]]/g)) {
		                for (; i < token.value.length && !found; i++) {
		                    if (!brackets[token.value[i]]) {
		                        continue;
		                    }
		
		                    bracketType = brackets[token.value[i]] + '.' + token.type.replace("rparen", "lparen");
		
		                    if (isNaN(depth[bracketType])) {
		                        depth[bracketType] = 0;
		                    }
		
		                    switch (token.value[i]) {
		                        case '(':
		                        case '[':
		                        case '{':
		                            depth[bracketType]++;
		                            break;
		                        case ')':
		                        case ']':
		                        case '}':
		                            depth[bracketType]--;
		
		                            if (depth[bracketType] === -1) {
		                                matchType = 'bracket';
		                                found = true;
		                            }
		                        break;
		                    }
		                }
		            }
		            else if (token.type.indexOf('tag-name') !== -1) {
		                if (isNaN(depth[token.value])) {
		                    depth[token.value] = 0;
		                }
		                
		                if (prevToken.value === '<') {
		                    depth[token.value]++;
		                }
		                else if (prevToken.value === '</') {
		                    depth[token.value]--;
		                }
		                
		                if (depth[token.value] === -1) {
		                    matchType = 'tag';
		                    found = true;
		                }
		            }
		
		            if (!found) {
		                prevToken = token;
		                token = iterator.stepForward();
		                i = 0;
		            }
		        } while (token && !found);
		
		        //no match found
		        if (!matchType)
		            return;
		
		        var range, pos;
		        if (matchType === 'bracket') {
		            range = this.session.getBracketRange(cursor);
		            if (!range) {
		                range = new Range(
		                    iterator.getCurrentTokenRow(),
		                    iterator.getCurrentTokenColumn() + i - 1,
		                    iterator.getCurrentTokenRow(),
		                    iterator.getCurrentTokenColumn() + i - 1
		                );
		                pos = range.start;
		                if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column) < 2)
		                    range = this.session.getBracketRange(pos);
		            }
		        }
		        else if (matchType === 'tag') {
		            if (token && token.type.indexOf('tag-name') !== -1) 
		                var tag = token.value;
		            else
		                return;
		
		            range = new Range(
		                iterator.getCurrentTokenRow(),
		                iterator.getCurrentTokenColumn() - 2,
		                iterator.getCurrentTokenRow(),
		                iterator.getCurrentTokenColumn() - 2
		            );
		
		            //find matching tag
		            if (range.compare(cursor.row, cursor.column) === 0) {
		                found = false;
		                do {
		                    token = prevToken;
		                    prevToken = iterator.stepBackward();
		                    
		                    if (prevToken) {
		                        if (prevToken.type.indexOf('tag-close') !== -1) {
		                            range.setEnd(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
		                        }
		
		                        if (token.value === tag && token.type.indexOf('tag-name') !== -1) {
		                            if (prevToken.value === '<') {
		                                depth[tag]++;
		                            }
		                            else if (prevToken.value === '</') {
		                                depth[tag]--;
		                            }
		                            
		                            if (depth[tag] === 0)
		                                found = true;
		                        }
		                    }
		                } while (prevToken && !found);
		            }
		
		            //we found it
		            if (token && token.type.indexOf('tag-name')) {
		                pos = range.start;
		                if (pos.row == cursor.row && Math.abs(pos.column - cursor.column) < 2)
		                    pos = range.end;
		            }
		        }
		
		        pos = range && range.cursor || pos;
		        if (pos) {
		            if (select) {
		                if (range && expand) {
		                    this.selection.setRange(range);
		                } else if (range && range.isEqual(this.getSelectionRange())) {
		                    this.clearSelection();
		                } else {
		                    this.selection.selectTo(pos.row, pos.column);
		                }
		            } else {
		                this.selection.moveTo(pos.row, pos.column);
		            }
		        }
		    };
		
		    /**
		     * Moves the cursor to the specified line number, and also into the indicated column.
		     * @param {Number} lineNumber The line number to go to
		     * @param {Number} column A column number to go to
		     * @param {Boolean} animate If `true` animates scolling
		     *
		     **/
		    this.gotoLine = function(lineNumber, column, animate) {
		        this.selection.clearSelection();
		        this.session.unfold({row: lineNumber - 1, column: column || 0});
		
		        // todo: find a way to automatically exit multiselect mode
		        this.exitMultiSelectMode && this.exitMultiSelectMode();
		        this.moveCursorTo(lineNumber - 1, column || 0);
		
		        if (!this.isRowFullyVisible(lineNumber - 1))
		            this.scrollToLine(lineNumber - 1, true, animate);
		    };
		
		    /**
		     * Moves the cursor to the specified row and column. Note that this does de-select the current selection.
		     * @param {Number} row The new row number
		     * @param {Number} column The new column number
		     *
		     *
		     * @related Editor.moveCursorTo
		     **/
		    this.navigateTo = function(row, column) {
		        this.selection.moveTo(row, column);
		    };
		
		    /**
		     * Moves the cursor up in the document the specified number of times. Note that this does de-select the current selection.
		     * @param {Number} times The number of times to change navigation
		     *
		     *
		     **/
		    this.navigateUp = function(times) {
		        if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
		            var selectionStart = this.selection.anchor.getPosition();
		            return this.moveCursorToPosition(selectionStart);
		        }
		        this.selection.clearSelection();
		        this.selection.moveCursorBy(-times || -1, 0);
		    };
		
		    /**
		     * Moves the cursor down in the document the specified number of times. Note that this does de-select the current selection.
		     * @param {Number} times The number of times to change navigation
		     *
		     *
		     **/
		    this.navigateDown = function(times) {
		        if (this.selection.isMultiLine() && this.selection.isBackwards()) {
		            var selectionEnd = this.selection.anchor.getPosition();
		            return this.moveCursorToPosition(selectionEnd);
		        }
		        this.selection.clearSelection();
		        this.selection.moveCursorBy(times || 1, 0);
		    };
		
		    /**
		     * Moves the cursor left in the document the specified number of times. Note that this does de-select the current selection.
		     * @param {Number} times The number of times to change navigation
		     *
		     *
		     **/
		    this.navigateLeft = function(times) {
		        if (!this.selection.isEmpty()) {
		            var selectionStart = this.getSelectionRange().start;
		            this.moveCursorToPosition(selectionStart);
		        }
		        else {
		            times = times || 1;
		            while (times--) {
		                this.selection.moveCursorLeft();
		            }
		        }
		        this.clearSelection();
		    };
		
		    /**
		     * Moves the cursor right in the document the specified number of times. Note that this does de-select the current selection.
		     * @param {Number} times The number of times to change navigation
		     *
		     *
		     **/
		    this.navigateRight = function(times) {
		        if (!this.selection.isEmpty()) {
		            var selectionEnd = this.getSelectionRange().end;
		            this.moveCursorToPosition(selectionEnd);
		        }
		        else {
		            times = times || 1;
		            while (times--) {
		                this.selection.moveCursorRight();
		            }
		        }
		        this.clearSelection();
		    };
		
		    /**
		     *
		     * Moves the cursor to the start of the current line. Note that this does de-select the current selection.
		     **/
		    this.navigateLineStart = function() {
		        this.selection.moveCursorLineStart();
		        this.clearSelection();
		    };
		
		    /**
		     *
		     * Moves the cursor to the end of the current line. Note that this does de-select the current selection.
		     **/
		    this.navigateLineEnd = function() {
		        this.selection.moveCursorLineEnd();
		        this.clearSelection();
		    };
		
		    /**
		     *
		     * Moves the cursor to the end of the current file. Note that this does de-select the current selection.
		     **/
		    this.navigateFileEnd = function() {
		        this.selection.moveCursorFileEnd();
		        this.clearSelection();
		    };
		
		    /**
		     *
		     * Moves the cursor to the start of the current file. Note that this does de-select the current selection.
		     **/
		    this.navigateFileStart = function() {
		        this.selection.moveCursorFileStart();
		        this.clearSelection();
		    };
		
		    /**
		     *
		     * Moves the cursor to the word immediately to the right of the current position. Note that this does de-select the current selection.
		     **/
		    this.navigateWordRight = function() {
		        this.selection.moveCursorWordRight();
		        this.clearSelection();
		    };
		
		    /**
		     *
		     * Moves the cursor to the word immediately to the left of the current position. Note that this does de-select the current selection.
		     **/
		    this.navigateWordLeft = function() {
		        this.selection.moveCursorWordLeft();
		        this.clearSelection();
		    };
		
		    /**
		     * Replaces the first occurrence of `options.needle` with the value in `replacement`.
		     * @param {String} replacement The text to replace with
		     * @param {Object} options The [[Search `Search`]] options to use
		     *
		     *
		     **/
		    this.replace = function(replacement, options) {
		        if (options)
		            this.$search.set(options);
		
		        var range = this.$search.find(this.session);
		        var replaced = 0;
		        if (!range)
		            return replaced;
		
		        if (this.$tryReplace(range, replacement)) {
		            replaced = 1;
		        }
		
		        this.selection.setSelectionRange(range);
		        this.renderer.scrollSelectionIntoView(range.start, range.end);
		
		        return replaced;
		    };
		
		    /**
		     * Replaces all occurrences of `options.needle` with the value in `replacement`.
		     * @param {String} replacement The text to replace with
		     * @param {Object} options The [[Search `Search`]] options to use
		     *
		     *
		     **/
		    this.replaceAll = function(replacement, options) {
		        if (options) {
		            this.$search.set(options);
		        }
		
		        var ranges = this.$search.findAll(this.session);
		        var replaced = 0;
		        if (!ranges.length)
		            return replaced;
		
		        var selection = this.getSelectionRange();
		        this.selection.moveTo(0, 0);
		
		        for (var i = ranges.length - 1; i >= 0; --i) {
		            if(this.$tryReplace(ranges[i], replacement)) {
		                replaced++;
		            }
		        }
		
		        this.selection.setSelectionRange(selection);
		
		        return replaced;
		    };
		
		    this.$tryReplace = function(range, replacement) {
		        var input = this.session.getTextRange(range);
		        replacement = this.$search.replace(input, replacement);
		        if (replacement !== null) {
		            range.end = this.session.replace(range, replacement);
		            return range;
		        } else {
		            return null;
		        }
		    };
		
		    /**
		     * {:Search.getOptions} For more information on `options`, see [[Search `Search`]].
		     * @related Search.getOptions
		     * @returns {Object}
		     **/
		    this.getLastSearchOptions = function() {
		        return this.$search.getOptions();
		    };
		
		    /**
		     * Attempts to find `needle` within the document. For more information on `options`, see [[Search `Search`]].
		     * @param {String} needle The text to search for (optional)
		     * @param {Object} options An object defining various search properties
		     * @param {Boolean} animate If `true` animate scrolling
		     *
		     *
		     * @related Search.find
		     **/
		    this.find = function(needle, options, animate) {
		        if (!options)
		            options = {};
		
		        if (typeof needle == "string" || needle instanceof RegExp)
		            options.needle = needle;
		        else if (typeof needle == "object")
		            oop.mixin(options, needle);
		
		        var range = this.selection.getRange();
		        if (options.needle == null) {
		            needle = this.session.getTextRange(range)
		                || this.$search.$options.needle;
		            if (!needle) {
		                range = this.session.getWordRange(range.start.row, range.start.column);
		                needle = this.session.getTextRange(range);
		            }
		            this.$search.set({needle: needle});
		        }
		
		        this.$search.set(options);
		        if (!options.start)
		            this.$search.set({start: range});
		
		        var newRange = this.$search.find(this.session);
		        if (options.preventScroll)
		            return newRange;
		        if (newRange) {
		            this.revealRange(newRange, animate);
		            return newRange;
		        }
		        // clear selection if nothing is found
		        if (options.backwards)
		            range.start = range.end;
		        else
		            range.end = range.start;
		        this.selection.setRange(range);
		    };
		
		    /**
		     * Performs another search for `needle` in the document. For more information on `options`, see [[Search `Search`]].
		     * @param {Object} options search options
		     * @param {Boolean} animate If `true` animate scrolling
		     *
		     *
		     * @related Editor.find
		     **/
		    this.findNext = function(options, animate) {
		        this.find({skipCurrent: true, backwards: false}, options, animate);
		    };
		
		    /**
		     * Performs a search for `needle` backwards. For more information on `options`, see [[Search `Search`]].
		     * @param {Object} options search options
		     * @param {Boolean} animate If `true` animate scrolling
		     *
		     *
		     * @related Editor.find
		     **/
		    this.findPrevious = function(options, animate) {
		        this.find(options, {skipCurrent: true, backwards: true}, animate);
		    };
		
		    this.revealRange = function(range, animate) {
		        this.session.unfold(range);
		        this.selection.setSelectionRange(range);
		
		        var scrollTop = this.renderer.scrollTop;
		        this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
		        if (animate !== false)
		            this.renderer.animateScrolling(scrollTop);
		    };
		
		    /**
		     * {:UndoManager.undo}
		     * @related UndoManager.undo
		     **/
		    this.undo = function() {
		        this.session.getUndoManager().undo(this.session);
		        this.renderer.scrollCursorIntoView(null, 0.5);
		    };
		
		    /**
		     * {:UndoManager.redo}
		     * @related UndoManager.redo
		     **/
		    this.redo = function() {
		        this.session.getUndoManager().redo(this.session);
		        this.renderer.scrollCursorIntoView(null, 0.5);
		    };
		
		    /**
		     *
		     * Cleans up the entire editor.
		     **/
		    this.destroy = function() {
		        this.renderer.destroy();
		        this._signal("destroy", this);
		        if (this.session) {
		            this.session.destroy();
		        }
		    };
		
		    /**
		     * Enables automatic scrolling of the cursor into view when editor itself is inside scrollable element
		     * @param {Boolean} enable default true
		     **/
		    this.setAutoScrollEditorIntoView = function(enable) {
		        if (!enable)
		            return;
		        var rect;
		        var self = this;
		        var shouldScroll = false;
		        if (!this.$scrollAnchor)
		            this.$scrollAnchor = document.createElement("div");
		        var scrollAnchor = this.$scrollAnchor;
		        scrollAnchor.style.cssText = "position:absolute";
		        this.container.insertBefore(scrollAnchor, this.container.firstChild);
		        var onChangeSelection = this.on("changeSelection", function() {
		            shouldScroll = true;
		        });
		        // needed to not trigger sync reflow
		        var onBeforeRender = this.renderer.on("beforeRender", function() {
		            if (shouldScroll)
		                rect = self.renderer.container.getBoundingClientRect();
		        });
		        var onAfterRender = this.renderer.on("afterRender", function() {
		            if (shouldScroll && rect && (self.isFocused()
		                || self.searchBox && self.searchBox.isFocused())
		            ) {
		                var renderer = self.renderer;
		                var pos = renderer.$cursorLayer.$pixelPos;
		                var config = renderer.layerConfig;
		                var top = pos.top - config.offset;
		                if (pos.top >= 0 && top + rect.top < 0) {
		                    shouldScroll = true;
		                } else if (pos.top < config.height &&
		                    pos.top + rect.top + config.lineHeight > window.innerHeight) {
		                    shouldScroll = false;
		                } else {
		                    shouldScroll = null;
		                }
		                if (shouldScroll != null) {
		                    scrollAnchor.style.top = top + "px";
		                    scrollAnchor.style.left = pos.left + "px";
		                    scrollAnchor.style.height = config.lineHeight + "px";
		                    scrollAnchor.scrollIntoView(shouldScroll);
		                }
		                shouldScroll = rect = null;
		            }
		        });
		        this.setAutoScrollEditorIntoView = function(enable) {
		            if (enable)
		                return;
		            delete this.setAutoScrollEditorIntoView;
		            this.off("changeSelection", onChangeSelection);
		            this.renderer.off("afterRender", onAfterRender);
		            this.renderer.off("beforeRender", onBeforeRender);
		        };
		    };
		
		
		    this.$resetCursorStyle = function() {
		        var style = this.$cursorStyle || "ace";
		        var cursorLayer = this.renderer.$cursorLayer;
		        if (!cursorLayer)
		            return;
		        cursorLayer.setSmoothBlinking(/smooth/.test(style));
		        cursorLayer.isBlinking = !this.$readOnly && style != "wide";
		        dom.setCssClass(cursorLayer.element, "ace_slim-cursors", /slim/.test(style));
		    };
		
		}).call(Editor.prototype);
		
		
		
		config.defineOptions(Editor.prototype, "editor", {
		    selectionStyle: {
		        set: function(style) {
		            this.onSelectionChange();
		            this._signal("changeSelectionStyle", {data: style});
		        },
		        initialValue: "line"
		    },
		    highlightActiveLine: {
		        set: function() {this.$updateHighlightActiveLine();},
		        initialValue: true
		    },
		    highlightSelectedWord: {
		        set: function(shouldHighlight) {this.$onSelectionChange();},
		        initialValue: true
		    },
		    readOnly: {
		        set: function(readOnly) {
		            // disabled to not break vim mode!
		            // this.textInput.setReadOnly(readOnly);
		            this.$resetCursorStyle(); 
		        },
		        initialValue: false
		    },
		    copyWithEmptySelection: {
		        set: function(value) {
		            this.textInput.setCopyWithEmptySelection(value);
		        },
		        initialValue: false
		    },
		    cursorStyle: {
		        set: function(val) { this.$resetCursorStyle(); },
		        values: ["ace", "slim", "smooth", "wide"],
		        initialValue: "ace"
		    },
		    mergeUndoDeltas: {
		        values: [false, true, "always"],
		        initialValue: true
		    },
		    behavioursEnabled: {initialValue: true},
		    wrapBehavioursEnabled: {initialValue: true},
		    autoScrollEditorIntoView: {
		        set: function(val) {this.setAutoScrollEditorIntoView(val);}
		    },
		    keyboardHandler: {
		        set: function(val) { this.setKeyboardHandler(val); },
		        get: function() { return this.keybindingId; },
		        handlesSet: true
		    },
		
		    hScrollBarAlwaysVisible: "renderer",
		    vScrollBarAlwaysVisible: "renderer",
		    highlightGutterLine: "renderer",
		    animatedScroll: "renderer",
		    showInvisibles: "renderer",
		    showPrintMargin: "renderer",
		    printMarginColumn: "renderer",
		    printMargin: "renderer",
		    fadeFoldWidgets: "renderer",
		    showFoldWidgets: "renderer",
		    showLineNumbers: "renderer",
		    showGutter: "renderer",
		    displayIndentGuides: "renderer",
		    fontSize: "renderer",
		    fontFamily: "renderer",
		    maxLines: "renderer",
		    minLines: "renderer",
		    scrollPastEnd: "renderer",
		    fixedWidthGutter: "renderer",
		    theme: "renderer",
		
		    scrollSpeed: "$mouseHandler",
		    dragDelay: "$mouseHandler",
		    dragEnabled: "$mouseHandler",
		    focusTimout: "$mouseHandler",
		    tooltipFollowsMouse: "$mouseHandler",
		
		    firstLineNumber: "session",
		    overwrite: "session",
		    newLineMode: "session",
		    useWorker: "session",
		    useSoftTabs: "session",
		    tabSize: "session",
		    wrap: "session",
		    indentedSoftWrap: "session",
		    foldStyle: "session",
		    mode: "session"
		});
		
		exports.Editor = Editor;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/ext/error_marker.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var LineWidgets = require("../line_widgets").LineWidgets;
		var dom = require("../lib/dom");
		var Range = require("../range").Range;
		
		function binarySearch(array, needle, comparator) {
		    var first = 0;
		    var last = array.length - 1;
		
		    while (first <= last) {
		        var mid = (first + last) >> 1;
		        var c = comparator(needle, array[mid]);
		        if (c > 0)
		            first = mid + 1;
		        else if (c < 0)
		            last = mid - 1;
		        else
		            return mid;
		    }
		
		    // Return the nearest lesser index, "-1" means "0, "-2" means "1", etc.
		    return -(first + 1);
		}
		
		function findAnnotations(session, row, dir) {
		    var annotations = session.getAnnotations().sort(Range.comparePoints);
		    if (!annotations.length)
		        return;
		    
		    var i = binarySearch(annotations, {row: row, column: -1}, Range.comparePoints);
		    if (i < 0)
		        i = -i - 1;
		    
		    if (i >= annotations.length)
		        i = dir > 0 ? 0 : annotations.length - 1;
		    else if (i === 0 && dir < 0)
		        i = annotations.length - 1;
		    
		    var annotation = annotations[i];
		    if (!annotation || !dir)
		        return;
		
		    if (annotation.row === row) {
		        do {
		            annotation = annotations[i += dir];
		        } while (annotation && annotation.row === row);
		        if (!annotation)
		            return annotations.slice();
		    }
		    
		    
		    var matched = [];
		    row = annotation.row;
		    do {
		        matched[dir < 0 ? "unshift" : "push"](annotation);
		        annotation = annotations[i += dir];
		    } while (annotation && annotation.row == row);
		    return matched.length && matched;
		}
		
		exports.showErrorMarker = function(editor, dir) {
		    var session = editor.session;
		    if (!session.widgetManager) {
		        session.widgetManager = new LineWidgets(session);
		        session.widgetManager.attach(editor);
		    }
		    
		    var pos = editor.getCursorPosition();
		    var row = pos.row;
		    var oldWidget = session.widgetManager.getWidgetsAtRow(row).filter(function(w) {
		        return w.type == "errorMarker";
		    })[0];
		    if (oldWidget) {
		        oldWidget.destroy();
		    } else {
		        row -= dir;
		    }
		    var annotations = findAnnotations(session, row, dir);
		    var gutterAnno;
		    if (annotations) {
		        var annotation = annotations[0];
		        pos.column = (annotation.pos && typeof annotation.column != "number"
		            ? annotation.pos.sc
		            : annotation.column) || 0;
		        pos.row = annotation.row;
		        gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];
		    } else if (oldWidget) {
		        return;
		    } else {
		        gutterAnno = {
		            text: ["Looks good!"],
		            className: "ace_ok"
		        };
		    }
		    editor.session.unfold(pos.row);
		    editor.selection.moveToPosition(pos);
		    
		    var w = {
		        row: pos.row, 
		        fixedWidth: true,
		        coverGutter: true,
		        el: dom.createElement("div"),
		        type: "errorMarker"
		    };
		    var el = w.el.appendChild(dom.createElement("div"));
		    var arrow = w.el.appendChild(dom.createElement("div"));
		    arrow.className = "error_widget_arrow " + gutterAnno.className;
		    
		    var left = editor.renderer.$cursorLayer
		        .getPixelPosition(pos).left;
		    arrow.style.left = left + editor.renderer.gutterWidth - 5 + "px";
		    
		    w.el.className = "error_widget_wrapper";
		    el.className = "error_widget " + gutterAnno.className;
		    el.innerHTML = gutterAnno.text.join("<br>");
		    
		    el.appendChild(dom.createElement("div"));
		    
		    var kb = function(_, hashId, keyString) {
		        if (hashId === 0 && (keyString === "esc" || keyString === "return")) {
		            w.destroy();
		            return {command: "null"};
		        }
		    };
		    
		    w.destroy = function() {
		        if (editor.$mouseHandler.isMousePressed)
		            return;
		        editor.keyBinding.removeKeyboardHandler(kb);
		        session.widgetManager.removeLineWidget(w);
		        editor.off("changeSelection", w.destroy);
		        editor.off("changeSession", w.destroy);
		        editor.off("mouseup", w.destroy);
		        editor.off("change", w.destroy);
		    };
		    
		    editor.keyBinding.addKeyboardHandler(kb);
		    editor.on("changeSelection", w.destroy);
		    editor.on("changeSession", w.destroy);
		    editor.on("mouseup", w.destroy);
		    editor.on("change", w.destroy);
		    
		    editor.session.widgetManager.addLineWidget(w);
		    
		    w.el.onmousedown = editor.focus.bind(editor);
		    
		    editor.renderer.scrollCursorIntoView(null, 0.5, {bottom: w.el.offsetHeight});
		};
		
		
		dom.importCssString("\
		    .error_widget_wrapper {\
		        background: inherit;\
		        color: inherit;\
		        border:none\
		    }\
		    .error_widget {\
		        border-top: solid 2px;\
		        border-bottom: solid 2px;\
		        margin: 5px 0;\
		        padding: 10px 40px;\
		        white-space: pre-wrap;\
		    }\
		    .error_widget.ace_error, .error_widget_arrow.ace_error{\
		        border-color: #ff5a5a\
		    }\
		    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\
		        border-color: #F1D817\
		    }\
		    .error_widget.ace_info, .error_widget_arrow.ace_info{\
		        border-color: #5a5a5a\
		    }\
		    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\
		        border-color: #5aaa5a\
		    }\
		    .error_widget_arrow {\
		        position: absolute;\
		        border: solid 5px;\
		        border-top-color: transparent!important;\
		        border-right-color: transparent!important;\
		        border-left-color: transparent!important;\
		        top: -5px;\
		    }\
		", "");
		
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/index.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		require("./lib/fixoldbrowsers");
		
		var dom = require("./lib/dom");
		var event = require("./lib/event");
		
		var Editor = require("./editor").Editor;
		var EditSession = require("./edit_session").EditSession;
		var UndoManager = require("./undomanager").UndoManager;
		var Renderer = require("./virtual_renderer").VirtualRenderer;
		
		// The following require()s are for inclusion in the built ace file
		require("./worker/worker_client");
		require("./keyboard/hash_handler");
		require("./placeholder");
		require("./multi_select");
		require("./mode/folding/fold_mode");
		require("./theme/textmate");
		require("./ext/error_marker");
		
		exports.config = require("./config");
		
		/**
		 * Provides access to require in packed noconflict mode
		 * @param {String} moduleName
		 * @returns {Object}
		 **/
		exports.require = require;
		
		if (typeof define === "function")
		    exports.define = define;
		
		/**
		 * Embeds the Ace editor into the DOM, at the element provided by `el`.
		 * @param {String | DOMElement} el Either the id of an element, or the element itself
		 *
		 **/
		exports.edit = function(el) {
		    if (typeof el == "string") {
		        var _id = el;
		        el = document.getElementById(_id);
		        if (!el)
		            throw new Error("ace.edit can't find div #" + _id);
		    }
		
		    if (el && el.env && el.env.editor instanceof Editor)
		        return el.env.editor;
		
		    var value = "";
		    if (el && /input|textarea/i.test(el.tagName)) {
		        var oldNode = el;
		        value = oldNode.value;
		        el = dom.createElement("pre");
		        oldNode.parentNode.replaceChild(el, oldNode);
		    } else if (el) {
		        value = dom.getInnerText(el);
		        el.innerHTML = "";
		    }
		
		    var doc = exports.createEditSession(value);
		
		    var editor = new Editor(new Renderer(el));
		    editor.setSession(doc);
		
		    var env = {
		        document: doc,
		        editor: editor,
		        onResize: editor.resize.bind(editor, null)
		    };
		    if (oldNode) env.textarea = oldNode;
		    event.addListener(window, "resize", env.onResize);
		    editor.on("destroy", function() {
		        event.removeListener(window, "resize", env.onResize);
		        env.editor.container.env = null; // prevent memory leak on old ie
		    });
		    editor.container.env = editor.env = env;
		    return editor;
		};
		
		/**
		 * Creates a new [[EditSession]], and returns the associated [[Document]].
		 * @param {Document | String} text {:textParam}
		 * @param {TextMode} mode {:modeParam}
		 * 
		 **/
		exports.createEditSession = function(text, mode) {
		    var doc = new EditSession(text, mode);
		    doc.setUndoManager(new UndoManager());
		    return doc;
		};
		exports.EditSession = EditSession;
		exports.UndoManager = UndoManager;
		exports.version = "1.2.9";
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/keyboard/hash_handler.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var keyUtil = require("../lib/keys");
		var useragent = require("../lib/useragent");
		var KEY_MODS = keyUtil.KEY_MODS;
		
		function HashHandler(config, platform) {
		    this.platform = platform || (useragent.isMac ? "mac" : "win");
		    this.commands = {};
		    this.commandKeyBinding = {};
		    this.addCommands(config);
		    this.$singleCommand = true;
		}
		
		function MultiHashHandler(config, platform) {
		    HashHandler.call(this, config, platform);
		    this.$singleCommand = false;
		}
		
		MultiHashHandler.prototype = HashHandler.prototype;
		
		(function() {
		    
		
		    this.addCommand = function(command) {
		        if (this.commands[command.name])
		            this.removeCommand(command);
		
		        this.commands[command.name] = command;
		
		        if (command.bindKey)
		            this._buildKeyHash(command);
		    };
		
		    this.removeCommand = function(command, keepCommand) {
		        var name = command && (typeof command === 'string' ? command : command.name);
		        command = this.commands[name];
		        if (!keepCommand)
		            delete this.commands[name];
		
		        // exhaustive search is brute force but since removeCommand is
		        // not a performance critical operation this should be OK
		        var ckb = this.commandKeyBinding;
		        for (var keyId in ckb) {
		            var cmdGroup = ckb[keyId];
		            if (cmdGroup == command) {
		                delete ckb[keyId];
		            } else if (Array.isArray(cmdGroup)) {
		                var i = cmdGroup.indexOf(command);
		                if (i != -1) {
		                    cmdGroup.splice(i, 1);
		                    if (cmdGroup.length == 1)
		                        ckb[keyId] = cmdGroup[0];
		                }
		            }
		        }
		    };
		
		    this.bindKey = function(key, command, position) {
		        if (typeof key == "object" && key) {
		            if (position == undefined)
		                position = key.position;
		            key = key[this.platform];
		        }
		        if (!key)
		            return;
		        if (typeof command == "function")
		            return this.addCommand({exec: command, bindKey: key, name: command.name || key});
		        
		        key.split("|").forEach(function(keyPart) {
		            var chain = "";
		            if (keyPart.indexOf(" ") != -1) {
		                var parts = keyPart.split(/\s+/);
		                keyPart = parts.pop();
		                parts.forEach(function(keyPart) {
		                    var binding = this.parseKeys(keyPart);
		                    var id = KEY_MODS[binding.hashId] + binding.key;
		                    chain += (chain ? " " : "") + id;
		                    this._addCommandToBinding(chain, "chainKeys");
		                }, this);
		                chain += " ";
		            }
		            var binding = this.parseKeys(keyPart);
		            var id = KEY_MODS[binding.hashId] + binding.key;
		            this._addCommandToBinding(chain + id, command, position);
		        }, this);
		    };
		    
		    function getPosition(command) {
		        return typeof command == "object" && command.bindKey
		            && command.bindKey.position || 0;
		    }
		    this._addCommandToBinding = function(keyId, command, position) {
		        var ckb = this.commandKeyBinding, i;
		        if (!command) {
		            delete ckb[keyId];
		        } else if (!ckb[keyId] || this.$singleCommand) {
		            ckb[keyId] = command;
		        } else {
		            if (!Array.isArray(ckb[keyId])) {
		                ckb[keyId] = [ckb[keyId]];
		            } else if ((i = ckb[keyId].indexOf(command)) != -1) {
		                ckb[keyId].splice(i, 1);
		            }
		
		            if (typeof position != "number") {
		                if (position || command.isDefault)
		                    position = -100;
		                else
		                   position = getPosition(command);
		            }
		            var commands = ckb[keyId];
		            for (i = 0; i < commands.length; i++) {
		                var other = commands[i];
		                var otherPos = getPosition(other);
		                if (otherPos > position)
		                    break;
		            }
		            commands.splice(i, 0, command);
		        }
		    };
		
		    this.addCommands = function(commands) {
		        commands && Object.keys(commands).forEach(function(name) {
		            var command = commands[name];
		            if (!command)
		                return;
		            
		            if (typeof command === "string")
		                return this.bindKey(command, name);
		
		            if (typeof command === "function")
		                command = { exec: command };
		
		            if (typeof command !== "object")
		                return;
		
		            if (!command.name)
		                command.name = name;
		
		            this.addCommand(command);
		        }, this);
		    };
		
		    this.removeCommands = function(commands) {
		        Object.keys(commands).forEach(function(name) {
		            this.removeCommand(commands[name]);
		        }, this);
		    };
		
		    this.bindKeys = function(keyList) {
		        Object.keys(keyList).forEach(function(key) {
		            this.bindKey(key, keyList[key]);
		        }, this);
		    };
		
		    this._buildKeyHash = function(command) {
		        this.bindKey(command.bindKey, command);
		    };
		
		    // accepts keys in the form ctrl+Enter or ctrl-Enter
		    // keys without modifiers or shift only 
		    this.parseKeys = function(keys) {
		        var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function(x){return x});
		        var key = parts.pop();
		
		        var keyCode = keyUtil[key];
		        if (keyUtil.FUNCTION_KEYS[keyCode])
		            key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();
		        else if (!parts.length)
		            return {key: key, hashId: -1};
		        else if (parts.length == 1 && parts[0] == "shift")
		            return {key: key.toUpperCase(), hashId: -1};
		
		        var hashId = 0;
		        for (var i = parts.length; i--;) {
		            var modifier = keyUtil.KEY_MODS[parts[i]];
		            if (modifier == null) {
		                if (typeof console != "undefined")
		                    console.error("invalid modifier " + parts[i] + " in " + keys);
		                return false;
		            }
		            hashId |= modifier;
		        }
		        return {key: key, hashId: hashId};
		    };
		
		    this.findKeyCommand = function findKeyCommand(hashId, keyString) {
		        var key = KEY_MODS[hashId] + keyString;
		        return this.commandKeyBinding[key];
		    };
		
		    this.handleKeyboard = function(data, hashId, keyString, keyCode) {
		        if (keyCode < 0) return;
		        var key = KEY_MODS[hashId] + keyString;
		        var command = this.commandKeyBinding[key];
		        if (data.$keyChain) {
		            data.$keyChain += " " + key;
		            command = this.commandKeyBinding[data.$keyChain] || command;
		        }
		        
		        if (command) {
		            if (command == "chainKeys" || command[command.length - 1] == "chainKeys") {
		                data.$keyChain = data.$keyChain || key;
		                return {command: "null"};
		            }
		        }
		        
		        if (data.$keyChain) {
		            if ((!hashId || hashId == 4) && keyString.length == 1)
		                data.$keyChain = data.$keyChain.slice(0, -key.length - 1); // wait for input
		            else if (hashId == -1 || keyCode > 0)
		                data.$keyChain = ""; // reset keyChain
		        }
		        return {command: command};
		    };
		    
		    this.getStatusText = function(editor, data) {
		        return data.$keyChain || "";
		    };
		
		}).call(HashHandler.prototype);
		
		exports.HashHandler = HashHandler;
		exports.MultiHashHandler = MultiHashHandler;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/keyboard/keybinding.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var keyUtil  = require("../lib/keys");
		var event = require("../lib/event");
		
		var KeyBinding = function(editor) {
		    this.$editor = editor;
		    this.$data = {editor: editor};
		    this.$handlers = [];
		    this.setDefaultHandler(editor.commands);
		};
		
		(function() {
		    this.setDefaultHandler = function(kb) {
		        this.removeKeyboardHandler(this.$defaultHandler);
		        this.$defaultHandler = kb;
		        this.addKeyboardHandler(kb, 0);
		    };
		
		    this.setKeyboardHandler = function(kb) {
		        var h = this.$handlers;
		        if (h[h.length - 1] == kb)
		            return;
		
		        while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler)
		            this.removeKeyboardHandler(h[h.length - 1]);
		
		        this.addKeyboardHandler(kb, 1);
		    };
		
		    this.addKeyboardHandler = function(kb, pos) {
		        if (!kb)
		            return;
		        if (typeof kb == "function" && !kb.handleKeyboard)
		            kb.handleKeyboard = kb;
		        var i = this.$handlers.indexOf(kb);
		        if (i != -1)
		            this.$handlers.splice(i, 1);
		
		        if (pos == undefined)
		            this.$handlers.push(kb);
		        else
		            this.$handlers.splice(pos, 0, kb);
		
		        if (i == -1 && kb.attach)
		            kb.attach(this.$editor);
		    };
		
		    this.removeKeyboardHandler = function(kb) {
		        var i = this.$handlers.indexOf(kb);
		        if (i == -1)
		            return false;
		        this.$handlers.splice(i, 1);
		        kb.detach && kb.detach(this.$editor);
		        return true;
		    };
		
		    this.getKeyboardHandler = function() {
		        return this.$handlers[this.$handlers.length - 1];
		    };
		    
		    this.getStatusText = function() {
		        var data = this.$data;
		        var editor = data.editor;
		        return this.$handlers.map(function(h) {
		            return h.getStatusText && h.getStatusText(editor, data) || "";
		        }).filter(Boolean).join(" ");
		    };
		
		    this.$callKeyboardHandlers = function(hashId, keyString, keyCode, e) {
		        var toExecute;
		        var success = false;
		        var commands = this.$editor.commands;
		
		        for (var i = this.$handlers.length; i--;) {
		            toExecute = this.$handlers[i].handleKeyboard(
		                this.$data, hashId, keyString, keyCode, e
		            );
		            if (!toExecute || !toExecute.command)
		                continue;
		            
		            // allow keyboardHandler to consume keys
		            if (toExecute.command == "null") {
		                success = true;
		            } else {
		                success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);
		            }
		            // do not stop input events to not break repeating
		            if (success && e && hashId != -1 && 
		                toExecute.passEvent != true && toExecute.command.passEvent != true
		            ) {
		                event.stopEvent(e);
		            }
		            if (success)
		                break;
		        }
		        
		        if (!success && hashId == -1) {
		            toExecute = {command: "insertstring"};
		            success = commands.exec("insertstring", this.$editor, keyString);
		        }
		        
		        if (success && this.$editor._signal)
		            this.$editor._signal("keyboardActivity", toExecute);
		        
		        return success;
		    };
		
		    this.onCommandKey = function(e, hashId, keyCode) {
		        var keyString = keyUtil.keyCodeToString(keyCode);
		        this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
		    };
		
		    this.onTextInput = function(text) {
		        this.$callKeyboardHandlers(-1, text);
		    };
		
		}).call(KeyBinding.prototype);
		
		exports.KeyBinding = KeyBinding;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/keyboard/textinput.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var event = require("../lib/event");
		var useragent = require("../lib/useragent");
		var dom = require("../lib/dom");
		var lang = require("../lib/lang");
		var BROKEN_SETDATA = useragent.isChrome < 18;
		var USE_IE_MIME_TYPE =  useragent.isIE;
		
		var TextInputIOS = require("./textinput_ios").TextInput;
		var TextInput = function(parentNode, host) {
		    if (useragent.isIOS)
		        return TextInputIOS.call(this, parentNode, host);
		    
		    var text = dom.createElement("textarea");
		    text.className = "ace_text-input";
		
		    text.setAttribute("wrap", "off");
		    text.setAttribute("autocorrect", "off");
		    text.setAttribute("autocapitalize", "off");
		    text.setAttribute("spellcheck", false);
		
		    text.style.opacity = "0";
		    parentNode.insertBefore(text, parentNode.firstChild);
		
		    var PLACEHOLDER = "\u2028\u2028";
		
		    var copied = false;
		    var pasted = false;
		    var inComposition = false;
		    var tempStyle = '';
		    var isSelectionEmpty = true;
		    var copyWithEmptySelection = false;
		
		    // FOCUS
		    // ie9 throws error if document.activeElement is accessed too soon
		    try { var isFocused = document.activeElement === text; } catch(e) {}
		    
		    event.addListener(text, "blur", function(e) {
		        host.onBlur(e);
		        isFocused = false;
		    });
		    event.addListener(text, "focus", function(e) {
		        isFocused = true;
		        host.onFocus(e);
		        resetSelection();
		    });
		    this.focus = function() {
		        if (tempStyle) return text.focus();
		        var top = text.style.top;
		        text.style.position = "fixed";
		        text.style.top = "0px";
		        text.focus();
		        setTimeout(function() {
		            text.style.position = "";
		            if (text.style.top == "0px")
		                text.style.top = top;
		        }, 0);
		    };
		    this.blur = function() {
		        text.blur();
		    };
		    this.isFocused = function() {
		        return isFocused;
		    };
		
		    // modifying selection of blured textarea can focus it (chrome mac/linux)
		    var syncSelection = lang.delayedCall(function() {
		        isFocused && resetSelection(isSelectionEmpty);
		    });
		    var syncValue = lang.delayedCall(function() {
		         if (!inComposition) {
		            text.value = PLACEHOLDER;
		            isFocused && resetSelection();
		         }
		    });
		
		    function resetSelection(isEmpty) {
		        isEmpty = copyWithEmptySelection ? false : isEmpty;
		        if (inComposition)
		            return;
		        
		        // this prevents infinite recursion on safari 8 
		        // see https://github.com/ajaxorg/ace/issues/2114
		        inComposition = true;
		        
		        if (inputHandler) {
		            var selectionStart = 0;
		            var selectionEnd = isEmpty ? 0 : text.value.length - 1;
		        } else {
		            var selectionStart = isEmpty ? 2 : 1;
		            var selectionEnd = 2;
		        }
		        // on firefox this throws if textarea is hidden
		        try {
		            text.setSelectionRange(selectionStart, selectionEnd);
		        } catch(e){}
		        
		        inComposition = false;
		    }
		
		    function resetValue() {
		        if (inComposition)
		            return;
		        text.value = PLACEHOLDER;
		        //http://code.google.com/p/chromium/issues/detail?id=76516
		        if (useragent.isWebKit)
		            syncValue.schedule();
		    }
		
		    useragent.isWebKit || host.addEventListener('changeSelection', function() {
		        if (host.selection.isEmpty() != isSelectionEmpty) {
		            isSelectionEmpty = !isSelectionEmpty;
		            syncSelection.schedule();
		        }
		    });
		
		    resetValue();
		    if (isFocused)
		        host.onFocus();
		
		
		    var isAllSelected = function(text) {
		        return text.selectionStart === 0 && text.selectionEnd === text.value.length;
		    };
		
		    var onSelect = function(e) {
		        if (copied) {
		            copied = false;
		        } else if (isAllSelected(text)) {
		            host.selectAll();
		            resetSelection();
		        } else if (inputHandler) {
		            resetSelection(host.selection.isEmpty());
		        }
		    };
		
		    var inputHandler = null;
		    this.setInputHandler = function(cb) {inputHandler = cb;};
		    this.getInputHandler = function() {return inputHandler;};
		    var afterContextMenu = false;
		    
		    var sendText = function(data) {
		        if (inputHandler) {
		            data = inputHandler(data);
		            inputHandler = null;
		        }
		        if (pasted) {
		            resetSelection();
		            if (data)
		                host.onPaste(data);
		            pasted = false;
		        } else if (data == PLACEHOLDER.charAt(0)) {
		            if (afterContextMenu)
		                host.execCommand("del", {source: "ace"});
		            else // some versions of android do not fire keydown when pressing backspace
		                host.execCommand("backspace", {source: "ace"});
		        } else {
		            if (data.substring(0, 2) == PLACEHOLDER)
		                data = data.substr(2);
		            else if (data.charAt(0) == PLACEHOLDER.charAt(0))
		                data = data.substr(1);
		            else if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
		                data = data.slice(0, -1);
		            // can happen if undo in textarea isn't stopped
		            if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
		                data = data.slice(0, -1);
		            
		            if (data)
		                host.onTextInput(data);
		        }
		        if (afterContextMenu)
		            afterContextMenu = false;
		    };
		    var onInput = function(e) {
		        // console.log("onInput", inComposition)
		        if (inComposition)
		            return;
		        var data = text.value;
		        sendText(data);
		        resetValue();
		    };
		    
		    var handleClipboardData = function(e, data, forceIEMime) {
		        var clipboardData = e.clipboardData || window.clipboardData;
		        if (!clipboardData || BROKEN_SETDATA)
		            return;
		        // using "Text" doesn't work on old webkit but ie needs it
		        var mime = USE_IE_MIME_TYPE || forceIEMime ? "Text" : "text/plain";
		        try {
		            if (data) {
		                // Safari 5 has clipboardData object, but does not handle setData()
		                return clipboardData.setData(mime, data) !== false;
		            } else {
		                return clipboardData.getData(mime);
		            }
		        } catch(e) {
		            if (!forceIEMime)
		                return handleClipboardData(e, data, true);
		        }
		    };
		
		    var doCopy = function(e, isCut) {
		        var data = host.getCopyText();
		        if (!data)
		            return event.preventDefault(e);
		
		        if (handleClipboardData(e, data)) {
		            isCut ? host.onCut() : host.onCopy();
		            event.preventDefault(e);
		        } else {
		            copied = true;
		            text.value = data;
		            text.select();
		            setTimeout(function(){
		                copied = false;
		                resetValue();
		                resetSelection();
		                isCut ? host.onCut() : host.onCopy();
		            });
		        }
		    };
		    
		    var onCut = function(e) {
		        doCopy(e, true);
		    };
		    
		    var onCopy = function(e) {
		        doCopy(e, false);
		    };
		    
		    var onPaste = function(e) {
		        var data = handleClipboardData(e);
		        if (typeof data == "string") {
		            if (data)
		                host.onPaste(data, e);
		            if (useragent.isIE)
		                setTimeout(resetSelection);
		            event.preventDefault(e);
		        }
		        else {
		            text.value = "";
		            pasted = true;
		        }
		    };
		
		    event.addCommandKeyListener(text, host.onCommandKey.bind(host));
		
		    event.addListener(text, "select", onSelect);
		
		    event.addListener(text, "input", onInput);
		
		    event.addListener(text, "cut", onCut);
		    event.addListener(text, "copy", onCopy);
		    event.addListener(text, "paste", onPaste);
		
		
		    // Opera has no clipboard events
		    if (!('oncut' in text) || !('oncopy' in text) || !('onpaste' in text)) {
		        event.addListener(parentNode, "keydown", function(e) {
		            if ((useragent.isMac && !e.metaKey) || !e.ctrlKey)
		                return;
		
		            switch (e.keyCode) {
		                case 67:
		                    onCopy(e);
		                    break;
		                case 86:
		                    onPaste(e);
		                    break;
		                case 88:
		                    onCut(e);
		                    break;
		            }
		        });
		    }
		
		
		    // COMPOSITION
		    var onCompositionStart = function(e) {
		        if (inComposition || !host.onCompositionStart || host.$readOnly) 
		            return;
		        // console.log("onCompositionStart", inComposition)
		        inComposition = {};
		        inComposition.canUndo = host.session.$undoManager;
		        host.onCompositionStart();
		        setTimeout(onCompositionUpdate, 0);
		        host.on("mousedown", onCompositionEnd);
		        if (inComposition.canUndo && !host.selection.isEmpty()) {
		            host.insert("");
		            host.session.markUndoGroup();
		            host.selection.clearSelection();
		        }
		        host.session.markUndoGroup();
		    };
		
		    var onCompositionUpdate = function() {
		        // console.log("onCompositionUpdate", inComposition && JSON.stringify(text.value))
		        if (!inComposition || !host.onCompositionUpdate || host.$readOnly)
		            return;
		        var val = text.value.replace(/\u2028/g, "");
		        if (inComposition.lastValue === val) return;
		        
		        host.onCompositionUpdate(val);
		        if (inComposition.lastValue)
		            host.undo();
		        if (inComposition.canUndo)
		            inComposition.lastValue = val;
		        if (inComposition.lastValue) {
		            var r = host.selection.getRange();
		            host.insert(inComposition.lastValue);
		            host.session.markUndoGroup();
		            inComposition.range = host.selection.getRange();
		            host.selection.setRange(r);
		            host.selection.clearSelection();
		        }
		    };
		
		    var onCompositionEnd = function(e) {
		        if (!host.onCompositionEnd || host.$readOnly) return;
		        // console.log("onCompositionEnd", inComposition &&inComposition.lastValue)
		        var c = inComposition;
		        inComposition = false;
		        var timer = setTimeout(function() {
		            timer = null;
		            var str = text.value.replace(/\u2028/g, "");
		            // console.log(str, c.lastValue)
		            if (inComposition)
		                return;
		            else if (str == c.lastValue)
		                resetValue();
		            else if (!c.lastValue && str) {
		                resetValue();
		                sendText(str);
		            }
		        });
		        inputHandler = function compositionInputHandler(str) {
		            // console.log("onCompositionEnd", str, c.lastValue)
		            if (timer)
		                clearTimeout(timer);
		            str = str.replace(/\u2028/g, "");
		            if (str == c.lastValue)
		                return "";
		            if (c.lastValue && timer)
		                host.undo();
		            return str;
		        };
		        host.onCompositionEnd();
		        host.removeListener("mousedown", onCompositionEnd);
		        if (e.type == "compositionend" && c.range) {
		            host.selection.setRange(c.range);
		        }
		        // Workaround for #3027, #3045, #3097, #3100, #3249
		        var needsOnInput = useragent.isIE ||
		            (useragent.isChrome && useragent.isChrome >= 53) ||
		            (useragent.isWebKit && useragent.isWebKit >= 603);
		
		        if (needsOnInput) {
		          onInput();
		        }
		    };
		    
		    
		
		    var syncComposition = lang.delayedCall(onCompositionUpdate, 50);
		
		    event.addListener(text, "compositionstart", onCompositionStart);
		    event.addListener(text, "compositionupdate", function(){syncComposition.schedule();});
		    event.addListener(text, "keyup", function(){syncComposition.schedule();});
		    event.addListener(text, "keydown", function(){syncComposition.schedule();});
		    event.addListener(text, "compositionend", onCompositionEnd);
		
		    this.getElement = function() {
		        return text;
		    };
		
		    this.setReadOnly = function(readOnly) {
		       text.readOnly = readOnly;
		    };
		
		    this.setCopyWithEmptySelection = function(value) {
		        copyWithEmptySelection = value;
		    };
		
		    this.onContextMenu = function(e) {
		        afterContextMenu = true;
		        resetSelection(host.selection.isEmpty());
		        host._emit("nativecontextmenu", {target: host, domEvent: e});
		        this.moveToMouse(e, true);
		    };
		    
		    this.moveToMouse = function(e, bringToFront) {
		        if (!tempStyle)
		            tempStyle = text.style.cssText;
		        text.style.cssText = (bringToFront ? "z-index:100000;" : "")
		            + "height:" + text.style.height + ";"
		            + (useragent.isIE ? "opacity:0.1;" : "");
		
		        var rect = host.container.getBoundingClientRect();
		        var style = dom.computedStyle(host.container);
		        var top = rect.top + (parseInt(style.borderTopWidth) || 0);
		        var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
		        var maxTop = rect.bottom - top - text.clientHeight -2;
		        var move = function(e) {
		            text.style.left = e.clientX - left - 2 + "px";
		            text.style.top = Math.min(e.clientY - top - 2, maxTop) + "px";
		        }; 
		        move(e);
		
		        if (e.type != "mousedown")
		            return;
		
		        if (host.renderer.$keepTextAreaAtCursor)
		            host.renderer.$keepTextAreaAtCursor = null;
		
		        clearTimeout(closeTimeout);
		        // on windows context menu is opened after mouseup
		        if (useragent.isWin)
		            event.capture(host.container, move, onContextMenuClose);
		    };
		
		    this.onContextMenuClose = onContextMenuClose;
		    var closeTimeout;
		    function onContextMenuClose() {
		        clearTimeout(closeTimeout);
		        closeTimeout = setTimeout(function () {
		            if (tempStyle) {
		                text.style.cssText = tempStyle;
		                tempStyle = '';
		            }
		            if (host.renderer.$keepTextAreaAtCursor == null) {
		                host.renderer.$keepTextAreaAtCursor = true;
		                host.renderer.$moveTextAreaToCursor();
		            }
		        }, 0);
		    }
		
		    var onContextMenu = function(e) {
		        host.textInput.onContextMenu(e);
		        onContextMenuClose();
		    };
		    event.addListener(text, "mouseup", onContextMenu);
		    event.addListener(text, "mousedown", function(e) {
		        e.preventDefault();
		        onContextMenuClose();
		    });
		    event.addListener(host.renderer.scroller, "contextmenu", onContextMenu);
		    event.addListener(text, "contextmenu", onContextMenu);
		};
		
		exports.TextInput = TextInput;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/keyboard/textinput_ios.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var event = require("../lib/event");
		var useragent = require("../lib/useragent");
		var dom = require("../lib/dom");
		var lang = require("../lib/lang");
		var KEYS = require("../lib/keys");
		var MODS = KEYS.KEY_MODS;
		var BROKEN_SETDATA = useragent.isChrome < 18;
		var USE_IE_MIME_TYPE =  useragent.isIE;
		
		var TextInput = function(parentNode, host) {
		    var self = this;
		    var text = dom.createElement("textarea");
		    text.className = useragent.isIOS ? "ace_text-input ace_text-input-ios" : "ace_text-input";
		
		    if (useragent.isTouchPad)
		        text.setAttribute("x-palm-disable-auto-cap", true);
		
		    text.setAttribute("wrap", "off");
		    text.setAttribute("autocorrect", "off");
		    text.setAttribute("autocapitalize", "off");
		    text.setAttribute("spellcheck", false);
		
		    text.style.opacity = "0";
		    parentNode.insertBefore(text, parentNode.firstChild);
		
		    var PLACEHOLDER = "\n aaaa a\n";
		
		    var copied = false;
		    var cut = false;
		    var pasted = false;
		    var inComposition = false;
		    var tempStyle = '';
		    var isSelectionEmpty = true;
		
		    // FOCUS
		    // ie9 throws error if document.activeElement is accessed too soon
		    try { var isFocused = document.activeElement === text; } catch(e) {}
		    
		    event.addListener(text, "blur", function(e) {
		        host.onBlur(e);
		        isFocused = false;
		    });
		    event.addListener(text, "focus", function(e) {
		        isFocused = true;
		        host.onFocus(e);
		        resetSelection();
		    });
		    this.focus = function() {
		        if (tempStyle) return text.focus();
		        text.style.position = "fixed";
		        text.focus();
		    };
		    this.blur = function() {
		        text.blur();
		    };
		    this.isFocused = function() {
		        return isFocused;
		    };
		
		    // modifying selection of blured textarea can focus it (chrome mac/linux)
		    var syncSelection = lang.delayedCall(function() {
		        isFocused && resetSelection(isSelectionEmpty);
		    });
		    var syncValue = lang.delayedCall(function() {
		         if (!inComposition) {
		            text.value = PLACEHOLDER;
		            isFocused && resetSelection();
		         }
		    });
		
		    function resetSelection(isEmpty) {
		        if (inComposition)
		            return;
		        
		        // this prevents infinite recursion on safari 8 
		        // see https://github.com/ajaxorg/ace/issues/2114
		        inComposition = true;
		        
		        if (inputHandler) {
		            selectionStart = 0;
		            selectionEnd = isEmpty ? 0 : text.value.length - 1;
		        } else {
		            var selectionStart = 4;
		            var selectionEnd = 5;
		        }
		        // on firefox this throws if textarea is hidden
		        try {
		            text.setSelectionRange(selectionStart, selectionEnd);
		        } catch(e) {}
		        
		        inComposition = false;
		    }
		
		    function resetValue() {
		        if (inComposition)
		            return;
		        text.value = PLACEHOLDER;
		        //http://code.google.com/p/chromium/issues/detail?id=76516
		        if (useragent.isWebKit)
		            syncValue.schedule();
		    }
		
		    useragent.isWebKit || host.addEventListener('changeSelection', function() {
		        if (host.selection.isEmpty() != isSelectionEmpty) {
		            isSelectionEmpty = !isSelectionEmpty;
		            syncSelection.schedule();
		        }
		    });
		
		    resetValue();
		    if (isFocused)
		        host.onFocus();
		
		
		    var isAllSelected = function(text) {
		        return text.selectionStart === 0 && text.selectionEnd === text.value.length;
		    };
		
		    var onSelect = function(e) {
		        if (isAllSelected(text)) {
		            host.selectAll();
		            resetSelection();
		        } else if (inputHandler) {
		            resetSelection(host.selection.isEmpty());
		        }
		    };
		
		    var inputHandler = null;
		    this.setInputHandler = function(cb) {inputHandler = cb;};
		    this.getInputHandler = function() {return inputHandler;};
		    var afterContextMenu = false;
		    
		    var sendText = function(data) {
		        if (text.selectionStart === 4 && text.selectionEnd === 5) {
		          return;
		        }
		        if (inputHandler) {
		            data = inputHandler(data);
		            inputHandler = null;
		        }
		        if (pasted) {
		            resetSelection();
		            if (data)
		                host.onPaste(data);
		            pasted = false;
		        } else if (data == PLACEHOLDER.substr(0) && text.selectionStart === 4) {
		            if (afterContextMenu)
		                host.execCommand("del", {source: "ace"});
		            else // some versions of android do not fire keydown when pressing backspace
		                host.execCommand("backspace", {source: "ace"});
		        } else if (!copied) {
		            if (data.substring(0, 9) == PLACEHOLDER && data.length > PLACEHOLDER.length)
		                data = data.substr(9);
		            else if (data.substr(0, 4) == PLACEHOLDER.substr(0, 4))
		                data = data.substr(4, data.length - PLACEHOLDER.length + 1);
		            else if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
		                data = data.slice(0, -1);
		            // can happen if undo in textarea isn't stopped
		            if (data == PLACEHOLDER.charAt(0)) {
		              // Do nothing
		            } else if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
		                data = data.slice(0, -1);
		            
		            if (data)
		                host.onTextInput(data);
		        }
		        if (copied) {
		          copied = false;
		        }
		        if (afterContextMenu)
		            afterContextMenu = false;
		    };
		    var onInput = function(e) {
		        // console.log("onInput", inComposition)
		        if (inComposition)
		            return;
		        var data = text.value;
		        sendText(data);
		        resetValue();
		    };
		    
		    var handleClipboardData = function(e, data, forceIEMime) {
		        var clipboardData = e.clipboardData || window.clipboardData;
		        if (!clipboardData || BROKEN_SETDATA)
		            return;
		        // using "Text" doesn't work on old webkit but ie needs it
		        var mime = USE_IE_MIME_TYPE || forceIEMime ? "Text" : "text/plain";
		        try {
		            if (data) {
		                // Safari 5 has clipboardData object, but does not handle setData()
		                return clipboardData.setData(mime, data) !== false;
		            } else {
		                return clipboardData.getData(mime);
		            }
		        } catch(e) {
		            if (!forceIEMime)
		                return handleClipboardData(e, data, true);
		        }
		    };
		
		    var doCopy = function(e, isCut) {
		        var data = host.getCopyText();
		        if (!data)
		            return event.preventDefault(e);
		
		        if (handleClipboardData(e, data)) {
		            if (useragent.isIOS) {
		                cut = isCut;
		                text.value = "\n aa" + data + "a a\n";
		                text.setSelectionRange(4, 4 + data.length);
		                copied = {
		                    value: data
		                };
		            }
		            isCut ? host.onCut() : host.onCopy();
		            if (!useragent.isIOS) event.preventDefault(e);
		        } else {
		            copied = true;
		            text.value = data;
		            text.select();
		            setTimeout(function(){
		                copied = false;
		                resetValue();
		                resetSelection();
		                isCut ? host.onCut() : host.onCopy();
		            });
		        }
		    };
		    
		    var onCut = function(e) {
		        doCopy(e, true);
		    };
		    
		    var onCopy = function(e) {
		        doCopy(e, false);
		    };
		    
		    var onPaste = function(e) {
		        var data = handleClipboardData(e);
		        if (typeof data == "string") {
		            if (data)
		                host.onPaste(data, e);
		            if (useragent.isIE)
		                setTimeout(resetSelection);
		            event.preventDefault(e);
		        }
		        else {
		            text.value = "";
		            pasted = true;
		        }
		    };
		
		    event.addCommandKeyListener(text, host.onCommandKey.bind(host));
		
		    event.addListener(text, "select", onSelect);
		
		    event.addListener(text, "input", onInput);
		
		    event.addListener(text, "cut", onCut);
		    event.addListener(text, "copy", onCopy);
		    event.addListener(text, "paste", onPaste);
		
		
		    // COMPOSITION
		    var onCompositionStart = function(e) {
		        if (inComposition || !host.onCompositionStart || host.$readOnly) 
		            return;
		        // console.log("onCompositionStart", inComposition)
		        inComposition = {};
		        inComposition.canUndo = host.session.$undoManager;
		        host.onCompositionStart();
		        setTimeout(onCompositionUpdate, 0);
		        host.on("mousedown", onCompositionEnd);
		        if (inComposition.canUndo && !host.selection.isEmpty()) {
		            host.insert("");
		            host.session.markUndoGroup();
		            host.selection.clearSelection();
		        }
		        host.session.markUndoGroup();
		    };
		
		    var onCompositionUpdate = function() {
		        // console.log("onCompositionUpdate", inComposition && JSON.stringify(text.value))
		        if (!inComposition || !host.onCompositionUpdate || host.$readOnly)
		            return;
		        var val = text.value.replace(/\x01/g, "");
		        if (inComposition.lastValue === val) return;
		        
		        host.onCompositionUpdate(val);
		        if (inComposition.lastValue)
		            host.undo();
		        if (inComposition.canUndo)
		            inComposition.lastValue = val;
		        if (inComposition.lastValue) {
		            var r = host.selection.getRange();
		            host.insert(inComposition.lastValue);
		            host.session.markUndoGroup();
		            inComposition.range = host.selection.getRange();
		            host.selection.setRange(r);
		            host.selection.clearSelection();
		        }
		    };
		
		    var onCompositionEnd = function(e) {
		        if (!host.onCompositionEnd || host.$readOnly) return;
		        // console.log("onCompositionEnd", inComposition &&inComposition.lastValue)
		        var c = inComposition;
		        inComposition = false;
		        var timer = setTimeout(function() {
		            timer = null;
		            var str = text.value.replace(/\x01/g, "");
		            // console.log(str, c.lastValue)
		            if (inComposition)
		                return;
		            else if (str == c.lastValue)
		                resetValue();
		            else if (!c.lastValue && str) {
		                resetValue();
		                sendText(str);
		            }
		        });
		        inputHandler = function compositionInputHandler(str) {
		            // console.log("onCompositionEnd", str, c.lastValue)
		            if (timer)
		                clearTimeout(timer);
		            str = str.replace(/\x01/g, "");
		            if (str == c.lastValue)
		                return "";
		            if (c.lastValue && timer)
		                host.undo();
		            return str;
		        };
		        host.onCompositionEnd();
		        host.removeListener("mousedown", onCompositionEnd);
		        if (e.type == "compositionend" && c.range) {
		            host.selection.setRange(c.range);
		        }
		        // Workaround for #3027, #3045, #3097, #3100, #3249
		        var needsOnInput =
		            (!!useragent.isChrome && useragent.isChrome >= 53) ||
		            (!!useragent.isWebKit && useragent.isWebKit >= 603);
		
		        if (needsOnInput) {
		          onInput();
		        }
		    };
		    
		    
		
		    var syncComposition = lang.delayedCall(onCompositionUpdate, 50);
		
		    event.addListener(text, "compositionstart", onCompositionStart);
		    event.addListener(text, "compositionupdate", function(){syncComposition.schedule();});
		    event.addListener(text, "keyup", function(){syncComposition.schedule();});
		    event.addListener(text, "keydown", function(){syncComposition.schedule();});
		    event.addListener(text, "compositionend", onCompositionEnd);
		
		    this.getElement = function() {
		        return text;
		    };
		
		    this.setReadOnly = function(readOnly) {
		       text.readOnly = readOnly;
		    };
		
		    this.onContextMenu = function(e) {
		        afterContextMenu = true;
		        resetSelection(host.selection.isEmpty());
		        host._emit("nativecontextmenu", {target: host, domEvent: e});
		        this.moveToMouse(e, true);
		    };
		    
		    this.moveToMouse = function(e, bringToFront) {
		        if (!tempStyle)
		            tempStyle = text.style.cssText;
		        text.style.cssText = (bringToFront ? "z-index:100000;" : "")
		            + "height:" + text.style.height + ";"
		            + (useragent.isIE ? "opacity:0.1;" : "");
		
		        var rect = host.container.getBoundingClientRect();
		        var style = dom.computedStyle(host.container);
		        var top = rect.top + (parseInt(style.borderTopWidth) || 0);
		        var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
		        var maxTop = rect.bottom - top - text.clientHeight -2;
		        var move = function(e) {
		            text.style.left = e.clientX - left - 2 + "px";
		            text.style.top = Math.min(e.clientY - top - 2, maxTop) + "px";
		        }; 
		        move(e);
		
		        if (e.type != "mousedown")
		            return;
		
		        if (host.renderer.$keepTextAreaAtCursor)
		            host.renderer.$keepTextAreaAtCursor = null;
		
		        clearTimeout(closeTimeout);
		        // on windows context menu is opened after mouseup
		        if (useragent.isWin)
		            event.capture(host.container, move, onContextMenuClose);
		    };
		
		    this.onContextMenuClose = onContextMenuClose;
		    var closeTimeout;
		    function onContextMenuClose() {
		        clearTimeout(closeTimeout);
		        closeTimeout = setTimeout(function () {
		            if (tempStyle) {
		                text.style.cssText = tempStyle;
		                tempStyle = '';
		            }
		            if (host.renderer.$keepTextAreaAtCursor == null) {
		                host.renderer.$keepTextAreaAtCursor = true;
		                host.renderer.$moveTextAreaToCursor();
		            }
		        }, 0);
		    }
		
		    var onContextMenu = function(e) {
		        host.textInput.onContextMenu(e);
		        onContextMenuClose();
		    };
		    event.addListener(text, "mouseup", onContextMenu);
		    event.addListener(text, "mousedown", function(e) {
		        e.preventDefault();
		        onContextMenuClose();
		    });
		    event.addListener(host.renderer.scroller, "contextmenu", onContextMenu);
		    event.addListener(text, "contextmenu", onContextMenu);
		    
		    if (useragent.isIOS) {
		        var typingResetTimeout = null;
		        var typing = false;
		
		        parentNode.addEventListener("keydown", function (e) {
		            if (typingResetTimeout) clearTimeout(typingResetTimeout);
		            typing = true;
		        });
		
		        parentNode.addEventListener("keyup", function (e) {
		            typingResetTimeout = setTimeout(function () {
		                typing = false;
		            }, 100);
		        });
		        
		        // IOS doesn't fire events for arrow keys, but this unique hack changes everything!
		        var detectArrowKeys = function(e) {
		            if (document.activeElement !== text) return;
		            if (typing) return;
		          
		            if (cut) {
		                return setTimeout(function () {
		                    cut = false;
		                }, 100);
		            }
		            var selectionStart = text.selectionStart;
		            var selectionEnd = text.selectionEnd;
		            text.setSelectionRange(4, 5);
		            if (selectionStart == selectionEnd) {
		                switch (selectionStart) {
		                    case 0: host.onCommandKey(null, 0, KEYS.up); break;
		                    case 1: host.onCommandKey(null, 0, KEYS.home); break;
		                    case 2: host.onCommandKey(null, MODS.option, KEYS.left); break;
		                    case 4: host.onCommandKey(null, 0, KEYS.left); break;
		                    case 5: host.onCommandKey(null, 0, KEYS.right); break;
		                    case 7: host.onCommandKey(null, MODS.option, KEYS.right); break;
		                    case 8: host.onCommandKey(null, 0, KEYS.end); break;
		                    case 9: host.onCommandKey(null, 0, KEYS.down); break;
		                }
		            } else {
		                switch (selectionEnd) {
		                    case 6: host.onCommandKey(null, MODS.shift, KEYS.right); break;
		                    case 7: host.onCommandKey(null, MODS.shift | MODS.option, KEYS.right); break;
		                    case 8: host.onCommandKey(null, MODS.shift, KEYS.end); break;
		                    case 9: host.onCommandKey(null, MODS.shift, KEYS.down); break;
		                }
		                switch (selectionStart) {
		                    case 0: host.onCommandKey(null, MODS.shift, KEYS.up); break;
		                    case 1: host.onCommandKey(null, MODS.shift, KEYS.home); break;
		                    case 2: host.onCommandKey(null, MODS.shift | MODS.option, KEYS.left); break;
		                    case 3: host.onCommandKey(null, MODS.shift, KEYS.left); break;
		                }
		            }
		        };
		        // On iOS, "selectionchange" can only be attached to the document object...
		        document.addEventListener("selectionchange", detectArrowKeys);
		        host.on("destroy", function() {
		            document.removeEventListener("selectionchange", detectArrowKeys);
		        });
		    }
		};
		
		exports.TextInput = TextInput;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/layer/cursor.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var dom = require("../lib/dom");
		var isIE8;
		
		var Cursor = function(parentEl) {
		    this.element = dom.createElement("div");
		    this.element.className = "ace_layer ace_cursor-layer";
		    parentEl.appendChild(this.element);
		    
		    if (isIE8 === undefined)
		        isIE8 = !("opacity" in this.element.style);
		
		    this.isVisible = false;
		    this.isBlinking = true;
		    this.blinkInterval = 1000;
		    this.smoothBlinking = false;
		
		    this.cursors = [];
		    this.cursor = this.addCursor();
		    dom.addCssClass(this.element, "ace_hidden-cursors");
		    this.$updateCursors = (isIE8
		        ? this.$updateVisibility
		        : this.$updateOpacity).bind(this);
		};
		
		(function() {
		    
		    this.$updateVisibility = function(val) {
		        var cursors = this.cursors;
		        for (var i = cursors.length; i--; )
		            cursors[i].style.visibility = val ? "" : "hidden";
		    };
		    this.$updateOpacity = function(val) {
		        var cursors = this.cursors;
		        for (var i = cursors.length; i--; )
		            cursors[i].style.opacity = val ? "" : "0";
		    };
		    
		
		    this.$padding = 0;
		    this.setPadding = function(padding) {
		        this.$padding = padding;
		    };
		
		    this.setSession = function(session) {
		        this.session = session;
		    };
		
		    this.setBlinking = function(blinking) {
		        if (blinking != this.isBlinking){
		            this.isBlinking = blinking;
		            this.restartTimer();
		        }
		    };
		
		    this.setBlinkInterval = function(blinkInterval) {
		        if (blinkInterval != this.blinkInterval){
		            this.blinkInterval = blinkInterval;
		            this.restartTimer();
		        }
		    };
		
		    this.setSmoothBlinking = function(smoothBlinking) {
		        if (smoothBlinking != this.smoothBlinking && !isIE8) {
		            this.smoothBlinking = smoothBlinking;
		            dom.setCssClass(this.element, "ace_smooth-blinking", smoothBlinking);
		            this.$updateCursors(true);
		            this.$updateCursors = (this.$updateOpacity).bind(this);
		            this.restartTimer();
		        }
		    };
		
		    this.addCursor = function() {
		        var el = dom.createElement("div");
		        el.className = "ace_cursor";
		        this.element.appendChild(el);
		        this.cursors.push(el);
		        return el;
		    };
		
		    this.removeCursor = function() {
		        if (this.cursors.length > 1) {
		            var el = this.cursors.pop();
		            el.parentNode.removeChild(el);
		            return el;
		        }
		    };
		
		    this.hideCursor = function() {
		        this.isVisible = false;
		        dom.addCssClass(this.element, "ace_hidden-cursors");
		        this.restartTimer();
		    };
		
		    this.showCursor = function() {
		        this.isVisible = true;
		        dom.removeCssClass(this.element, "ace_hidden-cursors");
		        this.restartTimer();
		    };
		
		    this.restartTimer = function() {
		        var update = this.$updateCursors;
		        clearInterval(this.intervalId);
		        clearTimeout(this.timeoutId);
		        if (this.smoothBlinking) {
		            dom.removeCssClass(this.element, "ace_smooth-blinking");
		        }
		        
		        update(true);
		
		        if (!this.isBlinking || !this.blinkInterval || !this.isVisible)
		            return;
		
		        if (this.smoothBlinking) {
		            setTimeout(function(){
		                dom.addCssClass(this.element, "ace_smooth-blinking");
		            }.bind(this));
		        }
		        
		        var blink = function(){
		            this.timeoutId = setTimeout(function() {
		                update(false);
		            }, 0.6 * this.blinkInterval);
		        }.bind(this);
		
		        this.intervalId = setInterval(function() {
		            update(true);
		            blink();
		        }, this.blinkInterval);
		
		        blink();
		    };
		
		    this.getPixelPosition = function(position, onScreen) {
		        if (!this.config || !this.session)
		            return {left : 0, top : 0};
		
		        if (!position)
		            position = this.session.selection.getCursor();
		        var pos = this.session.documentToScreenPosition(position);
		        var cursorLeft = this.$padding + pos.column * this.config.characterWidth;
		        var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) *
		            this.config.lineHeight;
		
		        return {left : cursorLeft, top : cursorTop};
		    };
		
		    this.update = function(config) {
		        this.config = config;
		
		        var selections = this.session.$selectionMarkers;
		        var i = 0, cursorIndex = 0;
		
		        if (selections === undefined || selections.length === 0){
		            selections = [{cursor: null}];
		        }
		
		        for (var i = 0, n = selections.length; i < n; i++) {
		            var pixelPos = this.getPixelPosition(selections[i].cursor, true);
		            if ((pixelPos.top > config.height + config.offset ||
		                 pixelPos.top < 0) && i > 1) {
		                continue;
		            }
		
		            var style = (this.cursors[cursorIndex++] || this.addCursor()).style;
		            
		            if (!this.drawCursor) {
		                style.left = pixelPos.left + "px";
		                style.top = pixelPos.top + "px";
		                style.width = config.characterWidth + "px";
		                style.height = config.lineHeight + "px";
		            } else {
		                this.drawCursor(style, pixelPos, config, selections[i], this.session);
		            }
		        }
		        while (this.cursors.length > cursorIndex)
		            this.removeCursor();
		
		        var overwrite = this.session.getOverwrite();
		        this.$setOverwrite(overwrite);
		
		        // cache for textarea and gutter highlight
		        this.$pixelPos = pixelPos;
		        this.restartTimer();
		    };
		    
		    this.drawCursor = null;
		
		    this.$setOverwrite = function(overwrite) {
		        if (overwrite != this.overwrite) {
		            this.overwrite = overwrite;
		            if (overwrite)
		                dom.addCssClass(this.element, "ace_overwrite-cursors");
		            else
		                dom.removeCssClass(this.element, "ace_overwrite-cursors");
		        }
		    };
		
		    this.destroy = function() {
		        clearInterval(this.intervalId);
		        clearTimeout(this.timeoutId);
		    };
		
		}).call(Cursor.prototype);
		
		exports.Cursor = Cursor;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/layer/font_metrics.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var oop = require("../lib/oop");
		var dom = require("../lib/dom");
		var lang = require("../lib/lang");
		var useragent = require("../lib/useragent");
		var EventEmitter = require("../lib/event_emitter").EventEmitter;
		
		var CHAR_COUNT = 0;
		
		var FontMetrics = exports.FontMetrics = function(parentEl) {
		    this.el = dom.createElement("div");
		    this.$setMeasureNodeStyles(this.el.style, true);
		    
		    this.$main = dom.createElement("div");
		    this.$setMeasureNodeStyles(this.$main.style);
		    
		    this.$measureNode = dom.createElement("div");
		    this.$setMeasureNodeStyles(this.$measureNode.style);
		    
		    
		    this.el.appendChild(this.$main);
		    this.el.appendChild(this.$measureNode);
		    parentEl.appendChild(this.el);
		    
		    if (!CHAR_COUNT)
		        this.$testFractionalRect();
		    this.$measureNode.innerHTML = lang.stringRepeat("X", CHAR_COUNT);
		    
		    this.$characterSize = {width: 0, height: 0};
		    this.checkForSizeChanges();
		};
		
		(function() {
		
		    oop.implement(this, EventEmitter);
		        
		    this.$characterSize = {width: 0, height: 0};
		    
		    this.$testFractionalRect = function() {
		        var el = dom.createElement("div");
		        this.$setMeasureNodeStyles(el.style);
		        el.style.width = "0.2px";
		        document.documentElement.appendChild(el);
		        var w = el.getBoundingClientRect().width;
		        if (w > 0 && w < 1)
		            CHAR_COUNT = 50;
		        else
		            CHAR_COUNT = 100;
		        el.parentNode.removeChild(el);
		    };
		    
		    this.$setMeasureNodeStyles = function(style, isRoot) {
		        style.width = style.height = "auto";
		        style.left = style.top = "0px";
		        style.visibility = "hidden";
		        style.position = "absolute";
		        style.whiteSpace = "pre";
		
		        if (useragent.isIE < 8) {
		            style["font-family"] = "inherit";
		        } else {
		            style.font = "inherit";
		        }
		        style.overflow = isRoot ? "hidden" : "visible";
		    };
		
		    this.checkForSizeChanges = function() {
		        var size = this.$measureSizes();
		        if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
		            this.$measureNode.style.fontWeight = "bold";
		            var boldSize = this.$measureSizes();
		            this.$measureNode.style.fontWeight = "";
		            this.$characterSize = size;
		            this.charSizes = Object.create(null);
		            this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;
		            this._emit("changeCharacterSize", {data: size});
		        }
		    };
		
		    this.$pollSizeChanges = function() {
		        if (this.$pollSizeChangesTimer)
		            return this.$pollSizeChangesTimer;
		        var self = this;
		        return this.$pollSizeChangesTimer = setInterval(function() {
		            self.checkForSizeChanges();
		        }, 500);
		    };
		    
		    this.setPolling = function(val) {
		        if (val) {
		            this.$pollSizeChanges();
		        } else if (this.$pollSizeChangesTimer) {
		            clearInterval(this.$pollSizeChangesTimer);
		            this.$pollSizeChangesTimer = 0;
		        }
		    };
		
		    this.$measureSizes = function() {
		        if (CHAR_COUNT === 50) {
		            var rect = null;
		            try { 
		               rect = this.$measureNode.getBoundingClientRect();
		            } catch(e) {
		               rect = {width: 0, height:0 };
		            }
		            var size = {
		                height: rect.height,
		                width: rect.width / CHAR_COUNT
		            };
		        } else {
		            var size = {
		                height: this.$measureNode.clientHeight,
		                width: this.$measureNode.clientWidth / CHAR_COUNT
		            };
		        }
		        // Size and width can be null if the editor is not visible or
		        // detached from the document
		        if (size.width === 0 || size.height === 0)
		            return null;
		        return size;
		    };
		
		    this.$measureCharWidth = function(ch) {
		        this.$main.innerHTML = lang.stringRepeat(ch, CHAR_COUNT);
		        var rect = this.$main.getBoundingClientRect();
		        return rect.width / CHAR_COUNT;
		    };
		    
		    this.getCharacterWidth = function(ch) {
		        var w = this.charSizes[ch];
		        if (w === undefined) {
		            w = this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;
		        }
		        return w;
		    };
		
		    this.destroy = function() {
		        clearInterval(this.$pollSizeChangesTimer);
		        if (this.el && this.el.parentNode)
		            this.el.parentNode.removeChild(this.el);
		    };
		
		}).call(FontMetrics.prototype);
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/layer/gutter.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var dom = require("../lib/dom");
		var oop = require("../lib/oop");
		var lang = require("../lib/lang");
		var EventEmitter = require("../lib/event_emitter").EventEmitter;
		
		var Gutter = function(parentEl) {
		    this.element = dom.createElement("div");
		    this.element.className = "ace_layer ace_gutter-layer";
		    parentEl.appendChild(this.element);
		    this.setShowFoldWidgets(this.$showFoldWidgets);
		    
		    this.gutterWidth = 0;
		
		    this.$annotations = [];
		    this.$updateAnnotations = this.$updateAnnotations.bind(this);
		
		    this.$cells = [];
		};
		
		(function() {
		
		    oop.implement(this, EventEmitter);
		
		    this.setSession = function(session) {
		        if (this.session)
		            this.session.removeEventListener("change", this.$updateAnnotations);
		        this.session = session;
		        if (session)
		            session.on("change", this.$updateAnnotations);
		    };
		
		    this.addGutterDecoration = function(row, className){
		        if (window.console)
		            console.warn && console.warn("deprecated use session.addGutterDecoration");
		        this.session.addGutterDecoration(row, className);
		    };
		
		    this.removeGutterDecoration = function(row, className){
		        if (window.console)
		            console.warn && console.warn("deprecated use session.removeGutterDecoration");
		        this.session.removeGutterDecoration(row, className);
		    };
		
		    this.setAnnotations = function(annotations) {
		        // iterate over sparse array
		        this.$annotations = [];
		        for (var i = 0; i < annotations.length; i++) {
		            var annotation = annotations[i];
		            var row = annotation.row;
		            var rowInfo = this.$annotations[row];
		            if (!rowInfo)
		                rowInfo = this.$annotations[row] = {text: []};
		           
		            var annoText = annotation.text;
		            annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || "";
		
		            if (rowInfo.text.indexOf(annoText) === -1)
		                rowInfo.text.push(annoText);
		
		            var type = annotation.type;
		            if (type == "error")
		                rowInfo.className = " ace_error";
		            else if (type == "warning" && rowInfo.className != " ace_error")
		                rowInfo.className = " ace_warning";
		            else if (type == "info" && (!rowInfo.className))
		                rowInfo.className = " ace_info";
		        }
		    };
		
		    this.$updateAnnotations = function (delta) {
		        if (!this.$annotations.length)
		            return;
		        var firstRow = delta.start.row;
		        var len = delta.end.row - firstRow;
		        if (len === 0) {
		            // do nothing
		        } else if (delta.action == 'remove') {
		            this.$annotations.splice(firstRow, len + 1, null);
		        } else {
		            var args = new Array(len + 1);
		            args.unshift(firstRow, 1);
		            this.$annotations.splice.apply(this.$annotations, args);
		        }
		    };
		
		    this.update = function(config) {
		        var session = this.session;
		        var firstRow = config.firstRow;
		        var lastRow = Math.min(config.lastRow + config.gutterOffset,  // needed to compensate for hor scollbar
		            session.getLength() - 1);
		        var fold = session.getNextFoldLine(firstRow);
		        var foldStart = fold ? fold.start.row : Infinity;
		        var foldWidgets = this.$showFoldWidgets && session.foldWidgets;
		        var breakpoints = session.$breakpoints;
		        var decorations = session.$decorations;
		        var firstLineNumber = session.$firstLineNumber;
		        var lastLineNumber = 0;
		        
		        var gutterRenderer = session.gutterRenderer || this.$renderer;
		
		        var cell = null;
		        var index = -1;
		        var row = firstRow;
		        while (true) {
		            if (row > foldStart) {
		                row = fold.end.row + 1;
		                fold = session.getNextFoldLine(row, fold);
		                foldStart = fold ? fold.start.row : Infinity;
		            }
		            if (row > lastRow) {
		                while (this.$cells.length > index + 1) {
		                    cell = this.$cells.pop();
		                    this.element.removeChild(cell.element);
		                }
		                break;
		            }
		
		            cell = this.$cells[++index];
		            if (!cell) {
		                cell = {element: null, textNode: null, foldWidget: null};
		                cell.element = dom.createElement("div");
		                cell.textNode = document.createTextNode('');
		                cell.element.appendChild(cell.textNode);
		                this.element.appendChild(cell.element);
		                this.$cells[index] = cell;
		            }
		
		            var className = "ace_gutter-cell ";
		            if (breakpoints[row])
		                className += breakpoints[row];
		            if (decorations[row])
		                className += decorations[row];
		            if (this.$annotations[row])
		                className += this.$annotations[row].className;
		            if (cell.element.className != className)
		                cell.element.className = className;
		
		            var height = session.getRowLength(row) * config.lineHeight + "px";
		            if (height != cell.element.style.height)
		                cell.element.style.height = height;
		
		            if (foldWidgets) {
		                var c = foldWidgets[row];
		                // check if cached value is invalidated and we need to recompute
		                if (c == null)
		                    c = foldWidgets[row] = session.getFoldWidget(row);
		            }
		
		            if (c) {
		                if (!cell.foldWidget) {
		                    cell.foldWidget = dom.createElement("span");
		                    cell.element.appendChild(cell.foldWidget);
		                }
		                var className = "ace_fold-widget ace_" + c;
		                if (c == "start" && row == foldStart && row < fold.end.row)
		                    className += " ace_closed";
		                else
		                    className += " ace_open";
		                if (cell.foldWidget.className != className)
		                    cell.foldWidget.className = className;
		
		                var height = config.lineHeight + "px";
		                if (cell.foldWidget.style.height != height)
		                    cell.foldWidget.style.height = height;
		            } else {
		                if (cell.foldWidget) {
		                    cell.element.removeChild(cell.foldWidget);
		                    cell.foldWidget = null;
		                }
		            }
		            
		            var text = lastLineNumber = gutterRenderer
		                ? gutterRenderer.getText(session, row)
		                : row + firstLineNumber;
		            if (text != cell.textNode.data)
		                cell.textNode.data = text;
		
		            row++;
		        }
		
		        this.element.style.height = config.minHeight + "px";
		
		        if (this.$fixedWidth || session.$useWrapMode)
		            lastLineNumber = session.getLength() + firstLineNumber;
		
		        var gutterWidth = gutterRenderer 
		            ? gutterRenderer.getWidth(session, lastLineNumber, config)
		            : lastLineNumber.toString().length * config.characterWidth;
		        
		        var padding = this.$padding || this.$computePadding();
		        gutterWidth += padding.left + padding.right;
		        if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {
		            this.gutterWidth = gutterWidth;
		            this.element.style.width = Math.ceil(this.gutterWidth) + "px";
		            this._emit("changeGutterWidth", gutterWidth);
		        }
		    };
		
		    this.$fixedWidth = false;
		    
		    this.$showLineNumbers = true;
		    this.$renderer = "";
		    this.setShowLineNumbers = function(show) {
		        this.$renderer = !show && {
		            getWidth: function() {return ""},
		            getText: function() {return ""}
		        };
		    };
		    
		    this.getShowLineNumbers = function() {
		        return this.$showLineNumbers;
		    };
		    
		    this.$showFoldWidgets = true;
		    this.setShowFoldWidgets = function(show) {
		        if (show)
		            dom.addCssClass(this.element, "ace_folding-enabled");
		        else
		            dom.removeCssClass(this.element, "ace_folding-enabled");
		
		        this.$showFoldWidgets = show;
		        this.$padding = null;
		    };
		    
		    this.getShowFoldWidgets = function() {
		        return this.$showFoldWidgets;
		    };
		
		    this.$computePadding = function() {
		        if (!this.element.firstChild)
		            return {left: 0, right: 0};
		        var style = dom.computedStyle(this.element.firstChild);
		        this.$padding = {};
		        this.$padding.left = parseInt(style.paddingLeft) + 1 || 0;
		        this.$padding.right = parseInt(style.paddingRight) || 0;
		        return this.$padding;
		    };
		
		    this.getRegion = function(point) {
		        var padding = this.$padding || this.$computePadding();
		        var rect = this.element.getBoundingClientRect();
		        if (point.x < padding.left + rect.left)
		            return "markers";
		        if (this.$showFoldWidgets && point.x > rect.right - padding.right)
		            return "foldWidgets";
		    };
		
		}).call(Gutter.prototype);
		
		exports.Gutter = Gutter;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/layer/marker.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var Range = require("../range").Range;
		var dom = require("../lib/dom");
		
		var Marker = function(parentEl) {
		    this.element = dom.createElement("div");
		    this.element.className = "ace_layer ace_marker-layer";
		    parentEl.appendChild(this.element);
		};
		
		(function() {
		
		    this.$padding = 0;
		
		    this.setPadding = function(padding) {
		        this.$padding = padding;
		    };
		    this.setSession = function(session) {
		        this.session = session;
		    };
		    
		    this.setMarkers = function(markers) {
		        this.markers = markers;
		    };
		
		    this.update = function(config) {
		        var config = config || this.config;
		        if (!config)
		            return;
		
		        this.config = config;
		
		
		        var html = [];
		        for (var key in this.markers) {
		            var marker = this.markers[key];
		
		            if (!marker.range) {
		                marker.update(html, this, this.session, config);
		                continue;
		            }
		
		            var range = marker.range.clipRows(config.firstRow, config.lastRow);
		            if (range.isEmpty()) continue;
		
		            range = range.toScreenRange(this.session);
		            if (marker.renderer) {
		                var top = this.$getTop(range.start.row, config);
		                var left = this.$padding + range.start.column * config.characterWidth;
		                marker.renderer(html, range, left, top, config);
		            } else if (marker.type == "fullLine") {
		                this.drawFullLineMarker(html, range, marker.clazz, config);
		            } else if (marker.type == "screenLine") {
		                this.drawScreenLineMarker(html, range, marker.clazz, config);
		            } else if (range.isMultiLine()) {
		                if (marker.type == "text")
		                    this.drawTextMarker(html, range, marker.clazz, config);
		                else
		                    this.drawMultiLineMarker(html, range, marker.clazz, config);
		            } else {
		                this.drawSingleLineMarker(html, range, marker.clazz + " ace_start" + " ace_br15", config);
		            }
		        }
		        this.element.innerHTML = html.join("");
		    };
		
		    this.$getTop = function(row, layerConfig) {
		        return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
		    };
		
		    function getBorderClass(tl, tr, br, bl) {
		        return (tl ? 1 : 0) | (tr ? 2 : 0) | (br ? 4 : 0) | (bl ? 8 : 0);
		    }
		    // Draws a marker, which spans a range of text on multiple lines 
		    this.drawTextMarker = function(stringBuilder, range, clazz, layerConfig, extraStyle) {
		        var session = this.session;
		        var start = range.start.row;
		        var end = range.end.row;
		        var row = start;
		        var prev = 0; 
		        var curr = 0;
		        var next = session.getScreenLastRowColumn(row);
		        var lineRange = new Range(row, range.start.column, row, curr);
		        for (; row <= end; row++) {
		            lineRange.start.row = lineRange.end.row = row;
		            lineRange.start.column = row == start ? range.start.column : session.getRowWrapIndent(row);
		            lineRange.end.column = next;
		            prev = curr;
		            curr = next;
		            next = row + 1 < end ? session.getScreenLastRowColumn(row + 1) : row == end ? 0 : range.end.column;
		            this.drawSingleLineMarker(stringBuilder, lineRange, 
		                clazz + (row == start  ? " ace_start" : "") + " ace_br"
		                    + getBorderClass(row == start || row == start + 1 && range.start.column, prev < curr, curr > next, row == end),
		                layerConfig, row == end ? 0 : 1, extraStyle);
		        }
		    };
		
		    // Draws a multi line marker, where lines span the full width
		    this.drawMultiLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
		        // from selection start to the end of the line
		        var padding = this.$padding;
		        var height = config.lineHeight;
		        var top = this.$getTop(range.start.row, config);
		        var left = padding + range.start.column * config.characterWidth;
		        extraStyle = extraStyle || "";
		
		        stringBuilder.push(
		            "<div class='", clazz, " ace_br1 ace_start' style='",
		            "height:", height, "px;",
		            "right:0;",
		            "top:", top, "px;",
		            "left:", left, "px;", extraStyle, "'></div>"
		        );
		
		        // from start of the last line to the selection end
		        top = this.$getTop(range.end.row, config);
		        var width = range.end.column * config.characterWidth;
		
		        stringBuilder.push(
		            "<div class='", clazz, " ace_br12' style='",
		            "height:", height, "px;",
		            "width:", width, "px;",
		            "top:", top, "px;",
		            "left:", padding, "px;", extraStyle, "'></div>"
		        );
		
		        // all the complete lines
		        height = (range.end.row - range.start.row - 1) * config.lineHeight;
		        if (height <= 0)
		            return;
		        top = this.$getTop(range.start.row + 1, config);
		        
		        var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);
		
		        stringBuilder.push(
		            "<div class='", clazz, (radiusClass ? " ace_br" + radiusClass : ""), "' style='",
		            "height:", height, "px;",
		            "right:0;",
		            "top:", top, "px;",
		            "left:", padding, "px;", extraStyle, "'></div>"
		        );
		    };
		
		    // Draws a marker which covers part or whole width of a single screen line
		    this.drawSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {
		        var height = config.lineHeight;
		        var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;
		
		        var top = this.$getTop(range.start.row, config);
		        var left = this.$padding + range.start.column * config.characterWidth;
		
		        stringBuilder.push(
		            "<div class='", clazz, "' style='",
		            "height:", height, "px;",
		            "width:", width, "px;",
		            "top:", top, "px;",
		            "left:", left, "px;", extraStyle || "", "'></div>"
		        );
		    };
		
		    this.drawFullLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
		        var top = this.$getTop(range.start.row, config);
		        var height = config.lineHeight;
		        if (range.start.row != range.end.row)
		            height += this.$getTop(range.end.row, config) - top;
		
		        stringBuilder.push(
		            "<div class='", clazz, "' style='",
		            "height:", height, "px;",
		            "top:", top, "px;",
		            "left:0;right:0;", extraStyle || "", "'></div>"
		        );
		    };
		    
		    this.drawScreenLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
		        var top = this.$getTop(range.start.row, config);
		        var height = config.lineHeight;
		
		        stringBuilder.push(
		            "<div class='", clazz, "' style='",
		            "height:", height, "px;",
		            "top:", top, "px;",
		            "left:0;right:0;", extraStyle || "", "'></div>"
		        );
		    };
		
		}).call(Marker.prototype);
		
		exports.Marker = Marker;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/layer/text.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var oop = require("../lib/oop");
		var dom = require("../lib/dom");
		var lang = require("../lib/lang");
		var useragent = require("../lib/useragent");
		var EventEmitter = require("../lib/event_emitter").EventEmitter;
		
		var Text = function(parentEl) {
		    this.element = dom.createElement("div");
		    this.element.className = "ace_layer ace_text-layer";
		    parentEl.appendChild(this.element);
		    this.$updateEolChar = this.$updateEolChar.bind(this);
		};
		
		(function() {
		
		    oop.implement(this, EventEmitter);
		
		    this.EOF_CHAR = "\xB6";
		    this.EOL_CHAR_LF = "\xAC";
		    this.EOL_CHAR_CRLF = "\xa4";
		    this.EOL_CHAR = this.EOL_CHAR_LF;
		    this.TAB_CHAR = "\u2014"; //"\u21E5";
		    this.SPACE_CHAR = "\xB7";
		    this.$padding = 0;
		
		    this.$updateEolChar = function() {
		        var EOL_CHAR = this.session.doc.getNewLineCharacter() == "\n"
		           ? this.EOL_CHAR_LF
		           : this.EOL_CHAR_CRLF;
		        if (this.EOL_CHAR != EOL_CHAR) {
		            this.EOL_CHAR = EOL_CHAR;
		            return true;
		        }
		    }
		
		    this.setPadding = function(padding) {
		        this.$padding = padding;
		        this.element.style.padding = "0 " + padding + "px";
		    };
		
		    this.getLineHeight = function() {
		        return this.$fontMetrics.$characterSize.height || 0;
		    };
		
		    this.getCharacterWidth = function() {
		        return this.$fontMetrics.$characterSize.width || 0;
		    };
		    
		    this.$setFontMetrics = function(measure) {
		        this.$fontMetrics = measure;
		        this.$fontMetrics.on("changeCharacterSize", function(e) {
		            this._signal("changeCharacterSize", e);
		        }.bind(this));
		        this.$pollSizeChanges();
		    }
		
		    this.checkForSizeChanges = function() {
		        this.$fontMetrics.checkForSizeChanges();
		    };
		    this.$pollSizeChanges = function() {
		        return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
		    };
		    this.setSession = function(session) {
		        this.session = session;
		        if (session)
		            this.$computeTabString();
		    };
		
		    this.showInvisibles = false;
		    this.setShowInvisibles = function(showInvisibles) {
		        if (this.showInvisibles == showInvisibles)
		            return false;
		
		        this.showInvisibles = showInvisibles;
		        this.$computeTabString();
		        return true;
		    };
		
		    this.displayIndentGuides = true;
		    this.setDisplayIndentGuides = function(display) {
		        if (this.displayIndentGuides == display)
		            return false;
		
		        this.displayIndentGuides = display;
		        this.$computeTabString();
		        return true;
		    };
		
		    this.$tabStrings = [];
		    this.onChangeTabSize =
		    this.$computeTabString = function() {
		        var tabSize = this.session.getTabSize();
		        this.tabSize = tabSize;
		        var tabStr = this.$tabStrings = [0];
		        for (var i = 1; i < tabSize + 1; i++) {
		            if (this.showInvisibles) {
		                tabStr.push("<span class='ace_invisible ace_invisible_tab'>"
		                    + lang.stringRepeat(this.TAB_CHAR, i)
		                    + "</span>");
		            } else {
		                tabStr.push(lang.stringRepeat(" ", i));
		            }
		        }
		        if (this.displayIndentGuides) {
		            this.$indentGuideRe =  /\s\S| \t|\t |\s$/;
		            var className = "ace_indent-guide";
		            var spaceClass = "";
		            var tabClass = "";
		            if (this.showInvisibles) {
		                className += " ace_invisible";
		                spaceClass = " ace_invisible_space";
		                tabClass = " ace_invisible_tab";
		                var spaceContent = lang.stringRepeat(this.SPACE_CHAR, this.tabSize);
		                var tabContent = lang.stringRepeat(this.TAB_CHAR, this.tabSize);
		            } else{
		                var spaceContent = lang.stringRepeat(" ", this.tabSize);
		                var tabContent = spaceContent;
		            }
		
		            this.$tabStrings[" "] = "<span class='" + className + spaceClass + "'>" + spaceContent + "</span>";
		            this.$tabStrings["\t"] = "<span class='" + className + tabClass + "'>" + tabContent + "</span>";
		        }
		    };
		
		    this.updateLines = function(config, firstRow, lastRow) {
		        // Due to wrap line changes there can be new lines if e.g.
		        // the line to updated wrapped in the meantime.
		        if (this.config.lastRow != config.lastRow ||
		            this.config.firstRow != config.firstRow) {
		            this.scrollLines(config);
		        }
		        this.config = config;
		
		        var first = Math.max(firstRow, config.firstRow);
		        var last = Math.min(lastRow, config.lastRow);
		
		        var lineElements = this.element.childNodes;
		        var lineElementsIdx = 0;
		
		        for (var row = config.firstRow; row < first; row++) {
		            var foldLine = this.session.getFoldLine(row);
		            if (foldLine) {
		                if (foldLine.containsRow(first)) {
		                    first = foldLine.start.row;
		                    break;
		                } else {
		                    row = foldLine.end.row;
		                }
		            }
		            lineElementsIdx ++;
		        }
		
		        var row = first;
		        var foldLine = this.session.getNextFoldLine(row);
		        var foldStart = foldLine ? foldLine.start.row : Infinity;
		
		        while (true) {
		            if (row > foldStart) {
		                row = foldLine.end.row+1;
		                foldLine = this.session.getNextFoldLine(row, foldLine);
		                foldStart = foldLine ? foldLine.start.row :Infinity;
		            }
		            if (row > last)
		                break;
		
		            var lineElement = lineElements[lineElementsIdx++];
		            if (lineElement) {
		                var html = [];
		                this.$renderLine(
		                    html, row, !this.$useLineGroups(), row == foldStart ? foldLine : false
		                );
		                lineElement.style.height = config.lineHeight * this.session.getRowLength(row) + "px";
		                lineElement.innerHTML = html.join("");
		            }
		            row++;
		        }
		    };
		
		    this.scrollLines = function(config) {
		        var oldConfig = this.config;
		        this.config = config;
		
		        if (!oldConfig || oldConfig.lastRow < config.firstRow)
		            return this.update(config);
		
		        if (config.lastRow < oldConfig.firstRow)
		            return this.update(config);
		
		        var el = this.element;
		        if (oldConfig.firstRow < config.firstRow)
		            for (var row=this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row>0; row--)
		                el.removeChild(el.firstChild);
		
		        if (oldConfig.lastRow > config.lastRow)
		            for (var row=this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row>0; row--)
		                el.removeChild(el.lastChild);
		
		        if (config.firstRow < oldConfig.firstRow) {
		            var fragment = this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1);
		            if (el.firstChild)
		                el.insertBefore(fragment, el.firstChild);
		            else
		                el.appendChild(fragment);
		        }
		
		        if (config.lastRow > oldConfig.lastRow) {
		            var fragment = this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow);
		            el.appendChild(fragment);
		        }
		    };
		
		    this.$renderLinesFragment = function(config, firstRow, lastRow) {
		        var fragment = this.element.ownerDocument.createDocumentFragment();
		        var row = firstRow;
		        var foldLine = this.session.getNextFoldLine(row);
		        var foldStart = foldLine ? foldLine.start.row : Infinity;
		
		        while (true) {
		            if (row > foldStart) {
		                row = foldLine.end.row+1;
		                foldLine = this.session.getNextFoldLine(row, foldLine);
		                foldStart = foldLine ? foldLine.start.row : Infinity;
		            }
		            if (row > lastRow)
		                break;
		
		            var container = dom.createElement("div");
		
		            var html = [];
		            // Get the tokens per line as there might be some lines in between
		            // beeing folded.
		            this.$renderLine(html, row, false, row == foldStart ? foldLine : false);
		
		            // don't use setInnerHtml since we are working with an empty DIV
		            container.innerHTML = html.join("");
		            if (this.$useLineGroups()) {
		                container.className = 'ace_line_group';
		                fragment.appendChild(container);
		                container.style.height = config.lineHeight * this.session.getRowLength(row) + "px";
		
		            } else {
		                while(container.firstChild)
		                    fragment.appendChild(container.firstChild);
		            }
		
		            row++;
		        }
		        return fragment;
		    };
		
		    this.update = function(config) {
		        this.config = config;
		
		        var html = [];
		        var firstRow = config.firstRow, lastRow = config.lastRow;
		
		        var row = firstRow;
		        var foldLine = this.session.getNextFoldLine(row);
		        var foldStart = foldLine ? foldLine.start.row : Infinity;
		
		        while (true) {
		            if (row > foldStart) {
		                row = foldLine.end.row+1;
		                foldLine = this.session.getNextFoldLine(row, foldLine);
		                foldStart = foldLine ? foldLine.start.row :Infinity;
		            }
		            if (row > lastRow)
		                break;
		
		            if (this.$useLineGroups())
		                html.push("<div class='ace_line_group' style='height:", config.lineHeight*this.session.getRowLength(row), "px'>")
		
		            this.$renderLine(html, row, false, row == foldStart ? foldLine : false);
		
		            if (this.$useLineGroups())
		                html.push("</div>"); // end the line group
		
		            row++;
		        }
		        this.element.innerHTML = html.join("");
		    };
		
		    this.$textToken = {
		        "text": true,
		        "rparen": true,
		        "lparen": true
		    };
		
		    this.$renderToken = function(stringBuilder, screenColumn, token, value) {
		        var self = this;
		        var replaceReg = /\t|&|<|>|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\u3000\uFEFF\uFFF9-\uFFFC])|[\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3000-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]/g;
		        var replaceFunc = function(c, a, b, tabIdx, idx4) {
		            if (a) {
		                return self.showInvisibles
		                    ? "<span class='ace_invisible ace_invisible_space'>" + lang.stringRepeat(self.SPACE_CHAR, c.length) + "</span>"
		                    : c;
		            } else if (c == "&") {
		                return "&#38;";
		            } else if (c == "<") {
		                return "&#60;";
		            } else if (c == ">") {
		                // normally escaping this is not needed, but xml documents throw error when setting innerHTML to ]]>
		                return "&#62;";
		            } else if (c == "\t") {
		                var tabSize = self.session.getScreenTabSize(screenColumn + tabIdx);
		                screenColumn += tabSize - 1;
		                return self.$tabStrings[tabSize];
		            } else if (c == "\u3000") {
		                // U+3000 is both invisible AND full-width, so must be handled uniquely
		                var classToUse = self.showInvisibles ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk";
		                var space = self.showInvisibles ? self.SPACE_CHAR : "";
		                screenColumn += 1;
		                return "<span class='" + classToUse + "' style='width:" +
		                    (self.config.characterWidth * 2) +
		                    "px'>" + space + "</span>";
		            } else if (b) {
		                return "<span class='ace_invisible ace_invisible_space ace_invalid'>" + self.SPACE_CHAR + "</span>";
		            } else {
		                screenColumn += 1;
		                return "<span class='ace_cjk' style='width:" +
		                    (self.config.characterWidth * 2) +
		                    "px'>" + c + "</span>";
		            }
		        };
		
		        var output = value.replace(replaceReg, replaceFunc);
		
		        if (!this.$textToken[token.type]) {
		            var classes = "ace_" + token.type.replace(/\./g, " ace_");
		            var style = "";
		            if (token.type == "fold")
		                style = " style='width:" + (token.value.length * this.config.characterWidth) + "px;' ";
		            stringBuilder.push("<span class='", classes, "'", style, ">", output, "</span>");
		        }
		        else {
		            stringBuilder.push(output);
		        }
		        return screenColumn + value.length;
		    };
		
		    this.renderIndentGuide = function(stringBuilder, value, max) {
		        var cols = value.search(this.$indentGuideRe);
		        if (cols <= 0 || cols >= max)
		            return value;
		        if (value[0] == " ") {
		            cols -= cols % this.tabSize;
		            stringBuilder.push(lang.stringRepeat(this.$tabStrings[" "], cols/this.tabSize));
		            return value.substr(cols);
		        } else if (value[0] == "\t") {
		            stringBuilder.push(lang.stringRepeat(this.$tabStrings["\t"], cols));
		            return value.substr(cols);
		        }
		        return value;
		    };
		
		    this.$renderWrappedLine = function(stringBuilder, tokens, splits, onlyContents) {
		        var chars = 0;
		        var split = 0;
		        var splitChars = splits[0];
		        var screenColumn = 0;
		
		        for (var i = 0; i < tokens.length; i++) {
		            var token = tokens[i];
		            var value = token.value;
		            if (i == 0 && this.displayIndentGuides) {
		                chars = value.length;
		                value = this.renderIndentGuide(stringBuilder, value, splitChars);
		                if (!value)
		                    continue;
		                chars -= value.length;
		            }
		
		            if (chars + value.length < splitChars) {
		                screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
		                chars += value.length;
		            } else {
		                while (chars + value.length >= splitChars) {
		                    screenColumn = this.$renderToken(
		                        stringBuilder, screenColumn,
		                        token, value.substring(0, splitChars - chars)
		                    );
		                    value = value.substring(splitChars - chars);
		                    chars = splitChars;
		
		                    if (!onlyContents) {
		                        stringBuilder.push("</div>",
		                            "<div class='ace_line' style='height:",
		                            this.config.lineHeight, "px'>"
		                        );
		                    }
		
		                    stringBuilder.push(lang.stringRepeat("\xa0", splits.indent));
		
		                    split ++;
		                    screenColumn = 0;
		                    splitChars = splits[split] || Number.MAX_VALUE;
		                }
		                if (value.length != 0) {
		                    chars += value.length;
		                    screenColumn = this.$renderToken(
		                        stringBuilder, screenColumn, token, value
		                    );
		                }
		            }
		        }
		    };
		
		    this.$renderSimpleLine = function(stringBuilder, tokens) {
		        var screenColumn = 0;
		        var token = tokens[0];
		        var value = token.value;
		        if (this.displayIndentGuides)
		            value = this.renderIndentGuide(stringBuilder, value);
		        if (value)
		            screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
		        for (var i = 1; i < tokens.length; i++) {
		            token = tokens[i];
		            value = token.value;
		            screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
		        }
		    };
		
		    // row is either first row of foldline or not in fold
		    this.$renderLine = function(stringBuilder, row, onlyContents, foldLine) {
		        if (!foldLine && foldLine != false)
		            foldLine = this.session.getFoldLine(row);
		
		        if (foldLine)
		            var tokens = this.$getFoldLineTokens(row, foldLine);
		        else
		            var tokens = this.session.getTokens(row);
		
		
		        if (!onlyContents) {
		            stringBuilder.push(
		                "<div class='ace_line' style='height:", 
		                    this.config.lineHeight * (
		                        this.$useLineGroups() ? 1 :this.session.getRowLength(row)
		                    ), "px'>"
		            );
		        }
		
		        if (tokens.length) {
		            var splits = this.session.getRowSplitData(row);
		            if (splits && splits.length)
		                this.$renderWrappedLine(stringBuilder, tokens, splits, onlyContents);
		            else
		                this.$renderSimpleLine(stringBuilder, tokens);
		        }
		
		        if (this.showInvisibles) {
		            if (foldLine)
		                row = foldLine.end.row
		
		            stringBuilder.push(
		                "<span class='ace_invisible ace_invisible_eol'>",
		                row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR,
		                "</span>"
		            );
		        }
		        if (!onlyContents)
		            stringBuilder.push("</div>");
		    };
		
		    this.$getFoldLineTokens = function(row, foldLine) {
		        var session = this.session;
		        var renderTokens = [];
		
		        function addTokens(tokens, from, to) {
		            var idx = 0, col = 0;
		            while ((col + tokens[idx].value.length) < from) {
		                col += tokens[idx].value.length;
		                idx++;
		
		                if (idx == tokens.length)
		                    return;
		            }
		            if (col != from) {
		                var value = tokens[idx].value.substring(from - col);
		                // Check if the token value is longer then the from...to spacing.
		                if (value.length > (to - from))
		                    value = value.substring(0, to - from);
		
		                renderTokens.push({
		                    type: tokens[idx].type,
		                    value: value
		                });
		
		                col = from + value.length;
		                idx += 1;
		            }
		
		            while (col < to && idx < tokens.length) {
		                var value = tokens[idx].value;
		                if (value.length + col > to) {
		                    renderTokens.push({
		                        type: tokens[idx].type,
		                        value: value.substring(0, to - col)
		                    });
		                } else
		                    renderTokens.push(tokens[idx]);
		                col += value.length;
		                idx += 1;
		            }
		        }
		
		        var tokens = session.getTokens(row);
		        foldLine.walk(function(placeholder, row, column, lastColumn, isNewRow) {
		            if (placeholder != null) {
		                renderTokens.push({
		                    type: "fold",
		                    value: placeholder
		                });
		            } else {
		                if (isNewRow)
		                    tokens = session.getTokens(row);
		
		                if (tokens.length)
		                    addTokens(tokens, lastColumn, column);
		            }
		        }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);
		
		        return renderTokens;
		    };
		
		    this.$useLineGroups = function() {
		        // For the updateLines function to work correctly, it's important that the
		        // child nodes of this.element correspond on a 1-to-1 basis to rows in the
		        // document (as distinct from lines on the screen). For sessions that are
		        // wrapped, this means we need to add a layer to the node hierarchy (tagged
		        // with the class name ace_line_group).
		        return this.session.getUseWrapMode();
		    };
		
		    this.destroy = function() {
		        clearInterval(this.$pollSizeChangesTimer);
		        if (this.$measureNode)
		            this.$measureNode.parentNode.removeChild(this.$measureNode);
		        delete this.$measureNode;
		    };
		
		}).call(Text.prototype);
		
		exports.Text = Text;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/lib/app_config.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		
		var oop = require("./oop");
		var EventEmitter = require("./event_emitter").EventEmitter;
		
		var optionsProvider = {
		    setOptions: function(optList) {
		        Object.keys(optList).forEach(function(key) {
		            this.setOption(key, optList[key]);
		        }, this);
		    },
		    getOptions: function(optionNames) {
		        var result = {};
		        if (!optionNames) {
		            optionNames = Object.keys(this.$options);
		        } else if (!Array.isArray(optionNames)) {
		            result = optionNames;
		            optionNames = Object.keys(result);
		        }
		        optionNames.forEach(function(key) {
		            result[key] = this.getOption(key);
		        }, this);
		        return result;
		    },
		    setOption: function(name, value) {
		        if (this["$" + name] === value)
		            return;
		        var opt = this.$options[name];
		        if (!opt) {
		            return warn('misspelled option "' + name + '"');
		        }
		        if (opt.forwardTo)
		            return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);
		
		        if (!opt.handlesSet)
		            this["$" + name] = value;
		        if (opt && opt.set)
		            opt.set.call(this, value);
		    },
		    getOption: function(name) {
		        var opt = this.$options[name];
		        if (!opt) {
		            return warn('misspelled option "' + name + '"');
		        }
		        if (opt.forwardTo)
		            return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
		        return opt && opt.get ? opt.get.call(this) : this["$" + name];
		    }
		};
		
		function warn(message) {
		    if (typeof console != "undefined" && console.warn)
		        console.warn.apply(console, arguments);
		}
		
		function reportError(msg, data) {
		    var e = new Error(msg);
		    e.data = data;
		    if (typeof console == "object" && console.error)
		        console.error(e);
		    setTimeout(function() { throw e; });
		}
		
		var AppConfig = function() {
		    this.$defaultOptions = {};
		};
		
		(function() {
		    // module loading
		    oop.implement(this, EventEmitter);
		    /*
		     * option {name, value, initialValue, setterName, set, get }
		     */
		    this.defineOptions = function(obj, path, options) {
		        if (!obj.$options)
		            this.$defaultOptions[path] = obj.$options = {};
		
		        Object.keys(options).forEach(function(key) {
		            var opt = options[key];
		            if (typeof opt == "string")
		                opt = {forwardTo: opt};
		
		            opt.name || (opt.name = key);
		            obj.$options[opt.name] = opt;
		            if ("initialValue" in opt)
		                obj["$" + opt.name] = opt.initialValue;
		        });
		
		        // implement option provider interface
		        oop.implement(obj, optionsProvider);
		
		        return this;
		    };
		
		    this.resetOptions = function(obj) {
		        Object.keys(obj.$options).forEach(function(key) {
		            var opt = obj.$options[key];
		            if ("value" in opt)
		                obj.setOption(key, opt.value);
		        });
		    };
		
		    this.setDefaultValue = function(path, name, value) {
		        var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});
		        if (opts[name]) {
		            if (opts.forwardTo)
		                this.setDefaultValue(opts.forwardTo, name, value);
		            else
		                opts[name].value = value;
		        }
		    };
		
		    this.setDefaultValues = function(path, optionHash) {
		        Object.keys(optionHash).forEach(function(key) {
		            this.setDefaultValue(path, key, optionHash[key]);
		        }, this);
		    };
		    
		    this.warn = warn;
		    this.reportError = reportError;
		    
		}).call(AppConfig.prototype);
		
		exports.AppConfig = AppConfig;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/lib/bidiutil.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var ArabicAlefBetIntervalsBegine = ['\u0621', '\u0641'];
		var ArabicAlefBetIntervalsEnd = ['\u063A', '\u064a'];
		var dir = 0, hiLevel = 0;
		var lastArabic = false, hasUBAT_AL = false,  hasUBAT_B = false,  hasUBAT_S = false, hasBlockSep = false, hasSegSep = false;
		
		var impTab_LTR = [
						/*		L,		R,		EN,		AN,		N,		IL,		Cond */
		/* 0 LTR text	*/	[	0,		3,		0,		1,		0,		0,		0	],
		/* 1 LTR+AN		*/	[	0,		3,		0,		1,		2,		2,		0	],
		/* 2 LTR+AN+N	*/	[	0,		3,		0,		0x11,		2,		0,		1	],
		/* 3 RTL text	*/	[	0,		3,		5,		5,		4,		1,		0	],
		/* 4 RTL cont	*/	[	0,		3,		0x15,		0x15,		4,		0,		1	],
		/* 5 RTL+EN/AN	*/	[	0,		3,		5,		5,		4,		2,		0	]
		];
		
		var impTab_RTL = [
				/*		L,		R,		EN,		AN,		N,		IL,		Cond */
		/* 0 RTL text	*/	[	2,		0,		1,		1,		0,		1,		0	],
		/* 1 RTL+EN/AN	*/	[	2,		0,		1,		1,		0,		2,		0	],
		/* 2 LTR text	*/	[	2,		0,		2,		1,		3,		2,		0	],
		/* 3 LTR+cont	*/	[	2,		0,		2,		0x21,		3,		1,		1	]
		];
		
		var LTR = 0, RTL = 1;
		
		var L = 0; /* left to right */
		var R = 1; /* right to left */
		var EN = 2; /* European digit */
		var AN = 3; /* Arabic-Indic digit */
		var ON = 4; /* neutral */
		var B = 5; /* block separator */
		var S = 6; /* segment separator */
		var AL = 7; /* Arabic Letter */
		var WS = 8; /* white space */
		var CS = 9; /* common digit separator */
		var ES = 10; /* European digit separator */
		var ET = 11; /* European digit terminator */
		var NSM = 12; /* Non Spacing Mark */
		var LRE = 13; /* LRE */
		var RLE = 14; /* RLE */
		var PDF = 15; /* PDF */
		var LRO = 16; /* LRO */
		var RLO = 17; /* RLO */
		var BN = 18; /* Boundary Neutral */
		
		var UnicodeTBL00 = [
		BN,BN,BN,BN,BN,BN,BN,BN,BN,S,B,S,WS,B,BN,BN,
		BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,B,B,B,S,
		WS,ON,ON,ET,ET,ET,ON,ON,ON,ON,ON,ES,CS,ES,CS,CS,
		EN,EN,EN,EN,EN,EN,EN,EN,EN,EN,CS,ON,ON,ON,ON,ON,
		ON,L,L,L,L,L,L,L,L,L,L,L,L,L,L,L,
		L,L,L,L,L,L,L,L,L,L,L,ON,ON,ON,ON,ON,
		ON,L,L,L,L,L,L,L,L,L,L,L,L,L,L,L,
		L,L,L,L,L,L,L,L,L,L,L,ON,ON,ON,ON,BN,
		BN,BN,BN,BN,BN,B,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,
		BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,
		CS,ON,ET,ET,ET,ET,ON,ON,ON,ON,L,ON,ON,BN,ON,ON,
		ET,ET,EN,EN,ON,L,ON,ON,ON,EN,L,ON,ON,ON,ON,ON
		];
		
		var UnicodeTBL20 = [
		WS,WS,WS,WS,WS,WS,WS,WS,WS,WS,WS,BN,BN,BN,L,R	,
		ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,
		ON,ON,ON,ON,ON,ON,ON,ON,WS,B,LRE,RLE,PDF,LRO,RLO,CS,
		ET,ET,ET,ET,ET,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,
		ON,ON,ON,ON,CS,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,
		ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,WS
		];
		
		function _computeLevels(chars, levels, len, charTypes) {
			var impTab = dir ? impTab_RTL : impTab_LTR
				, prevState = null, newClass = null, newLevel = null, newState = 0
				, action = null, cond = null, condPos = -1, i = null, ix = null, classes = [];
		
			if (!charTypes) {
				for (i = 0, charTypes = []; i < len; i++) {
					charTypes[i] = _getCharacterType(chars[i]);
				}
			}
			hiLevel = dir;
			lastArabic = false;
			hasUBAT_AL = false;
			hasUBAT_B = false;
			hasUBAT_S = false;
			for (ix = 0; ix < len; ix++){
				prevState = newState;
				classes[ix] = newClass = _getCharClass(chars, charTypes, classes, ix);
				newState = impTab[prevState][newClass];
				action = newState & 0xF0;
				newState &= 0x0F;
				levels[ix] = newLevel = impTab[newState][5];
				if (action > 0){
					if (action == 0x10){
						for(i = condPos; i < ix; i++){
							levels[i] = 1;
						}
						condPos = -1;
					} else {
						condPos = -1;
					}
				}
				cond = impTab[newState][6];
				if (cond){
					if(condPos == -1){
						condPos = ix;
					}
				}else{
					if (condPos > -1){
						for(i = condPos; i < ix; i++){
							levels[i] = newLevel;
						}
						condPos = -1;
					}
				}
				if (charTypes[ix] == B){
					levels[ix] = 0;
				}
				hiLevel |= newLevel;
			}
			if (hasUBAT_S){
				for(i = 0; i < len; i++){
					if(charTypes[i] == S){
						levels[i] = dir;
						for(var j = i - 1; j >= 0; j--){
							if(charTypes[j] == WS){
								levels[j] = dir;
							}else{
								break;
							}
						}
					}
				}
			}
		}
		
		function _invertLevel(lev, levels, _array) {
			if (hiLevel < lev){
				return;
			}
			if (lev == 1 && dir == RTL && !hasUBAT_B){
				_array.reverse();
				return;
			}
			var len = _array.length, start = 0, end, lo, hi, tmp;
			while(start < len){
				if (levels[start] >= lev){
					end = start + 1;
				while(end < len && levels[end] >= lev){
					end++;
				}
				for(lo = start, hi = end - 1 ; lo < hi; lo++, hi--){
					tmp = _array[lo];
					_array[lo] = _array[hi];
					_array[hi] = tmp;
				}
				start = end;
			}
			start++;
			}
		}
		
		function _getCharClass(chars, types, classes, ix) {			
			var cType = types[ix], wType, nType, len, i;
			switch(cType){
				case L:
				case R:
					lastArabic = false;
				case ON:
				case AN:
					return cType;
				case EN:
					return lastArabic ? AN : EN;
				case AL:
					lastArabic = true;
					hasUBAT_AL = true;
					return R;
				case WS:
					return ON;
				case CS:
					if (ix < 1 || (ix + 1) >= types.length ||
						((wType = classes[ix - 1]) != EN && wType != AN) ||
						((nType = types[ix + 1]) != EN && nType != AN)){
						return ON;
					}
					if (lastArabic){nType = AN;}
					return nType == wType ? nType : ON;
				case ES:
					wType = ix > 0 ? classes[ix - 1] : B;
					if (wType == EN && (ix + 1) < types.length && types[ix + 1] == EN){
						return EN;
					}
					return ON;
				case ET:
					if (ix > 0 && classes[ix - 1] == EN){
						return EN;
					}
					if (lastArabic){
						return ON;
					}
					i = ix + 1;
					len = types.length;
					while (i < len && types[i] == ET){
						i++;
					}
					if (i < len && types[i] == EN){
						return EN;
					}
					return ON;
				case NSM:
					len = types.length;
					i = ix + 1;
					while (i < len && types[i] == NSM){
						i++;
					}
					if (i < len){
						var c = chars[ix], rtlCandidate = (c >= 0x0591 && c <= 0x08FF) || c == 0xFB1E;
						
						wType = types[i];
						if (rtlCandidate && (wType == R || wType == AL)){
							return R;
						}
					}
		
					if (ix < 1 || (wType = types[ix - 1]) == B){
						return ON;
					}
					return classes[ix - 1];
				case B:
					lastArabic = false;
					hasUBAT_B = true;
					return dir;
				case S:
					hasUBAT_S = true;
					return ON;
				case LRE:
				case RLE:
				case LRO:
				case RLO:
				case PDF:
					lastArabic = false;
				case BN:
					return ON;
			}
		}
		
		function _getCharacterType( ch ) {		
			var uc = ch.charCodeAt(0), hi = uc >> 8;
			
			if (hi == 0) {		
				return ((uc > 0x00BF) ? L : UnicodeTBL00[uc]);
			} else if (hi == 5) {
				return (/[\u0591-\u05f4]/.test(ch) ? R : L);
			} else if (hi == 6) {
				if (/[\u0610-\u061a\u064b-\u065f\u06d6-\u06e4\u06e7-\u06ed]/.test(ch))
					return NSM;
				else if (/[\u0660-\u0669\u066b-\u066c]/.test(ch))
					return AN;
				else if (uc == 0x066A)
					return ET;
				else if (/[\u06f0-\u06f9]/.test(ch))
					return EN;			
				else
					return AL;
			} else if (hi == 0x20 && uc <= 0x205F) {
				return UnicodeTBL20[uc & 0xFF];
			} else if (hi == 0xFE) {
				return (uc >= 0xFE70 ? AL : ON);
			}		
			return ON;	
		}
		
		function _isArabicDiacritics( ch ) {
			return (ch >= '\u064b' && ch <= '\u0655');
		}
		
		/* Strong LTR character (0 - even), regular width */
		exports.L = L;
		/* Strong RTL character (1 - odd), Bidi width */
		exports.R = R;
		/* European digit (2 - even), regular width */
		exports.EN = EN;
		/* Neutral RTL-by-context character (3 - odd), regular width */
		exports.ON_R = 3;
		/* Hindi (Arabic) digit (4 - even), Bidi width */
		exports.AN = 4;
		/* Arabic LamAlef (5 - odd), Half Bidi width */
		exports.R_H = 5;
		/* invisible EOL (6 - even), zero width */
		exports.B = 6;
		
		exports.DOT = "\xB7";
		
		/**
		 * Performs text reordering by implementing Unicode Bidi algorithm
		 * with aim to produce logical<->visual map and Bidi levels
		 * @param {String} text string to be reordered
		 * @param {Array} unicode character types produced by call to 'hasBidiCharacters'
		 * @param {Boolean} 'true' for right-to-left text direction, otherwise 'false'
		 *
		 * @return {Object} An object containing logicalFromVisual map and Bidi levels
		 **/
		exports.doBidiReorder = function(text, textCharTypes, isRtl) {
			if (text.length < 2)
				return {};
				
			var chars = text.split(""), logicalFromVisual = new Array(chars.length),
				bidiLevels = new Array(chars.length), levels = []; 
		
			dir = isRtl ? RTL : LTR;
		
			_computeLevels(chars, levels, chars.length, textCharTypes);
		
			for (var i = 0; i < logicalFromVisual.length; logicalFromVisual[i] = i, i++);
		
			_invertLevel(2, levels, logicalFromVisual);
			_invertLevel(1, levels, logicalFromVisual);
		
			for (var i = 0; i < logicalFromVisual.length - 1; i++) { //fix levels to reflect character width
				if (textCharTypes[i] === AN) {
					levels[i] = exports.AN;
				} else if (levels[i] === R && ((textCharTypes[i] > AL && textCharTypes[i] < LRE) 
					|| textCharTypes[i] === ON || textCharTypes[i] === BN)) {
					levels[i] = exports.ON_R;
				} else if ((i > 0 && chars[i - 1] === '\u0644') && /\u0622|\u0623|\u0625|\u0627/.test(chars[i])) {
					levels[i - 1] = levels[i] = exports.R_H;
					i++;
				}
			}
			/* fix level to mark zero length EOL */
			if (chars[chars.length - 1] === exports.DOT)
				levels[chars.length - 1] = exports.B;
						
			for (var i = 0; i < logicalFromVisual.length; i++) {
				bidiLevels[i] = levels[logicalFromVisual[i]];
			}
		
			return {'logicalFromVisual': logicalFromVisual, 'bidiLevels': bidiLevels};
		};	
		
		/**
		 * Performs character classification, to be used in Unicode Bidi algorithm.
		 * @param {String} text string to be reordered
		 * @param {Array} unicode character types (to be filled by this method)
		 *
		 * @return {Boolean} 'true' if text contains Bidi characters, otherwise 'false'
		 **/
		exports.hasBidiCharacters = function(text, textCharTypes){
			var ret = false;
			for (var i = 0; i < text.length; i++){
				textCharTypes[i] = _getCharacterType(text.charAt(i));
				if (!ret && (textCharTypes[i] == R || textCharTypes[i] == AL))
					ret = true;
			}
			return ret;
		};
		
		/**
		 * Returns visual index corresponding to logical index basing on logicalFromvisual 
		 * map provided by Unicode Bidi algorithm.
		 * @param {int} logical index of character in text buffer
		 * @param {Object} object containing logicalFromVisual map
		 *
		 * @return {int} visual index (on display) corresponding to logical index
		 **/	
		exports.getVisualFromLogicalIdx = function(logIdx, rowMap) {
			for (var i = 0; i < rowMap.logicalFromVisual.length; i++) {
				if (rowMap.logicalFromVisual[i] == logIdx)
					return i;
			}
			return 0;
		};
		
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/lib/dom.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var XHTML_NS = "http://www.w3.org/1999/xhtml";
		
		exports.getDocumentHead = function(doc) {
		    if (!doc)
		        doc = document;
		    return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
		};
		
		exports.createElement = function(tag, ns) {
		    return document.createElementNS ?
		           document.createElementNS(ns || XHTML_NS, tag) :
		           document.createElement(tag);
		};
		
		exports.hasCssClass = function(el, name) {
		    var classes = (el.className + "").split(/\s+/g);
		    return classes.indexOf(name) !== -1;
		};
		
		/*
		* Add a CSS class to the list of classes on the given node
		*/
		exports.addCssClass = function(el, name) {
		    if (!exports.hasCssClass(el, name)) {
		        el.className += " " + name;
		    }
		};
		
		/*
		* Remove a CSS class from the list of classes on the given node
		*/
		exports.removeCssClass = function(el, name) {
		    var classes = el.className.split(/\s+/g);
		    while (true) {
		        var index = classes.indexOf(name);
		        if (index == -1) {
		            break;
		        }
		        classes.splice(index, 1);
		    }
		    el.className = classes.join(" ");
		};
		
		exports.toggleCssClass = function(el, name) {
		    var classes = el.className.split(/\s+/g), add = true;
		    while (true) {
		        var index = classes.indexOf(name);
		        if (index == -1) {
		            break;
		        }
		        add = false;
		        classes.splice(index, 1);
		    }
		    if (add)
		        classes.push(name);
		
		    el.className = classes.join(" ");
		    return add;
		};
		
		
		/*
		 * Add or remove a CSS class from the list of classes on the given node
		 * depending on the value of <tt>include</tt>
		 */
		exports.setCssClass = function(node, className, include) {
		    if (include) {
		        exports.addCssClass(node, className);
		    } else {
		        exports.removeCssClass(node, className);
		    }
		};
		
		exports.hasCssString = function(id, doc) {
		    var index = 0, sheets;
		    doc = doc || document;
		
		    if (doc.createStyleSheet && (sheets = doc.styleSheets)) {
		        while (index < sheets.length)
		            if (sheets[index++].owningElement.id === id) return true;
		    } else if ((sheets = doc.getElementsByTagName("style"))) {
		        while (index < sheets.length)
		            if (sheets[index++].id === id) return true;
		    }
		
		    return false;
		};
		
		exports.importCssString = function importCssString(cssText, id, doc) {
		    doc = doc || document;
		    // If style is already imported return immediately.
		    if (id && exports.hasCssString(id, doc))
		        return null;
		    
		    var style;
		    
		    if (id)
		        cssText += "\n/*# sourceURL=ace/css/" + id + " */";
		    
		    if (doc.createStyleSheet) {
		        style = doc.createStyleSheet();
		        style.cssText = cssText;
		        if (id)
		            style.owningElement.id = id;
		    } else {
		        style = exports.createElement("style");
		        style.appendChild(doc.createTextNode(cssText));
		        if (id)
		            style.id = id;
		
		        exports.getDocumentHead(doc).appendChild(style);
		    }
		};
		
		exports.importCssStylsheet = function(uri, doc) {
		    if (doc.createStyleSheet) {
		        doc.createStyleSheet(uri);
		    } else {
		        var link = exports.createElement('link');
		        link.rel = 'stylesheet';
		        link.href = uri;
		
		        exports.getDocumentHead(doc).appendChild(link);
		    }
		};
		
		exports.getInnerWidth = function(element) {
		    return (
		        parseInt(exports.computedStyle(element, "paddingLeft"), 10) +
		        parseInt(exports.computedStyle(element, "paddingRight"), 10) + 
		        element.clientWidth
		    );
		};
		
		exports.getInnerHeight = function(element) {
		    return (
		        parseInt(exports.computedStyle(element, "paddingTop"), 10) +
		        parseInt(exports.computedStyle(element, "paddingBottom"), 10) +
		        element.clientHeight
		    );
		};
		
		exports.scrollbarWidth = function(document) {
		    var inner = exports.createElement("ace_inner");
		    inner.style.width = "100%";
		    inner.style.minWidth = "0px";
		    inner.style.height = "200px";
		    inner.style.display = "block";
		
		    var outer = exports.createElement("ace_outer");
		    var style = outer.style;
		
		    style.position = "absolute";
		    style.left = "-10000px";
		    style.overflow = "hidden";
		    style.width = "200px";
		    style.minWidth = "0px";
		    style.height = "150px";
		    style.display = "block";
		
		    outer.appendChild(inner);
		
		    var body = document.documentElement;
		    body.appendChild(outer);
		
		    var noScrollbar = inner.offsetWidth;
		
		    style.overflow = "scroll";
		    var withScrollbar = inner.offsetWidth;
		
		    if (noScrollbar == withScrollbar) {
		        withScrollbar = outer.clientWidth;
		    }
		
		    body.removeChild(outer);
		
		    return noScrollbar-withScrollbar;
		};
		
		if (typeof document == "undefined") {
		    exports.importCssString = function() {};
		    return;
		}
		
		if (window.pageYOffset !== undefined) {
		    exports.getPageScrollTop = function() {
		        return window.pageYOffset;
		    };
		
		    exports.getPageScrollLeft = function() {
		        return window.pageXOffset;
		    };
		}
		else {
		    exports.getPageScrollTop = function() {
		        return document.body.scrollTop;
		    };
		
		    exports.getPageScrollLeft = function() {
		        return document.body.scrollLeft;
		    };
		}
		
		if (window.getComputedStyle)
		    exports.computedStyle = function(element, style) {
		        if (style)
		            return (window.getComputedStyle(element, "") || {})[style] || "";
		        return window.getComputedStyle(element, "") || {};
		    };
		else
		    exports.computedStyle = function(element, style) {
		        if (style)
		            return element.currentStyle[style];
		        return element.currentStyle;
		    };
		
		/*
		 * Optimized set innerHTML. This is faster than plain innerHTML if the element
		 * already contains a lot of child elements.
		 *
		 * See http://blog.stevenlevithan.com/archives/faster-than-innerhtml for details
		 */
		exports.setInnerHtml = function(el, innerHtml) {
		    var element = el.cloneNode(false);//document.createElement("div");
		    element.innerHTML = innerHtml;
		    el.parentNode.replaceChild(element, el);
		    return element;
		};
		
		if ("textContent" in document.documentElement) {
		    exports.setInnerText = function(el, innerText) {
		        el.textContent = innerText;
		    };
		
		    exports.getInnerText = function(el) {
		        return el.textContent;
		    };
		}
		else {
		    exports.setInnerText = function(el, innerText) {
		        el.innerText = innerText;
		    };
		
		    exports.getInnerText = function(el) {
		        return el.innerText;
		    };
		}
		
		exports.getParentWindow = function(document) {
		    return document.defaultView || document.parentWindow;
		};
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/lib/es5-shim.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		/*
		 * Brings an environment as close to ECMAScript 5 compliance
		 * as is possible with the facilities of erstwhile engines.
		 *
		 * Annotated ES5: http://es5.github.com/ (specific links below)
		 * ES5 Spec: http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf
		 * Required reading: http://javascriptweblog.wordpress.com/2011/12/05/extending-javascript-natives/
		 */
		
		//
		// Function
		// ========
		//
		
		// ES-5 15.3.4.5
		// http://es5.github.com/#x15.3.4.5
		
		function Empty() {}
		
		if (!Function.prototype.bind) {
		    Function.prototype.bind = function bind(that) { // .length is 1
		        // 1. Let Target be the this value.
		        var target = this;
		        // 2. If IsCallable(Target) is false, throw a TypeError exception.
		        if (typeof target != "function") {
		            throw new TypeError("Function.prototype.bind called on incompatible " + target);
		        }
		        // 3. Let A be a new (possibly empty) internal list of all of the
		        //   argument values provided after thisArg (arg1, arg2 etc), in order.
		        // XXX slicedArgs will stand in for "A" if used
		        var args = slice.call(arguments, 1); // for normal call
		        // 4. Let F be a new native ECMAScript object.
		        // 11. Set the [[Prototype]] internal property of F to the standard
		        //   built-in Function prototype object as specified in 15.3.3.1.
		        // 12. Set the [[Call]] internal property of F as described in
		        //   15.3.4.5.1.
		        // 13. Set the [[Construct]] internal property of F as described in
		        //   15.3.4.5.2.
		        // 14. Set the [[HasInstance]] internal property of F as described in
		        //   15.3.4.5.3.
		        var bound = function () {
		
		            if (this instanceof bound) {
		                // 15.3.4.5.2 [[Construct]]
		                // When the [[Construct]] internal method of a function object,
		                // F that was created using the bind function is called with a
		                // list of arguments ExtraArgs, the following steps are taken:
		                // 1. Let target be the value of F's [[TargetFunction]]
		                //   internal property.
		                // 2. If target has no [[Construct]] internal method, a
		                //   TypeError exception is thrown.
		                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
		                //   property.
		                // 4. Let args be a new list containing the same values as the
		                //   list boundArgs in the same order followed by the same
		                //   values as the list ExtraArgs in the same order.
		                // 5. Return the result of calling the [[Construct]] internal
		                //   method of target providing args as the arguments.
		
		                var result = target.apply(
		                    this,
		                    args.concat(slice.call(arguments))
		                );
		                if (Object(result) === result) {
		                    return result;
		                }
		                return this;
		
		            } else {
		                // 15.3.4.5.1 [[Call]]
		                // When the [[Call]] internal method of a function object, F,
		                // which was created using the bind function is called with a
		                // this value and a list of arguments ExtraArgs, the following
		                // steps are taken:
		                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
		                //   property.
		                // 2. Let boundThis be the value of F's [[BoundThis]] internal
		                //   property.
		                // 3. Let target be the value of F's [[TargetFunction]] internal
		                //   property.
		                // 4. Let args be a new list containing the same values as the
		                //   list boundArgs in the same order followed by the same
		                //   values as the list ExtraArgs in the same order.
		                // 5. Return the result of calling the [[Call]] internal method
		                //   of target providing boundThis as the this value and
		                //   providing args as the arguments.
		
		                // equiv: target.call(this, ...boundArgs, ...args)
		                return target.apply(
		                    that,
		                    args.concat(slice.call(arguments))
		                );
		
		            }
		
		        };
		        if(target.prototype) {
		            Empty.prototype = target.prototype;
		            bound.prototype = new Empty();
		            // Clean up dangling references.
		            Empty.prototype = null;
		        }
		        // XXX bound.length is never writable, so don't even try
		        //
		        // 15. If the [[Class]] internal property of Target is "Function", then
		        //     a. Let L be the length property of Target minus the length of A.
		        //     b. Set the length own property of F to either 0 or L, whichever is
		        //       larger.
		        // 16. Else set the length own property of F to 0.
		        // 17. Set the attributes of the length own property of F to the values
		        //   specified in 15.3.5.1.
		
		        // TODO
		        // 18. Set the [[Extensible]] internal property of F to true.
		
		        // TODO
		        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
		        // 20. Call the [[DefineOwnProperty]] internal method of F with
		        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
		        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
		        //   false.
		        // 21. Call the [[DefineOwnProperty]] internal method of F with
		        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
		        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
		        //   and false.
		
		        // TODO
		        // NOTE Function objects created using Function.prototype.bind do not
		        // have a prototype property or the [[Code]], [[FormalParameters]], and
		        // [[Scope]] internal properties.
		        // XXX can't delete prototype in pure-js.
		
		        // 22. Return F.
		        return bound;
		    };
		}
		
		// Shortcut to an often accessed properties, in order to avoid multiple
		// dereference that costs universally.
		// _Please note: Shortcuts are defined after `Function.prototype.bind` as we
		// us it in defining shortcuts.
		var call = Function.prototype.call;
		var prototypeOfArray = Array.prototype;
		var prototypeOfObject = Object.prototype;
		var slice = prototypeOfArray.slice;
		// Having a toString local variable name breaks in Opera so use _toString.
		var _toString = call.bind(prototypeOfObject.toString);
		var owns = call.bind(prototypeOfObject.hasOwnProperty);
		
		// If JS engine supports accessors creating shortcuts.
		var defineGetter;
		var defineSetter;
		var lookupGetter;
		var lookupSetter;
		var supportsAccessors;
		if ((supportsAccessors = owns(prototypeOfObject, "__defineGetter__"))) {
		    defineGetter = call.bind(prototypeOfObject.__defineGetter__);
		    defineSetter = call.bind(prototypeOfObject.__defineSetter__);
		    lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
		    lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
		}
		
		//
		// Array
		// =====
		//
		
		// ES5 15.4.4.12
		// http://es5.github.com/#x15.4.4.12
		// Default value for second param
		// [bugfix, ielt9, old browsers]
		// IE < 9 bug: [1,2].splice(0).join("") == "" but should be "12"
		if ([1,2].splice(0).length != 2) {
		    if(function() { // test IE < 9 to splice bug - see issue #138
		        function makeArray(l) {
		            var a = new Array(l+2);
		            a[0] = a[1] = 0;
		            return a;
		        }
		        var array = [], lengthBefore;
		        
		        array.splice.apply(array, makeArray(20));
		        array.splice.apply(array, makeArray(26));
		
		        lengthBefore = array.length; //46
		        array.splice(5, 0, "XXX"); // add one element
		
		        lengthBefore + 1 == array.length
		
		        if (lengthBefore + 1 == array.length) {
		            return true;// has right splice implementation without bugs
		        }
		        // else {
		        // IE8 bug
		        // }
		    }()) {//IE 6/7
		        var array_splice = Array.prototype.splice;
		        Array.prototype.splice = function(start, deleteCount) {
		            if (!arguments.length) {
		                return [];
		            } else {
		                return array_splice.apply(this, [
		                    start === void 0 ? 0 : start,
		                    deleteCount === void 0 ? (this.length - start) : deleteCount
		                ].concat(slice.call(arguments, 2)))
		            }
		        };
		    } else {//IE8
		        // taken from http://docs.sencha.com/ext-js/4-1/source/Array2.html
		        Array.prototype.splice = function(pos, removeCount){
		            var length = this.length;
		            if (pos > 0) {
		                if (pos > length)
		                    pos = length;
		            } else if (pos == void 0) {
		                pos = 0;
		            } else if (pos < 0) {
		                pos = Math.max(length + pos, 0);
		            }
		
		            if (!(pos+removeCount < length))
		                removeCount = length - pos;
		
		            var removed = this.slice(pos, pos+removeCount);
		            var insert = slice.call(arguments, 2);
		            var add = insert.length;            
		
		            // we try to use Array.push when we can for efficiency...
		            if (pos === length) {
		                if (add) {
		                    this.push.apply(this, insert);
		                }
		            } else {
		                var remove = Math.min(removeCount, length - pos);
		                var tailOldPos = pos + remove;
		                var tailNewPos = tailOldPos + add - remove;
		                var tailCount = length - tailOldPos;
		                var lengthAfterRemove = length - remove;
		
		                if (tailNewPos < tailOldPos) { // case A
		                    for (var i = 0; i < tailCount; ++i) {
		                        this[tailNewPos+i] = this[tailOldPos+i];
		                    }
		                } else if (tailNewPos > tailOldPos) { // case B
		                    for (i = tailCount; i--; ) {
		                        this[tailNewPos+i] = this[tailOldPos+i];
		                    }
		                } // else, add == remove (nothing to do)
		
		                if (add && pos === lengthAfterRemove) {
		                    this.length = lengthAfterRemove; // truncate array
		                    this.push.apply(this, insert);
		                } else {
		                    this.length = lengthAfterRemove + add; // reserves space
		                    for (i = 0; i < add; ++i) {
		                        this[pos+i] = insert[i];
		                    }
		                }
		            }
		            return removed;
		        };
		    }
		}
		
		// ES5 15.4.3.2
		// http://es5.github.com/#x15.4.3.2
		// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
		if (!Array.isArray) {
		    Array.isArray = function isArray(obj) {
		        return _toString(obj) == "[object Array]";
		    };
		}
		
		// The IsCallable() check in the Array functions
		// has been replaced with a strict check on the
		// internal class of the object to trap cases where
		// the provided function was actually a regular
		// expression literal, which in V8 and
		// JavaScriptCore is a typeof "function".  Only in
		// V8 are regular expression literals permitted as
		// reduce parameters, so it is desirable in the
		// general case for the shim to match the more
		// strict and common behavior of rejecting regular
		// expressions.
		
		// ES5 15.4.4.18
		// http://es5.github.com/#x15.4.4.18
		// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/forEach
		
		// Check failure of by-index access of string characters (IE < 9)
		// and failure of `0 in boxedString` (Rhino)
		var boxedString = Object("a"),
		    splitString = boxedString[0] != "a" || !(0 in boxedString);
		
		if (!Array.prototype.forEach) {
		    Array.prototype.forEach = function forEach(fun /*, thisp*/) {
		        var object = toObject(this),
		            self = splitString && _toString(this) == "[object String]" ?
		                this.split("") :
		                object,
		            thisp = arguments[1],
		            i = -1,
		            length = self.length >>> 0;
		
		        // If no callback function or if callback is not a callable function
		        if (_toString(fun) != "[object Function]") {
		            throw new TypeError(); // TODO message
		        }
		
		        while (++i < length) {
		            if (i in self) {
		                // Invoke the callback function with call, passing arguments:
		                // context, property value, property key, thisArg object
		                // context
		                fun.call(thisp, self[i], i, object);
		            }
		        }
		    };
		}
		
		// ES5 15.4.4.19
		// http://es5.github.com/#x15.4.4.19
		// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
		if (!Array.prototype.map) {
		    Array.prototype.map = function map(fun /*, thisp*/) {
		        var object = toObject(this),
		            self = splitString && _toString(this) == "[object String]" ?
		                this.split("") :
		                object,
		            length = self.length >>> 0,
		            result = Array(length),
		            thisp = arguments[1];
		
		        // If no callback function or if callback is not a callable function
		        if (_toString(fun) != "[object Function]") {
		            throw new TypeError(fun + " is not a function");
		        }
		
		        for (var i = 0; i < length; i++) {
		            if (i in self)
		                result[i] = fun.call(thisp, self[i], i, object);
		        }
		        return result;
		    };
		}
		
		// ES5 15.4.4.20
		// http://es5.github.com/#x15.4.4.20
		// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
		if (!Array.prototype.filter) {
		    Array.prototype.filter = function filter(fun /*, thisp */) {
		        var object = toObject(this),
		            self = splitString && _toString(this) == "[object String]" ?
		                this.split("") :
		                    object,
		            length = self.length >>> 0,
		            result = [],
		            value,
		            thisp = arguments[1];
		
		        // If no callback function or if callback is not a callable function
		        if (_toString(fun) != "[object Function]") {
		            throw new TypeError(fun + " is not a function");
		        }
		
		        for (var i = 0; i < length; i++) {
		            if (i in self) {
		                value = self[i];
		                if (fun.call(thisp, value, i, object)) {
		                    result.push(value);
		                }
		            }
		        }
		        return result;
		    };
		}
		
		// ES5 15.4.4.16
		// http://es5.github.com/#x15.4.4.16
		// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every
		if (!Array.prototype.every) {
		    Array.prototype.every = function every(fun /*, thisp */) {
		        var object = toObject(this),
		            self = splitString && _toString(this) == "[object String]" ?
		                this.split("") :
		                object,
		            length = self.length >>> 0,
		            thisp = arguments[1];
		
		        // If no callback function or if callback is not a callable function
		        if (_toString(fun) != "[object Function]") {
		            throw new TypeError(fun + " is not a function");
		        }
		
		        for (var i = 0; i < length; i++) {
		            if (i in self && !fun.call(thisp, self[i], i, object)) {
		                return false;
		            }
		        }
		        return true;
		    };
		}
		
		// ES5 15.4.4.17
		// http://es5.github.com/#x15.4.4.17
		// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some
		if (!Array.prototype.some) {
		    Array.prototype.some = function some(fun /*, thisp */) {
		        var object = toObject(this),
		            self = splitString && _toString(this) == "[object String]" ?
		                this.split("") :
		                object,
		            length = self.length >>> 0,
		            thisp = arguments[1];
		
		        // If no callback function or if callback is not a callable function
		        if (_toString(fun) != "[object Function]") {
		            throw new TypeError(fun + " is not a function");
		        }
		
		        for (var i = 0; i < length; i++) {
		            if (i in self && fun.call(thisp, self[i], i, object)) {
		                return true;
		            }
		        }
		        return false;
		    };
		}
		
		// ES5 15.4.4.21
		// http://es5.github.com/#x15.4.4.21
		// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduce
		if (!Array.prototype.reduce) {
		    Array.prototype.reduce = function reduce(fun /*, initial*/) {
		        var object = toObject(this),
		            self = splitString && _toString(this) == "[object String]" ?
		                this.split("") :
		                object,
		            length = self.length >>> 0;
		
		        // If no callback function or if callback is not a callable function
		        if (_toString(fun) != "[object Function]") {
		            throw new TypeError(fun + " is not a function");
		        }
		
		        // no value to return if no initial value and an empty array
		        if (!length && arguments.length == 1) {
		            throw new TypeError("reduce of empty array with no initial value");
		        }
		
		        var i = 0;
		        var result;
		        if (arguments.length >= 2) {
		            result = arguments[1];
		        } else {
		            do {
		                if (i in self) {
		                    result = self[i++];
		                    break;
		                }
		
		                // if array contains no values, no initial value to return
		                if (++i >= length) {
		                    throw new TypeError("reduce of empty array with no initial value");
		                }
		            } while (true);
		        }
		
		        for (; i < length; i++) {
		            if (i in self) {
		                result = fun.call(void 0, result, self[i], i, object);
		            }
		        }
		
		        return result;
		    };
		}
		
		// ES5 15.4.4.22
		// http://es5.github.com/#x15.4.4.22
		// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduceRight
		if (!Array.prototype.reduceRight) {
		    Array.prototype.reduceRight = function reduceRight(fun /*, initial*/) {
		        var object = toObject(this),
		            self = splitString && _toString(this) == "[object String]" ?
		                this.split("") :
		                object,
		            length = self.length >>> 0;
		
		        // If no callback function or if callback is not a callable function
		        if (_toString(fun) != "[object Function]") {
		            throw new TypeError(fun + " is not a function");
		        }
		
		        // no value to return if no initial value, empty array
		        if (!length && arguments.length == 1) {
		            throw new TypeError("reduceRight of empty array with no initial value");
		        }
		
		        var result, i = length - 1;
		        if (arguments.length >= 2) {
		            result = arguments[1];
		        } else {
		            do {
		                if (i in self) {
		                    result = self[i--];
		                    break;
		                }
		
		                // if array contains no values, no initial value to return
		                if (--i < 0) {
		                    throw new TypeError("reduceRight of empty array with no initial value");
		                }
		            } while (true);
		        }
		
		        do {
		            if (i in this) {
		                result = fun.call(void 0, result, self[i], i, object);
		            }
		        } while (i--);
		
		        return result;
		    };
		}
		
		// ES5 15.4.4.14
		// http://es5.github.com/#x15.4.4.14
		// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
		if (!Array.prototype.indexOf || ([0, 1].indexOf(1, 2) != -1)) {
		    Array.prototype.indexOf = function indexOf(sought /*, fromIndex */ ) {
		        var self = splitString && _toString(this) == "[object String]" ?
		                this.split("") :
		                toObject(this),
		            length = self.length >>> 0;
		
		        if (!length) {
		            return -1;
		        }
		
		        var i = 0;
		        if (arguments.length > 1) {
		            i = toInteger(arguments[1]);
		        }
		
		        // handle negative indices
		        i = i >= 0 ? i : Math.max(0, length + i);
		        for (; i < length; i++) {
		            if (i in self && self[i] === sought) {
		                return i;
		            }
		        }
		        return -1;
		    };
		}
		
		// ES5 15.4.4.15
		// http://es5.github.com/#x15.4.4.15
		// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf
		if (!Array.prototype.lastIndexOf || ([0, 1].lastIndexOf(0, -3) != -1)) {
		    Array.prototype.lastIndexOf = function lastIndexOf(sought /*, fromIndex */) {
		        var self = splitString && _toString(this) == "[object String]" ?
		                this.split("") :
		                toObject(this),
		            length = self.length >>> 0;
		
		        if (!length) {
		            return -1;
		        }
		        var i = length - 1;
		        if (arguments.length > 1) {
		            i = Math.min(i, toInteger(arguments[1]));
		        }
		        // handle negative indices
		        i = i >= 0 ? i : length - Math.abs(i);
		        for (; i >= 0; i--) {
		            if (i in self && sought === self[i]) {
		                return i;
		            }
		        }
		        return -1;
		    };
		}
		
		//
		// Object
		// ======
		//
		
		// ES5 15.2.3.2
		// http://es5.github.com/#x15.2.3.2
		if (!Object.getPrototypeOf) {
		    // https://github.com/kriskowal/es5-shim/issues#issue/2
		    // http://ejohn.org/blog/objectgetprototypeof/
		    // recommended by fschaefer on github
		    Object.getPrototypeOf = function getPrototypeOf(object) {
		        return object.__proto__ || (
		            object.constructor ?
		            object.constructor.prototype :
		            prototypeOfObject
		        );
		    };
		}
		
		// ES5 15.2.3.3
		// http://es5.github.com/#x15.2.3.3
		if (!Object.getOwnPropertyDescriptor) {
		    var ERR_NON_OBJECT = "Object.getOwnPropertyDescriptor called on a " +
		                         "non-object: ";
		    Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
		        if ((typeof object != "object" && typeof object != "function") || object === null)
		            throw new TypeError(ERR_NON_OBJECT + object);
		        // If object does not owns property return undefined immediately.
		        if (!owns(object, property))
		            return;
		
		        var descriptor, getter, setter;
		
		        // If object has a property then it's for sure both `enumerable` and
		        // `configurable`.
		        descriptor =  { enumerable: true, configurable: true };
		
		        // If JS engine supports accessor properties then property may be a
		        // getter or setter.
		        if (supportsAccessors) {
		            // Unfortunately `__lookupGetter__` will return a getter even
		            // if object has own non getter property along with a same named
		            // inherited getter. To avoid misbehavior we temporary remove
		            // `__proto__` so that `__lookupGetter__` will return getter only
		            // if it's owned by an object.
		            var prototype = object.__proto__;
		            object.__proto__ = prototypeOfObject;
		
		            var getter = lookupGetter(object, property);
		            var setter = lookupSetter(object, property);
		
		            // Once we have getter and setter we can put values back.
		            object.__proto__ = prototype;
		
		            if (getter || setter) {
		                if (getter) descriptor.get = getter;
		                if (setter) descriptor.set = setter;
		
		                // If it was accessor property we're done and return here
		                // in order to avoid adding `value` to the descriptor.
		                return descriptor;
		            }
		        }
		
		        // If we got this far we know that object has an own property that is
		        // not an accessor so we set it as a value and return descriptor.
		        descriptor.value = object[property];
		        return descriptor;
		    };
		}
		
		// ES5 15.2.3.4
		// http://es5.github.com/#x15.2.3.4
		if (!Object.getOwnPropertyNames) {
		    Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
		        return Object.keys(object);
		    };
		}
		
		// ES5 15.2.3.5
		// http://es5.github.com/#x15.2.3.5
		if (!Object.create) {
		    var createEmpty;
		    if (Object.prototype.__proto__ === null) {
		        createEmpty = function () {
		            return { "__proto__": null };
		        };
		    } else {
		        // In old IE __proto__ can't be used to manually set `null`
		        createEmpty = function () {
		            var empty = {};
		            for (var i in empty)
		                empty[i] = null;
		            empty.constructor =
		            empty.hasOwnProperty =
		            empty.propertyIsEnumerable =
		            empty.isPrototypeOf =
		            empty.toLocaleString =
		            empty.toString =
		            empty.valueOf =
		            empty.__proto__ = null;
		            return empty;
		        }
		    }
		
		    Object.create = function create(prototype, properties) {
		        var object;
		        if (prototype === null) {
		            object = createEmpty();
		        } else {
		            if (typeof prototype != "object")
		                throw new TypeError("typeof prototype["+(typeof prototype)+"] != 'object'");
		            var Type = function () {};
		            Type.prototype = prototype;
		            object = new Type();
		            // IE has no built-in implementation of `Object.getPrototypeOf`
		            // neither `__proto__`, but this manually setting `__proto__` will
		            // guarantee that `Object.getPrototypeOf` will work as expected with
		            // objects created using `Object.create`
		            object.__proto__ = prototype;
		        }
		        if (properties !== void 0)
		            Object.defineProperties(object, properties);
		        return object;
		    };
		}
		
		// ES5 15.2.3.6
		// http://es5.github.com/#x15.2.3.6
		
		// Patch for WebKit and IE8 standard mode
		// Designed by hax <hax.github.com>
		// related issue: https://github.com/kriskowal/es5-shim/issues#issue/5
		// IE8 Reference:
		//     http://msdn.microsoft.com/en-us/library/dd282900.aspx
		//     http://msdn.microsoft.com/en-us/library/dd229916.aspx
		// WebKit Bugs:
		//     https://bugs.webkit.org/show_bug.cgi?id=36423
		
		function doesDefinePropertyWork(object) {
		    try {
		        Object.defineProperty(object, "sentinel", {});
		        return "sentinel" in object;
		    } catch (exception) {
		        // returns falsy
		    }
		}
		
		// check whether defineProperty works if it's given. Otherwise,
		// shim partially.
		if (Object.defineProperty) {
		    var definePropertyWorksOnObject = doesDefinePropertyWork({});
		    var definePropertyWorksOnDom = typeof document == "undefined" ||
		        doesDefinePropertyWork(document.createElement("div"));
		    if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
		        var definePropertyFallback = Object.defineProperty;
		    }
		}
		
		if (!Object.defineProperty || definePropertyFallback) {
		    var ERR_NON_OBJECT_DESCRIPTOR = "Property description must be an object: ";
		    var ERR_NON_OBJECT_TARGET = "Object.defineProperty called on non-object: "
		    var ERR_ACCESSORS_NOT_SUPPORTED = "getters & setters can not be defined " +
		                                      "on this javascript engine";
		
		    Object.defineProperty = function defineProperty(object, property, descriptor) {
		        if ((typeof object != "object" && typeof object != "function") || object === null)
		            throw new TypeError(ERR_NON_OBJECT_TARGET + object);
		        if ((typeof descriptor != "object" && typeof descriptor != "function") || descriptor === null)
		            throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
		
		        // make a valiant attempt to use the real defineProperty
		        // for I8's DOM elements.
		        if (definePropertyFallback) {
		            try {
		                return definePropertyFallback.call(Object, object, property, descriptor);
		            } catch (exception) {
		                // try the shim if the real one doesn't work
		            }
		        }
		
		        // If it's a data property.
		        if (owns(descriptor, "value")) {
		            // fail silently if "writable", "enumerable", or "configurable"
		            // are requested but not supported
		            /*
		            // alternate approach:
		            if ( // can't implement these features; allow false but not true
		                !(owns(descriptor, "writable") ? descriptor.writable : true) ||
		                !(owns(descriptor, "enumerable") ? descriptor.enumerable : true) ||
		                !(owns(descriptor, "configurable") ? descriptor.configurable : true)
		            )
		                throw new RangeError(
		                    "This implementation of Object.defineProperty does not " +
		                    "support configurable, enumerable, or writable."
		                );
		            */
		
		            if (supportsAccessors && (lookupGetter(object, property) ||
		                                      lookupSetter(object, property)))
		            {
		                // As accessors are supported only on engines implementing
		                // `__proto__` we can safely override `__proto__` while defining
		                // a property to make sure that we don't hit an inherited
		                // accessor.
		                var prototype = object.__proto__;
		                object.__proto__ = prototypeOfObject;
		                // Deleting a property anyway since getter / setter may be
		                // defined on object itself.
		                delete object[property];
		                object[property] = descriptor.value;
		                // Setting original `__proto__` back now.
		                object.__proto__ = prototype;
		            } else {
		                object[property] = descriptor.value;
		            }
		        } else {
		            if (!supportsAccessors)
		                throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
		            // If we got that far then getters and setters can be defined !!
		            if (owns(descriptor, "get"))
		                defineGetter(object, property, descriptor.get);
		            if (owns(descriptor, "set"))
		                defineSetter(object, property, descriptor.set);
		        }
		
		        return object;
		    };
		}
		
		// ES5 15.2.3.7
		// http://es5.github.com/#x15.2.3.7
		if (!Object.defineProperties) {
		    Object.defineProperties = function defineProperties(object, properties) {
		        for (var property in properties) {
		            if (owns(properties, property))
		                Object.defineProperty(object, property, properties[property]);
		        }
		        return object;
		    };
		}
		
		// ES5 15.2.3.8
		// http://es5.github.com/#x15.2.3.8
		if (!Object.seal) {
		    Object.seal = function seal(object) {
		        // this is misleading and breaks feature-detection, but
		        // allows "securable" code to "gracefully" degrade to working
		        // but insecure code.
		        return object;
		    };
		}
		
		// ES5 15.2.3.9
		// http://es5.github.com/#x15.2.3.9
		if (!Object.freeze) {
		    Object.freeze = function freeze(object) {
		        // this is misleading and breaks feature-detection, but
		        // allows "securable" code to "gracefully" degrade to working
		        // but insecure code.
		        return object;
		    };
		}
		
		// detect a Rhino bug and patch it
		try {
		    Object.freeze(function () {});
		} catch (exception) {
		    Object.freeze = (function freeze(freezeObject) {
		        return function freeze(object) {
		            if (typeof object == "function") {
		                return object;
		            } else {
		                return freezeObject(object);
		            }
		        };
		    })(Object.freeze);
		}
		
		// ES5 15.2.3.10
		// http://es5.github.com/#x15.2.3.10
		if (!Object.preventExtensions) {
		    Object.preventExtensions = function preventExtensions(object) {
		        // this is misleading and breaks feature-detection, but
		        // allows "securable" code to "gracefully" degrade to working
		        // but insecure code.
		        return object;
		    };
		}
		
		// ES5 15.2.3.11
		// http://es5.github.com/#x15.2.3.11
		if (!Object.isSealed) {
		    Object.isSealed = function isSealed(object) {
		        return false;
		    };
		}
		
		// ES5 15.2.3.12
		// http://es5.github.com/#x15.2.3.12
		if (!Object.isFrozen) {
		    Object.isFrozen = function isFrozen(object) {
		        return false;
		    };
		}
		
		// ES5 15.2.3.13
		// http://es5.github.com/#x15.2.3.13
		if (!Object.isExtensible) {
		    Object.isExtensible = function isExtensible(object) {
		        // 1. If Type(O) is not Object throw a TypeError exception.
		        if (Object(object) === object) {
		            throw new TypeError(); // TODO message
		        }
		        // 2. Return the Boolean value of the [[Extensible]] internal property of O.
		        var name = '';
		        while (owns(object, name)) {
		            name += '?';
		        }
		        object[name] = true;
		        var returnValue = owns(object, name);
		        delete object[name];
		        return returnValue;
		    };
		}
		
		// ES5 15.2.3.14
		// http://es5.github.com/#x15.2.3.14
		if (!Object.keys) {
		    // http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
		    var hasDontEnumBug = true,
		        dontEnums = [
		            "toString",
		            "toLocaleString",
		            "valueOf",
		            "hasOwnProperty",
		            "isPrototypeOf",
		            "propertyIsEnumerable",
		            "constructor"
		        ],
		        dontEnumsLength = dontEnums.length;
		
		    for (var key in {"toString": null}) {
		        hasDontEnumBug = false;
		    }
		
		    Object.keys = function keys(object) {
		
		        if (
		            (typeof object != "object" && typeof object != "function") ||
		            object === null
		        ) {
		            throw new TypeError("Object.keys called on a non-object");
		        }
		
		        var keys = [];
		        for (var name in object) {
		            if (owns(object, name)) {
		                keys.push(name);
		            }
		        }
		
		        if (hasDontEnumBug) {
		            for (var i = 0, ii = dontEnumsLength; i < ii; i++) {
		                var dontEnum = dontEnums[i];
		                if (owns(object, dontEnum)) {
		                    keys.push(dontEnum);
		                }
		            }
		        }
		        return keys;
		    };
		
		}
		
		//
		// most of es5-shim Date section is removed since ace doesn't need it, it is too intrusive and it causes problems for users
		// ====
		//
		
		// ES5 15.9.4.4
		// http://es5.github.com/#x15.9.4.4
		if (!Date.now) {
		    Date.now = function now() {
		        return new Date().getTime();
		    };
		}
		
		
		//
		// String
		// ======
		//
		
		// ES5 15.5.4.20
		// http://es5.github.com/#x15.5.4.20
		var ws = "\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003" +
		    "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028" +
		    "\u2029\uFEFF";
		if (!String.prototype.trim || ws.trim()) {
		    // http://blog.stevenlevithan.com/archives/faster-trim-javascript
		    // http://perfectionkills.com/whitespace-deviations/
		    ws = "[" + ws + "]";
		    var trimBeginRegexp = new RegExp("^" + ws + ws + "*"),
		        trimEndRegexp = new RegExp(ws + ws + "*$");
		    String.prototype.trim = function trim() {
		        return String(this).replace(trimBeginRegexp, "").replace(trimEndRegexp, "");
		    };
		}
		
		//
		// Util
		// ======
		//
		
		// ES5 9.4
		// http://es5.github.com/#x9.4
		// http://jsperf.com/to-integer
		
		function toInteger(n) {
		    n = +n;
		    if (n !== n) { // isNaN
		        n = 0;
		    } else if (n !== 0 && n !== (1/0) && n !== -(1/0)) {
		        n = (n > 0 || -1) * Math.floor(Math.abs(n));
		    }
		    return n;
		}
		
		function isPrimitive(input) {
		    var type = typeof input;
		    return (
		        input === null ||
		        type === "undefined" ||
		        type === "boolean" ||
		        type === "number" ||
		        type === "string"
		    );
		}
		
		function toPrimitive(input) {
		    var val, valueOf, toString;
		    if (isPrimitive(input)) {
		        return input;
		    }
		    valueOf = input.valueOf;
		    if (typeof valueOf === "function") {
		        val = valueOf.call(input);
		        if (isPrimitive(val)) {
		            return val;
		        }
		    }
		    toString = input.toString;
		    if (typeof toString === "function") {
		        val = toString.call(input);
		        if (isPrimitive(val)) {
		            return val;
		        }
		    }
		    throw new TypeError();
		}
		
		// ES5 9.9
		// http://es5.github.com/#x9.9
		var toObject = function (o) {
		    if (o == null) { // this matches both null and undefined
		        throw new TypeError("can't convert "+o+" to object");
		    }
		    return Object(o);
		};
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/lib/event.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var keys = require("./keys");
		var useragent = require("./useragent");
		
		var pressedKeys = null;
		var ts = 0;
		
		exports.addListener = function(elem, type, callback) {
		    if (elem.addEventListener) {
		        return elem.addEventListener(type, callback, false);
		    }
		    if (elem.attachEvent) {
		        var wrapper = function() {
		            callback.call(elem, window.event);
		        };
		        callback._wrapper = wrapper;
		        elem.attachEvent("on" + type, wrapper);
		    }
		};
		
		exports.removeListener = function(elem, type, callback) {
		    if (elem.removeEventListener) {
		        return elem.removeEventListener(type, callback, false);
		    }
		    if (elem.detachEvent) {
		        elem.detachEvent("on" + type, callback._wrapper || callback);
		    }
		};
		
		/*
		* Prevents propagation and clobbers the default action of the passed event
		*/
		exports.stopEvent = function(e) {
		    exports.stopPropagation(e);
		    exports.preventDefault(e);
		    return false;
		};
		
		exports.stopPropagation = function(e) {
		    if (e.stopPropagation)
		        e.stopPropagation();
		    else
		        e.cancelBubble = true;
		};
		
		exports.preventDefault = function(e) {
		    if (e.preventDefault)
		        e.preventDefault();
		    else
		        e.returnValue = false;
		};
		
		/*
		 * @return {Number} 0 for left button, 1 for middle button, 2 for right button
		 */
		exports.getButton = function(e) {
		    if (e.type == "dblclick")
		        return 0;
		    if (e.type == "contextmenu" || (useragent.isMac && (e.ctrlKey && !e.altKey && !e.shiftKey)))
		        return 2;
		
		    // DOM Event
		    if (e.preventDefault) {
		        return e.button;
		    }
		    // old IE
		    else {
		        return {1:0, 2:2, 4:1}[e.button];
		    }
		};
		
		exports.capture = function(el, eventHandler, releaseCaptureHandler) {
		    function onMouseUp(e) {
		        eventHandler && eventHandler(e);
		        releaseCaptureHandler && releaseCaptureHandler(e);
		
		        exports.removeListener(document, "mousemove", eventHandler, true);
		        exports.removeListener(document, "mouseup", onMouseUp, true);
		        exports.removeListener(document, "dragstart", onMouseUp, true);
		    }
		
		    exports.addListener(document, "mousemove", eventHandler, true);
		    exports.addListener(document, "mouseup", onMouseUp, true);
		    exports.addListener(document, "dragstart", onMouseUp, true);
		    
		    return onMouseUp;
		};
		
		exports.addTouchMoveListener = function (el, callback) {
		    var startx, starty;
		    exports.addListener(el, "touchstart", function (e) {
		        var touches = e.touches;
		        var touchObj = touches[0];
		        startx = touchObj.clientX;
		        starty = touchObj.clientY;
		    });
		    exports.addListener(el, "touchmove", function (e) {
		        var touches = e.touches;
		        if (touches.length > 1) return;
		        
		        var touchObj = touches[0];
		
		        e.wheelX = startx - touchObj.clientX;
		        e.wheelY = starty - touchObj.clientY;
		
		        startx = touchObj.clientX;
		        starty = touchObj.clientY;
		
		        callback(e);
		    });
		};
		
		exports.addMouseWheelListener = function(el, callback) {
		    if ("onmousewheel" in el) {
		        exports.addListener(el, "mousewheel", function(e) {
		            var factor = 8;
		            if (e.wheelDeltaX !== undefined) {
		                e.wheelX = -e.wheelDeltaX / factor;
		                e.wheelY = -e.wheelDeltaY / factor;
		            } else {
		                e.wheelX = 0;
		                e.wheelY = -e.wheelDelta / factor;
		            }
		            callback(e);
		        });
		    } else if ("onwheel" in el) {
		        exports.addListener(el, "wheel",  function(e) {
		            var factor = 0.35;
		            switch (e.deltaMode) {
		                case e.DOM_DELTA_PIXEL:
		                    e.wheelX = e.deltaX * factor || 0;
		                    e.wheelY = e.deltaY * factor || 0;
		                    break;
		                case e.DOM_DELTA_LINE:
		                case e.DOM_DELTA_PAGE:
		                    e.wheelX = (e.deltaX || 0) * 5;
		                    e.wheelY = (e.deltaY || 0) * 5;
		                    break;
		            }
		            
		            callback(e);
		        });
		    } else {
		        exports.addListener(el, "DOMMouseScroll", function(e) {
		            if (e.axis && e.axis == e.HORIZONTAL_AXIS) {
		                e.wheelX = (e.detail || 0) * 5;
		                e.wheelY = 0;
		            } else {
		                e.wheelX = 0;
		                e.wheelY = (e.detail || 0) * 5;
		            }
		            callback(e);
		        });
		    }
		};
		
		exports.addMultiMouseDownListener = function(elements, timeouts, eventHandler, callbackName) {
		    var clicks = 0;
		    var startX, startY, timer; 
		    var eventNames = {
		        2: "dblclick",
		        3: "tripleclick",
		        4: "quadclick"
		    };
		
		    function onMousedown(e) {
		        if (exports.getButton(e) !== 0) {
		            clicks = 0;
		        } else if (e.detail > 1) {
		            clicks++;
		            if (clicks > 4)
		                clicks = 1;
		        } else {
		            clicks = 1;
		        }
		        if (useragent.isIE) {
		            var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;
		            if (!timer || isNewClick)
		                clicks = 1;
		            if (timer)
		                clearTimeout(timer);
		            timer = setTimeout(function() {timer = null;}, timeouts[clicks - 1] || 600);
		
		            if (clicks == 1) {
		                startX = e.clientX;
		                startY = e.clientY;
		            }
		        }
		        
		        e._clicks = clicks;
		
		        eventHandler[callbackName]("mousedown", e);
		
		        if (clicks > 4)
		            clicks = 0;
		        else if (clicks > 1)
		            return eventHandler[callbackName](eventNames[clicks], e);
		    }
		    function onDblclick(e) {
		        clicks = 2;
		        if (timer)
		            clearTimeout(timer);
		        timer = setTimeout(function() {timer = null;}, timeouts[clicks - 1] || 600);
		        eventHandler[callbackName]("mousedown", e);
		        eventHandler[callbackName](eventNames[clicks], e);
		    }
		    if (!Array.isArray(elements))
		        elements = [elements];
		    elements.forEach(function(el) {
		        exports.addListener(el, "mousedown", onMousedown);
		        if (useragent.isOldIE)
		            exports.addListener(el, "dblclick", onDblclick);
		    });
		};
		
		var getModifierHash = useragent.isMac && useragent.isOpera && !("KeyboardEvent" in window)
		    ? function(e) {
		        return 0 | (e.metaKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.ctrlKey ? 8 : 0);
		    }
		    : function(e) {
		        return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
		    };
		
		exports.getModifierString = function(e) {
		    return keys.KEY_MODS[getModifierHash(e)];
		};
		
		function normalizeCommandKeys(callback, e, keyCode) {
		    var hashId = getModifierHash(e);
		
		    if (!useragent.isMac && pressedKeys) {
		        if (e.getModifierState && (e.getModifierState("OS") || e.getModifierState("Win")))
		            hashId |= 8;
		        if (pressedKeys.altGr) {
		            if ((3 & hashId) != 3)
		                pressedKeys.altGr = 0;
		            else
		                return;
		        }
		        if (keyCode === 18 || keyCode === 17) {
		            var location = "location" in e ? e.location : e.keyLocation;
		            if (keyCode === 17 && location === 1) {
		                if (pressedKeys[keyCode] == 1)
		                    ts = e.timeStamp;
		            } else if (keyCode === 18 && hashId === 3 && location === 2) {
		                var dt = e.timeStamp - ts;
		                if (dt < 50)
		                    pressedKeys.altGr = true;
		            }
		        }
		    }
		    
		    if (keyCode in keys.MODIFIER_KEYS) {
		        keyCode = -1;
		    }
		
		    // keyCode of right command is 93 on mac and 92 on windows.
		    // keyCode of left command key is 91
		    if (hashId & 8 && (keyCode >= 91 && keyCode <= 93)) {
		        keyCode = -1;
		    }
		    
		    if (!hashId && keyCode === 13) {
		        var location = "location" in e ? e.location : e.keyLocation;
		        if (location === 3) {
		            callback(e, hashId, -keyCode);
		            if (e.defaultPrevented)
		                return;
		        }
		    }
		    
		    if (useragent.isChromeOS && hashId & 8) {
		        callback(e, hashId, keyCode);
		        if (e.defaultPrevented)
		            return;
		        else
		            hashId &= ~8;
		    }
		
		    // If there is no hashId and the keyCode is not a function key, then
		    // we don't call the callback as we don't handle a command key here
		    // (it's a normal key/character input).
		    if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
		        return false;
		    }
		    
		    return callback(e, hashId, keyCode);
		}
		
		
		exports.addCommandKeyListener = function(el, callback) {
		    var addListener = exports.addListener;
		    if (useragent.isOldGecko || (useragent.isOpera && !("KeyboardEvent" in window))) {
		        // Old versions of Gecko aka. Firefox < 4.0 didn't repeat the keydown
		        // event if the user pressed the key for a longer time. Instead, the
		        // keydown event was fired once and later on only the keypress event.
		        // To emulate the 'right' keydown behavior, the keyCode of the initial
		        // keyDown event is stored and in the following keypress events the
		        // stores keyCode is used to emulate a keyDown event.
		        var lastKeyDownKeyCode = null;
		        addListener(el, "keydown", function(e) {
		            lastKeyDownKeyCode = e.keyCode;
		        });
		        addListener(el, "keypress", function(e) {
		            return normalizeCommandKeys(callback, e, lastKeyDownKeyCode);
		        });
		    } else {
		        var lastDefaultPrevented = null;
		
		        addListener(el, "keydown", function(e) {
		            pressedKeys[e.keyCode] = (pressedKeys[e.keyCode] || 0) + 1;
		            var result = normalizeCommandKeys(callback, e, e.keyCode);
		            lastDefaultPrevented = e.defaultPrevented;
		            return result;
		        });
		
		        addListener(el, "keypress", function(e) {
		            if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
		                exports.stopEvent(e);
		                lastDefaultPrevented = null;
		            }
		        });
		
		        addListener(el, "keyup", function(e) {
		            pressedKeys[e.keyCode] = null;
		        });
		
		        if (!pressedKeys) {
		            resetPressedKeys();
		            addListener(window, "focus", resetPressedKeys);
		        }
		    }
		};
		function resetPressedKeys() {
		    // console.log("resetting")
		    pressedKeys = Object.create(null);
		}
		
		if (typeof window == "object" && window.postMessage && !useragent.isOldIE) {
		    var postMessageId = 1;
		    exports.nextTick = function(callback, win) {
		        win = win || window;
		        var messageName = "zero-timeout-message-" + postMessageId;
		        exports.addListener(win, "message", function listener(e) {
		            if (e.data == messageName) {
		                exports.stopPropagation(e);
		                exports.removeListener(win, "message", listener);
		                callback();
		            }
		        });
		        win.postMessage(messageName, "*");
		    };
		}
		
		
		exports.nextFrame = typeof window == "object" && (window.requestAnimationFrame
		    || window.mozRequestAnimationFrame
		    || window.webkitRequestAnimationFrame
		    || window.msRequestAnimationFrame
		    || window.oRequestAnimationFrame);
		
		if (exports.nextFrame)
		    exports.nextFrame = exports.nextFrame.bind(window);
		else
		    exports.nextFrame = function(callback) {
		        setTimeout(callback, 17);
		    };
		
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/lib/event_emitter.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var EventEmitter = {};
		var stopPropagation = function() { this.propagationStopped = true; };
		var preventDefault = function() { this.defaultPrevented = true; };
		
		EventEmitter._emit =
		EventEmitter._dispatchEvent = function(eventName, e) {
		    this._eventRegistry || (this._eventRegistry = {});
		    this._defaultHandlers || (this._defaultHandlers = {});
		
		    var listeners = this._eventRegistry[eventName] || [];
		    var defaultHandler = this._defaultHandlers[eventName];
		    if (!listeners.length && !defaultHandler)
		        return;
		
		    if (typeof e != "object" || !e)
		        e = {};
		
		    if (!e.type)
		        e.type = eventName;
		    if (!e.stopPropagation)
		        e.stopPropagation = stopPropagation;
		    if (!e.preventDefault)
		        e.preventDefault = preventDefault;
		
		    listeners = listeners.slice();
		    for (var i=0; i<listeners.length; i++) {
		        listeners[i](e, this);
		        if (e.propagationStopped)
		            break;
		    }
		    
		    if (defaultHandler && !e.defaultPrevented)
		        return defaultHandler(e, this);
		};
		
		
		EventEmitter._signal = function(eventName, e) {
		    var listeners = (this._eventRegistry || {})[eventName];
		    if (!listeners)
		        return;
		    listeners = listeners.slice();
		    for (var i=0; i<listeners.length; i++)
		        listeners[i](e, this);
		};
		
		EventEmitter.once = function(eventName, callback) {
		    var _self = this;
		    callback && this.addEventListener(eventName, function newCallback() {
		        _self.removeEventListener(eventName, newCallback);
		        callback.apply(null, arguments);
		    });
		};
		
		
		EventEmitter.setDefaultHandler = function(eventName, callback) {
		    var handlers = this._defaultHandlers;
		    if (!handlers)
		        handlers = this._defaultHandlers = {_disabled_: {}};
		    
		    if (handlers[eventName]) {
		        var old = handlers[eventName];
		        var disabled = handlers._disabled_[eventName];
		        if (!disabled)
		            handlers._disabled_[eventName] = disabled = [];
		        disabled.push(old);
		        var i = disabled.indexOf(callback);
		        if (i != -1) 
		            disabled.splice(i, 1);
		    }
		    handlers[eventName] = callback;
		};
		EventEmitter.removeDefaultHandler = function(eventName, callback) {
		    var handlers = this._defaultHandlers;
		    if (!handlers)
		        return;
		    var disabled = handlers._disabled_[eventName];
		    
		    if (handlers[eventName] == callback) {
		        var old = handlers[eventName];
		        if (disabled)
		            this.setDefaultHandler(eventName, disabled.pop());
		    } else if (disabled) {
		        var i = disabled.indexOf(callback);
		        if (i != -1)
		            disabled.splice(i, 1);
		    }
		};
		
		EventEmitter.on =
		EventEmitter.addEventListener = function(eventName, callback, capturing) {
		    this._eventRegistry = this._eventRegistry || {};
		
		    var listeners = this._eventRegistry[eventName];
		    if (!listeners)
		        listeners = this._eventRegistry[eventName] = [];
		
		    if (listeners.indexOf(callback) == -1)
		        listeners[capturing ? "unshift" : "push"](callback);
		    return callback;
		};
		
		EventEmitter.off =
		EventEmitter.removeListener =
		EventEmitter.removeEventListener = function(eventName, callback) {
		    this._eventRegistry = this._eventRegistry || {};
		
		    var listeners = this._eventRegistry[eventName];
		    if (!listeners)
		        return;
		
		    var index = listeners.indexOf(callback);
		    if (index !== -1)
		        listeners.splice(index, 1);
		};
		
		EventEmitter.removeAllListeners = function(eventName) {
		    if (this._eventRegistry) this._eventRegistry[eventName] = [];
		};
		
		exports.EventEmitter = EventEmitter;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/lib/fixoldbrowsers.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		require("./regexp");
		require("./es5-shim");
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/lib/keys.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		
		require("./fixoldbrowsers");
		
		var oop = require("./oop");
		
		/*
		 * Helper functions and hashes for key handling.
		 */
		var Keys = (function() {
		    var ret = {
		        MODIFIER_KEYS: {
		            16: 'Shift', 17: 'Ctrl', 18: 'Alt', 224: 'Meta'
		        },
		
		        KEY_MODS: {
		            "ctrl": 1, "alt": 2, "option" : 2, "shift": 4,
		            "super": 8, "meta": 8, "command": 8, "cmd": 8
		        },
		
		        FUNCTION_KEYS : {
		            8  : "Backspace",
		            9  : "Tab",
		            13 : "Return",
		            19 : "Pause",
		            27 : "Esc",
		            32 : "Space",
		            33 : "PageUp",
		            34 : "PageDown",
		            35 : "End",
		            36 : "Home",
		            37 : "Left",
		            38 : "Up",
		            39 : "Right",
		            40 : "Down",
		            44 : "Print",
		            45 : "Insert",
		            46 : "Delete",
		            96 : "Numpad0",
		            97 : "Numpad1",
		            98 : "Numpad2",
		            99 : "Numpad3",
		            100: "Numpad4",
		            101: "Numpad5",
		            102: "Numpad6",
		            103: "Numpad7",
		            104: "Numpad8",
		            105: "Numpad9",
		            '-13': "NumpadEnter",
		            112: "F1",
		            113: "F2",
		            114: "F3",
		            115: "F4",
		            116: "F5",
		            117: "F6",
		            118: "F7",
		            119: "F8",
		            120: "F9",
		            121: "F10",
		            122: "F11",
		            123: "F12",
		            144: "Numlock",
		            145: "Scrolllock"
		        },
		
		        PRINTABLE_KEYS: {
		           32: ' ',  48: '0',  49: '1',  50: '2',  51: '3',  52: '4', 53:  '5',
		           54: '6',  55: '7',  56: '8',  57: '9',  59: ';',  61: '=', 65:  'a',
		           66: 'b',  67: 'c',  68: 'd',  69: 'e',  70: 'f',  71: 'g', 72:  'h',
		           73: 'i',  74: 'j',  75: 'k',  76: 'l',  77: 'm',  78: 'n', 79:  'o',
		           80: 'p',  81: 'q',  82: 'r',  83: 's',  84: 't',  85: 'u', 86:  'v',
		           87: 'w',  88: 'x',  89: 'y',  90: 'z', 107: '+', 109: '-', 110: '.',
		          186: ';', 187: '=', 188: ',', 189: '-', 190: '.', 191: '/', 192: '`',
		          219: '[', 220: '\\',221: ']', 222: "'", 111: '/', 106: '*'
		        }
		    };
		
		    // A reverse map of FUNCTION_KEYS
		    var name, i;
		    for (i in ret.FUNCTION_KEYS) {
		        name = ret.FUNCTION_KEYS[i].toLowerCase();
		        ret[name] = parseInt(i, 10);
		    }
		
		    // A reverse map of PRINTABLE_KEYS
		    for (i in ret.PRINTABLE_KEYS) {
		        name = ret.PRINTABLE_KEYS[i].toLowerCase();
		        ret[name] = parseInt(i, 10);
		    }
		
		    // Add the MODIFIER_KEYS, FUNCTION_KEYS and PRINTABLE_KEYS to the KEY
		    // variables as well.
		    oop.mixin(ret, ret.MODIFIER_KEYS);
		    oop.mixin(ret, ret.PRINTABLE_KEYS);
		    oop.mixin(ret, ret.FUNCTION_KEYS);
		
		    // aliases
		    ret.enter = ret["return"];
		    ret.escape = ret.esc;
		    ret.del = ret["delete"];
		
		    // workaround for firefox bug
		    ret[173] = '-';
		    
		    (function() {
		        var mods = ["cmd", "ctrl", "alt", "shift"];
		        for (var i = Math.pow(2, mods.length); i--;) {            
		            ret.KEY_MODS[i] = mods.filter(function(x) {
		                return i & ret.KEY_MODS[x];
		            }).join("-") + "-";
		        }
		    })();
		
		    ret.KEY_MODS[0] = "";
		    ret.KEY_MODS[-1] = "input-";
		
		    return ret;
		})();
		oop.mixin(exports, Keys);
		
		exports.keyCodeToString = function(keyCode) {
		    // Language-switching keystroke in Chrome/Linux emits keyCode 0.
		    var keyString = Keys[keyCode];
		    if (typeof keyString != "string")
		        keyString = String.fromCharCode(keyCode);
		    return keyString.toLowerCase();
		};
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/lib/lang.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		exports.last = function(a) {
		    return a[a.length - 1];
		};
		
		exports.stringReverse = function(string) {
		    return string.split("").reverse().join("");
		};
		
		exports.stringRepeat = function (string, count) {
		    var result = '';
		    while (count > 0) {
		        if (count & 1)
		            result += string;
		
		        if (count >>= 1)
		            string += string;
		    }
		    return result;
		};
		
		var trimBeginRegexp = /^\s\s*/;
		var trimEndRegexp = /\s\s*$/;
		
		exports.stringTrimLeft = function (string) {
		    return string.replace(trimBeginRegexp, '');
		};
		
		exports.stringTrimRight = function (string) {
		    return string.replace(trimEndRegexp, '');
		};
		
		exports.copyObject = function(obj) {
		    var copy = {};
		    for (var key in obj) {
		        copy[key] = obj[key];
		    }
		    return copy;
		};
		
		exports.copyArray = function(array){
		    var copy = [];
		    for (var i=0, l=array.length; i<l; i++) {
		        if (array[i] && typeof array[i] == "object")
		            copy[i] = this.copyObject( array[i] );
		        else 
		            copy[i] = array[i];
		    }
		    return copy;
		};
		
		exports.deepCopy = function deepCopy(obj) {
		    if (typeof obj !== "object" || !obj)
		        return obj;
		    var copy;
		    if (Array.isArray(obj)) {
		        copy = [];
		        for (var key = 0; key < obj.length; key++) {
		            copy[key] = deepCopy(obj[key]);
		        }
		        return copy;
		    }
		    var cons = obj.constructor;
		    if (cons === RegExp)
		        return obj;
		    
		    copy = cons();
		    for (var key in obj) {
		        copy[key] = deepCopy(obj[key]);
		    }
		    return copy;
		};
		
		exports.arrayToMap = function(arr) {
		    var map = {};
		    for (var i=0; i<arr.length; i++) {
		        map[arr[i]] = 1;
		    }
		    return map;
		
		};
		
		exports.createMap = function(props) {
		    var map = Object.create(null);
		    for (var i in props) {
		        map[i] = props[i];
		    }
		    return map;
		};
		
		/*
		 * splice out of 'array' anything that === 'value'
		 */
		exports.arrayRemove = function(array, value) {
		  for (var i = 0; i <= array.length; i++) {
		    if (value === array[i]) {
		      array.splice(i, 1);
		    }
		  }
		};
		
		exports.escapeRegExp = function(str) {
		    return str.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1');
		};
		
		exports.escapeHTML = function(str) {
		    return str.replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
		};
		
		exports.getMatchOffsets = function(string, regExp) {
		    var matches = [];
		
		    string.replace(regExp, function(str) {
		        matches.push({
		            offset: arguments[arguments.length-2],
		            length: str.length
		        });
		    });
		
		    return matches;
		};
		
		/* deprecated */
		exports.deferredCall = function(fcn) {
		    var timer = null;
		    var callback = function() {
		        timer = null;
		        fcn();
		    };
		
		    var deferred = function(timeout) {
		        deferred.cancel();
		        timer = setTimeout(callback, timeout || 0);
		        return deferred;
		    };
		
		    deferred.schedule = deferred;
		
		    deferred.call = function() {
		        this.cancel();
		        fcn();
		        return deferred;
		    };
		
		    deferred.cancel = function() {
		        clearTimeout(timer);
		        timer = null;
		        return deferred;
		    };
		    
		    deferred.isPending = function() {
		        return timer;
		    };
		
		    return deferred;
		};
		
		
		exports.delayedCall = function(fcn, defaultTimeout) {
		    var timer = null;
		    var callback = function() {
		        timer = null;
		        fcn();
		    };
		
		    var _self = function(timeout) {
		        if (timer == null)
		            timer = setTimeout(callback, timeout || defaultTimeout);
		    };
		
		    _self.delay = function(timeout) {
		        timer && clearTimeout(timer);
		        timer = setTimeout(callback, timeout || defaultTimeout);
		    };
		    _self.schedule = _self;
		
		    _self.call = function() {
		        this.cancel();
		        fcn();
		    };
		
		    _self.cancel = function() {
		        timer && clearTimeout(timer);
		        timer = null;
		    };
		
		    _self.isPending = function() {
		        return timer;
		    };
		
		    return _self;
		};
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/lib/net.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var dom = require("./dom");
		
		exports.get = function (url, callback) {
		    var xhr = new XMLHttpRequest();
		    xhr.open('GET', url, true);
		    xhr.onreadystatechange = function () {
		        //Do not explicitly handle errors, those should be
		        //visible via console output in the browser.
		        if (xhr.readyState === 4) {
		            callback(xhr.responseText);
		        }
		    };
		    xhr.send(null);
		};
		
		exports.loadScript = function(path, callback) {
		    var head = dom.getDocumentHead();
		    var s = document.createElement('script');
		
		    s.src = path;
		    head.appendChild(s);
		
		    s.onload = s.onreadystatechange = function(_, isAbort) {
		        if (isAbort || !s.readyState || s.readyState == "loaded" || s.readyState == "complete") {
		            s = s.onload = s.onreadystatechange = null;
		            if (!isAbort)
		                callback();
		        }
		    };
		};
		
		/*
		 * Convert a url into a fully qualified absolute URL
		 * This function does not work in IE6
		 */
		exports.qualifyURL = function(url) {
		    var a = document.createElement('a');
		    a.href = url;
		    return a.href;
		}
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/lib/oop.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		exports.inherits = function(ctor, superCtor) {
		    ctor.super_ = superCtor;
		    ctor.prototype = Object.create(superCtor.prototype, {
		        constructor: {
		            value: ctor,
		            enumerable: false,
		            writable: true,
		            configurable: true
		        }
		    });
		};
		
		exports.mixin = function(obj, mixin) {
		    for (var key in mixin) {
		        obj[key] = mixin[key];
		    }
		    return obj;
		};
		
		exports.implement = function(proto, mixin) {
		    exports.mixin(proto, mixin);
		};
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/lib/regexp.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		
		
		
			//---------------------------------
		    //  Private variables
		    //---------------------------------
		
		    var real = {
		            exec: RegExp.prototype.exec,
		            test: RegExp.prototype.test,
		            match: String.prototype.match,
		            replace: String.prototype.replace,
		            split: String.prototype.split
		        },
		        compliantExecNpcg = real.exec.call(/()??/, "")[1] === undefined, // check `exec` handling of nonparticipating capturing groups
		        compliantLastIndexIncrement = function () {
		            var x = /^/g;
		            real.test.call(x, "");
		            return !x.lastIndex;
		        }();
		
		    if (compliantLastIndexIncrement && compliantExecNpcg)
		        return;
		
		    //---------------------------------
		    //  Overriden native methods
		    //---------------------------------
		
		    // Adds named capture support (with backreferences returned as `result.name`), and fixes two
		    // cross-browser issues per ES3:
		    // - Captured values for nonparticipating capturing groups should be returned as `undefined`,
		    //   rather than the empty string.
		    // - `lastIndex` should not be incremented after zero-length matches.
		    RegExp.prototype.exec = function (str) {
		        var match = real.exec.apply(this, arguments),
		            name, r2;
		        if ( typeof(str) == 'string' && match) {
		            // Fix browsers whose `exec` methods don't consistently return `undefined` for
		            // nonparticipating capturing groups
		            if (!compliantExecNpcg && match.length > 1 && indexOf(match, "") > -1) {
		                r2 = RegExp(this.source, real.replace.call(getNativeFlags(this), "g", ""));
		                // Using `str.slice(match.index)` rather than `match[0]` in case lookahead allowed
		                // matching due to characters outside the match
		                real.replace.call(str.slice(match.index), r2, function () {
		                    for (var i = 1; i < arguments.length - 2; i++) {
		                        if (arguments[i] === undefined)
		                            match[i] = undefined;
		                    }
		                });
		            }
		            // Attach named capture properties
		            if (this._xregexp && this._xregexp.captureNames) {
		                for (var i = 1; i < match.length; i++) {
		                    name = this._xregexp.captureNames[i - 1];
		                    if (name)
		                       match[name] = match[i];
		                }
		            }
		            // Fix browsers that increment `lastIndex` after zero-length matches
		            if (!compliantLastIndexIncrement && this.global && !match[0].length && (this.lastIndex > match.index))
		                this.lastIndex--;
		        }
		        return match;
		    };
		
		    // Don't override `test` if it won't change anything
		    if (!compliantLastIndexIncrement) {
		        // Fix browser bug in native method
		        RegExp.prototype.test = function (str) {
		            // Use the native `exec` to skip some processing overhead, even though the overriden
		            // `exec` would take care of the `lastIndex` fix
		            var match = real.exec.call(this, str);
		            // Fix browsers that increment `lastIndex` after zero-length matches
		            if (match && this.global && !match[0].length && (this.lastIndex > match.index))
		                this.lastIndex--;
		            return !!match;
		        };
		    }
		
		    //---------------------------------
		    //  Private helper functions
		    //---------------------------------
		
		    function getNativeFlags (regex) {
		        return (regex.global     ? "g" : "") +
		               (regex.ignoreCase ? "i" : "") +
		               (regex.multiline  ? "m" : "") +
		               (regex.extended   ? "x" : "") + // Proposed for ES4; included in AS3
		               (regex.sticky     ? "y" : "");
		    }
		
		    function indexOf (array, item, from) {
		        if (Array.prototype.indexOf) // Use the native array method if available
		            return array.indexOf(item, from);
		        for (var i = from || 0; i < array.length; i++) {
		            if (array[i] === item)
		                return i;
		        }
		        return -1;
		    }
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/lib/useragent.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		
		/*
		 * I hate doing this, but we need some way to determine if the user is on a Mac
		 * The reason is that users have different expectations of their key combinations.
		 *
		 * Take copy as an example, Mac people expect to use CMD or APPLE + C
		 * Windows folks expect to use CTRL + C
		 */
		exports.OS = {
		    LINUX: "LINUX",
		    MAC: "MAC",
		    WINDOWS: "WINDOWS"
		};
		
		/*
		 * Return an exports.OS constant
		 */
		exports.getOS = function() {
		    if (exports.isMac) {
		        return exports.OS.MAC;
		    } else if (exports.isLinux) {
		        return exports.OS.LINUX;
		    } else {
		        return exports.OS.WINDOWS;
		    }
		};
		
		// this can be called in non browser environments (e.g. from ace/requirejs/text)
		if (typeof navigator != "object")
		    return;
		
		var os = (navigator.platform.match(/mac|win|linux/i) || ["other"])[0].toLowerCase();
		var ua = navigator.userAgent;
		
		// Is the user using a browser that identifies itself as Windows
		exports.isWin = (os == "win");
		
		// Is the user using a browser that identifies itself as Mac OS
		exports.isMac = (os == "mac");
		
		// Is the user using a browser that identifies itself as Linux
		exports.isLinux = (os == "linux");
		
		// Windows Store JavaScript apps (aka Metro apps written in HTML5 and JavaScript) do not use the "Microsoft Internet Explorer" string in their user agent, but "MSAppHost" instead.
		exports.isIE = 
		    (navigator.appName == "Microsoft Internet Explorer" || navigator.appName.indexOf("MSAppHost") >= 0)
		    ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/)||[])[1])
		    : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/)||[])[1]); // for ie
		    
		exports.isOldIE = exports.isIE && exports.isIE < 9;
		
		// Is this Firefox or related?
		exports.isGecko = exports.isMozilla = (window.Controllers || window.controllers) && window.navigator.product === "Gecko";
		
		// oldGecko == rev < 2.0 
		exports.isOldGecko = exports.isGecko && parseInt((ua.match(/rv\:(\d+)/)||[])[1], 10) < 4;
		
		// Is this Opera 
		exports.isOpera = window.opera && Object.prototype.toString.call(window.opera) == "[object Opera]";
		
		// Is the user using a browser that identifies itself as WebKit 
		exports.isWebKit = parseFloat(ua.split("WebKit/")[1]) || undefined;
		
		exports.isChrome = parseFloat(ua.split(" Chrome/")[1]) || undefined;
		
		exports.isAIR = ua.indexOf("AdobeAIR") >= 0;
		
		exports.isIPad = ua.indexOf("iPad") >= 0;
		
		exports.isTouchPad = ua.indexOf("TouchPad") >= 0;
		
		exports.isChromeOS = ua.indexOf(" CrOS ") >= 0;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/line_widgets.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var oop = require("./lib/oop");
		var dom = require("./lib/dom");
		var Range = require("./range").Range;
		
		
		function LineWidgets(session) {
		    this.session = session;
		    this.session.widgetManager = this;
		    this.session.getRowLength = this.getRowLength;
		    this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;
		    this.updateOnChange = this.updateOnChange.bind(this);
		    this.renderWidgets = this.renderWidgets.bind(this);
		    this.measureWidgets = this.measureWidgets.bind(this);
		    this.session._changedWidgets = [];
		    this.$onChangeEditor = this.$onChangeEditor.bind(this);
		    
		    this.session.on("change", this.updateOnChange);
		    this.session.on("changeFold", this.updateOnFold);
		    this.session.on("changeEditor", this.$onChangeEditor);
		}
		
		(function() {
		    this.getRowLength = function(row) {
		        var h;
		        if (this.lineWidgets)
		            h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
		        else 
		            h = 0;
		        if (!this.$useWrapMode || !this.$wrapData[row]) {
		            return 1 + h;
		        } else {
		            return this.$wrapData[row].length + 1 + h;
		        }
		    };
		
		    this.$getWidgetScreenLength = function() {
		        var screenRows = 0;
		        this.lineWidgets.forEach(function(w){
		            if (w && w.rowCount && !w.hidden)
		                screenRows += w.rowCount;
		        });
		        return screenRows;
		    };    
		    
		    this.$onChangeEditor = function(e) {
		        this.attach(e.editor);
		    };
		    
		    this.attach = function(editor) {
		        if (editor  && editor.widgetManager && editor.widgetManager != this)
		            editor.widgetManager.detach();
		
		        if (this.editor == editor)
		            return;
		
		        this.detach();
		        this.editor = editor;
		        
		        if (editor) {
		            editor.widgetManager = this;
		            editor.renderer.on("beforeRender", this.measureWidgets);
		            editor.renderer.on("afterRender", this.renderWidgets);
		        }
		    };
		    this.detach = function(e) {
		        var editor = this.editor;
		        if (!editor)
		            return;
		        
		        this.editor = null;
		        editor.widgetManager = null;
		        
		        editor.renderer.off("beforeRender", this.measureWidgets);
		        editor.renderer.off("afterRender", this.renderWidgets);
		        var lineWidgets = this.session.lineWidgets;
		        lineWidgets && lineWidgets.forEach(function(w) {
		            if (w && w.el && w.el.parentNode) {
		                w._inDocument = false;
		                w.el.parentNode.removeChild(w.el);
		            }
		        });
		    };
		
		    this.updateOnFold = function(e, session) {
		        var lineWidgets = session.lineWidgets;
		        if (!lineWidgets || !e.action)
		            return;
		        var fold = e.data;
		        var start = fold.start.row;
		        var end = fold.end.row;
		        var hide = e.action == "add";
		        for (var i = start + 1; i < end; i++) {
		            if (lineWidgets[i])
		                lineWidgets[i].hidden = hide;
		        }
		        if (lineWidgets[end]) {
		            if (hide) {
		                if (!lineWidgets[start])
		                    lineWidgets[start] = lineWidgets[end];
		                else
		                    lineWidgets[end].hidden = hide;
		            } else {
		                if (lineWidgets[start] == lineWidgets[end])
		                    lineWidgets[start] = undefined;
		                lineWidgets[end].hidden = hide;
		            }
		        }
		    };
		    
		    this.updateOnChange = function(delta) {
		        var lineWidgets = this.session.lineWidgets;
		        if (!lineWidgets) return;
		        
		        var startRow = delta.start.row;
		        var len = delta.end.row - startRow;
		
		        if (len === 0) {
		            // return
		        } else if (delta.action == 'remove') {
		            var removed = lineWidgets.splice(startRow + 1, len);
		            removed.forEach(function(w) {
		                w && this.removeLineWidget(w);
		            }, this);
		            this.$updateRows();
		        } else {
		            var args = new Array(len);
		            args.unshift(startRow, 0);
		            lineWidgets.splice.apply(lineWidgets, args);
		            this.$updateRows();
		        }
		    };
		    
		    this.$updateRows = function() {
		        var lineWidgets = this.session.lineWidgets;
		        if (!lineWidgets) return;
		        var noWidgets = true;
		        lineWidgets.forEach(function(w, i) {
		            if (w) {
		                noWidgets = false;
		                w.row = i;
		                while (w.$oldWidget) {
		                    w.$oldWidget.row = i;
		                    w = w.$oldWidget;
		                }
		            }
		        });
		        if (noWidgets)
		            this.session.lineWidgets = null;
		    };
		
		    this.addLineWidget = function(w) {
		        if (!this.session.lineWidgets)
		            this.session.lineWidgets = new Array(this.session.getLength());
		        
		        var old = this.session.lineWidgets[w.row];
		        if (old) {
		            w.$oldWidget = old;
		            if (old.el && old.el.parentNode) {
		                old.el.parentNode.removeChild(old.el);
		                old._inDocument = false;
		            }
		        }
		            
		        this.session.lineWidgets[w.row] = w;
		        
		        w.session = this.session;
		        
		        var renderer = this.editor.renderer;
		        if (w.html && !w.el) {
		            w.el = dom.createElement("div");
		            w.el.innerHTML = w.html;
		        }
		        if (w.el) {
		            dom.addCssClass(w.el, "ace_lineWidgetContainer");
		            w.el.style.position = "absolute";
		            w.el.style.zIndex = 5;
		            renderer.container.appendChild(w.el);
		            w._inDocument = true;
		        }
		        
		        if (!w.coverGutter) {
		            w.el.style.zIndex = 3;
		        }
		        if (!w.pixelHeight) {
		            w.pixelHeight = w.el.offsetHeight;
		        }
		        if (w.rowCount == null) {
		            w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;
		        }
		        
		        var fold = this.session.getFoldAt(w.row, 0);
		        w.$fold = fold;
		        if (fold) {
		            var lineWidgets = this.session.lineWidgets;
		            if (w.row == fold.end.row && !lineWidgets[fold.start.row])
		                lineWidgets[fold.start.row] = w;
		            else
		                w.hidden = true;
		        }
		            
		        this.session._emit("changeFold", {data:{start:{row: w.row}}});
		        
		        this.$updateRows();
		        this.renderWidgets(null, renderer);
		        this.onWidgetChanged(w);
		        return w;
		    };
		    
		    this.removeLineWidget = function(w) {
		        w._inDocument = false;
		        w.session = null;
		        if (w.el && w.el.parentNode)
		            w.el.parentNode.removeChild(w.el);
		        if (w.editor && w.editor.destroy) try {
		            w.editor.destroy();
		        } catch(e){}
		        if (this.session.lineWidgets) {
		            var w1 = this.session.lineWidgets[w.row]
		            if (w1 == w) {
		                this.session.lineWidgets[w.row] = w.$oldWidget;
		                if (w.$oldWidget)
		                    this.onWidgetChanged(w.$oldWidget);
		            } else {
		                while (w1) {
		                    if (w1.$oldWidget == w) {
		                        w1.$oldWidget = w.$oldWidget;
		                        break;
		                    }
		                    w1 = w1.$oldWidget;
		                }
		            }
		        }
		        this.session._emit("changeFold", {data:{start:{row: w.row}}});
		        this.$updateRows();
		    };
		    
		    this.getWidgetsAtRow = function(row) {
		        var lineWidgets = this.session.lineWidgets;
		        var w = lineWidgets && lineWidgets[row];
		        var list = [];
		        while (w) {
		            list.push(w);
		            w = w.$oldWidget;
		        }
		        return list;
		    };
		    
		    this.onWidgetChanged = function(w) {
		        this.session._changedWidgets.push(w);
		        this.editor && this.editor.renderer.updateFull();
		    };
		    
		    this.measureWidgets = function(e, renderer) {
		        var changedWidgets = this.session._changedWidgets;
		        var config = renderer.layerConfig;
		        
		        if (!changedWidgets || !changedWidgets.length) return;
		        var min = Infinity;
		        for (var i = 0; i < changedWidgets.length; i++) {
		            var w = changedWidgets[i];
		            if (!w || !w.el) continue;
		            if (w.session != this.session) continue;
		            if (!w._inDocument) {
		                if (this.session.lineWidgets[w.row] != w)
		                    continue;
		                w._inDocument = true;
		                renderer.container.appendChild(w.el);
		            }
		            
		            w.h = w.el.offsetHeight;
		            
		            if (!w.fixedWidth) {
		                w.w = w.el.offsetWidth;
		                w.screenWidth = Math.ceil(w.w / config.characterWidth);
		            }
		            
		            var rowCount = w.h / config.lineHeight;
		            if (w.coverLine) {
		                rowCount -= this.session.getRowLineCount(w.row);
		                if (rowCount < 0)
		                    rowCount = 0;
		            }
		            if (w.rowCount != rowCount) {
		                w.rowCount = rowCount;
		                if (w.row < min)
		                    min = w.row;
		            }
		        }
		        if (min != Infinity) {
		            this.session._emit("changeFold", {data:{start:{row: min}}});
		            this.session.lineWidgetWidth = null;
		        }
		        this.session._changedWidgets = [];
		    };
		    
		    this.renderWidgets = function(e, renderer) {
		        var config = renderer.layerConfig;
		        var lineWidgets = this.session.lineWidgets;
		        if (!lineWidgets)
		            return;
		        var first = Math.min(this.firstRow, config.firstRow);
		        var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);
		        
		        while (first > 0 && !lineWidgets[first])
		            first--;
		        
		        this.firstRow = config.firstRow;
		        this.lastRow = config.lastRow;
		
		        renderer.$cursorLayer.config = config;
		        for (var i = first; i <= last; i++) {
		            var w = lineWidgets[i];
		            if (!w || !w.el) continue;
		            if (w.hidden) {
		                w.el.style.top = -100 - (w.pixelHeight || 0) + "px";
		                continue;
		            }
		            if (!w._inDocument) {
		                w._inDocument = true;
		                renderer.container.appendChild(w.el);
		            }
		            var top = renderer.$cursorLayer.getPixelPosition({row: i, column:0}, true).top;
		            if (!w.coverLine)
		                top += config.lineHeight * this.session.getRowLineCount(w.row);
		            w.el.style.top = top - config.offset + "px";
		            
		            var left = w.coverGutter ? 0 : renderer.gutterWidth;
		            if (!w.fixedWidth)
		                left -= renderer.scrollLeft;
		            w.el.style.left = left + "px";
		            
		            if (w.fullWidth && w.screenWidth) {
		                w.el.style.minWidth = config.width + 2 * config.padding + "px";
		            }
		            
		            if (w.fixedWidth) {
		                w.el.style.right = renderer.scrollBar.getWidth() + "px";
		            } else {
		                w.el.style.right = "";
		            }
		        }
		    };
		    
		}).call(LineWidgets.prototype);
		
		
		exports.LineWidgets = LineWidgets;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/mode/behaviour/css.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var oop = require("../../lib/oop");
		var Behaviour = require("../behaviour").Behaviour;
		var CstyleBehaviour = require("./cstyle").CstyleBehaviour;
		var TokenIterator = require("../../token_iterator").TokenIterator;
		
		var CssBehaviour = function () {
		
		    this.inherit(CstyleBehaviour);
		
		    this.add("colon", "insertion", function (state, action, editor, session, text) {
		        if (text === ':') {
		            var cursor = editor.getCursorPosition();
		            var iterator = new TokenIterator(session, cursor.row, cursor.column);
		            var token = iterator.getCurrentToken();
		            if (token && token.value.match(/\s+/)) {
		                token = iterator.stepBackward();
		            }
		            if (token && token.type === 'support.type') {
		                var line = session.doc.getLine(cursor.row);
		                var rightChar = line.substring(cursor.column, cursor.column + 1);
		                if (rightChar === ':') {
		                    return {
		                       text: '',
		                       selection: [1, 1]
		                    }
		                }
		                if (!line.substring(cursor.column).match(/^\s*;/)) {
		                    return {
		                       text: ':;',
		                       selection: [1, 1]
		                    }
		                }
		            }
		        }
		    });
		
		    this.add("colon", "deletion", function (state, action, editor, session, range) {
		        var selected = session.doc.getTextRange(range);
		        if (!range.isMultiLine() && selected === ':') {
		            var cursor = editor.getCursorPosition();
		            var iterator = new TokenIterator(session, cursor.row, cursor.column);
		            var token = iterator.getCurrentToken();
		            if (token && token.value.match(/\s+/)) {
		                token = iterator.stepBackward();
		            }
		            if (token && token.type === 'support.type') {
		                var line = session.doc.getLine(range.start.row);
		                var rightChar = line.substring(range.end.column, range.end.column + 1);
		                if (rightChar === ';') {
		                    range.end.column ++;
		                    return range;
		                }
		            }
		        }
		    });
		
		    this.add("semicolon", "insertion", function (state, action, editor, session, text) {
		        if (text === ';') {
		            var cursor = editor.getCursorPosition();
		            var line = session.doc.getLine(cursor.row);
		            var rightChar = line.substring(cursor.column, cursor.column + 1);
		            if (rightChar === ';') {
		                return {
		                   text: '',
		                   selection: [1, 1]
		                }
		            }
		        }
		    });
		
		}
		oop.inherits(CssBehaviour, CstyleBehaviour);
		
		exports.CssBehaviour = CssBehaviour;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/mode/behaviour/cstyle.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var oop = require("../../lib/oop");
		var Behaviour = require("../behaviour").Behaviour;
		var TokenIterator = require("../../token_iterator").TokenIterator;
		var lang = require("../../lib/lang");
		
		var SAFE_INSERT_IN_TOKENS =
		    ["text", "paren.rparen", "punctuation.operator"];
		var SAFE_INSERT_BEFORE_TOKENS =
		    ["text", "paren.rparen", "punctuation.operator", "comment"];
		
		var context;
		var contextCache = {};
		var defaultQuotes = {'"' : '"', "'" : "'"};
		
		var initContext = function(editor) {
		    var id = -1;
		    if (editor.multiSelect) {
		        id = editor.selection.index;
		        if (contextCache.rangeCount != editor.multiSelect.rangeCount)
		            contextCache = {rangeCount: editor.multiSelect.rangeCount};
		    }
		    if (contextCache[id])
		        return context = contextCache[id];
		    context = contextCache[id] = {
		        autoInsertedBrackets: 0,
		        autoInsertedRow: -1,
		        autoInsertedLineEnd: "",
		        maybeInsertedBrackets: 0,
		        maybeInsertedRow: -1,
		        maybeInsertedLineStart: "",
		        maybeInsertedLineEnd: ""
		    };
		};
		
		var getWrapped = function(selection, selected, opening, closing) {
		    var rowDiff = selection.end.row - selection.start.row;
		    return {
		        text: opening + selected + closing,
		        selection: [
		                0,
		                selection.start.column + 1,
		                rowDiff,
		                selection.end.column + (rowDiff ? 0 : 1)
		            ]
		    };
		};
		
		var CstyleBehaviour = function(options) {
		    this.add("braces", "insertion", function(state, action, editor, session, text) {
		        var cursor = editor.getCursorPosition();
		        var line = session.doc.getLine(cursor.row);
		        if (text == '{') {
		            initContext(editor);
		            var selection = editor.getSelectionRange();
		            var selected = session.doc.getTextRange(selection);
		            if (selected !== "" && selected !== "{" && editor.getWrapBehavioursEnabled()) {
		                return getWrapped(selection, selected, '{', '}');
		            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
		                if (/[\]\}\)]/.test(line[cursor.column]) || editor.inMultiSelectMode || options && options.braces) {
		                    CstyleBehaviour.recordAutoInsert(editor, session, "}");
		                    return {
		                        text: '{}',
		                        selection: [1, 1]
		                    };
		                } else {
		                    CstyleBehaviour.recordMaybeInsert(editor, session, "{");
		                    return {
		                        text: '{',
		                        selection: [1, 1]
		                    };
		                }
		            }
		        } else if (text == '}') {
		            initContext(editor);
		            var rightChar = line.substring(cursor.column, cursor.column + 1);
		            if (rightChar == '}') {
		                var matching = session.$findOpeningBracket('}', {column: cursor.column + 1, row: cursor.row});
		                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
		                    CstyleBehaviour.popAutoInsertedClosing();
		                    return {
		                        text: '',
		                        selection: [1, 1]
		                    };
		                }
		            }
		        } else if (text == "\n" || text == "\r\n") {
		            initContext(editor);
		            var closing = "";
		            if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
		                closing = lang.stringRepeat("}", context.maybeInsertedBrackets);
		                CstyleBehaviour.clearMaybeInsertedClosing();
		            }
		            var rightChar = line.substring(cursor.column, cursor.column + 1);
		            if (rightChar === '}') {
		                var openBracePos = session.findMatchingBracket({row: cursor.row, column: cursor.column+1}, '}');
		                if (!openBracePos)
		                     return null;
		                var next_indent = this.$getIndent(session.getLine(openBracePos.row));
		            } else if (closing) {
		                var next_indent = this.$getIndent(line);
		            } else {
		                CstyleBehaviour.clearMaybeInsertedClosing();
		                return;
		            }
		            var indent = next_indent + session.getTabString();
		
		            return {
		                text: '\n' + indent + '\n' + next_indent + closing,
		                selection: [1, indent.length, 1, indent.length]
		            };
		        } else {
		            CstyleBehaviour.clearMaybeInsertedClosing();
		        }
		    });
		
		    this.add("braces", "deletion", function(state, action, editor, session, range) {
		        var selected = session.doc.getTextRange(range);
		        if (!range.isMultiLine() && selected == '{') {
		            initContext(editor);
		            var line = session.doc.getLine(range.start.row);
		            var rightChar = line.substring(range.end.column, range.end.column + 1);
		            if (rightChar == '}') {
		                range.end.column++;
		                return range;
		            } else {
		                context.maybeInsertedBrackets--;
		            }
		        }
		    });
		
		    this.add("parens", "insertion", function(state, action, editor, session, text) {
		        if (text == '(') {
		            initContext(editor);
		            var selection = editor.getSelectionRange();
		            var selected = session.doc.getTextRange(selection);
		            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
		                return getWrapped(selection, selected, '(', ')');
		            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
		                CstyleBehaviour.recordAutoInsert(editor, session, ")");
		                return {
		                    text: '()',
		                    selection: [1, 1]
		                };
		            }
		        } else if (text == ')') {
		            initContext(editor);
		            var cursor = editor.getCursorPosition();
		            var line = session.doc.getLine(cursor.row);
		            var rightChar = line.substring(cursor.column, cursor.column + 1);
		            if (rightChar == ')') {
		                var matching = session.$findOpeningBracket(')', {column: cursor.column + 1, row: cursor.row});
		                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
		                    CstyleBehaviour.popAutoInsertedClosing();
		                    return {
		                        text: '',
		                        selection: [1, 1]
		                    };
		                }
		            }
		        }
		    });
		
		    this.add("parens", "deletion", function(state, action, editor, session, range) {
		        var selected = session.doc.getTextRange(range);
		        if (!range.isMultiLine() && selected == '(') {
		            initContext(editor);
		            var line = session.doc.getLine(range.start.row);
		            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
		            if (rightChar == ')') {
		                range.end.column++;
		                return range;
		            }
		        }
		    });
		
		    this.add("brackets", "insertion", function(state, action, editor, session, text) {
		        if (text == '[') {
		            initContext(editor);
		            var selection = editor.getSelectionRange();
		            var selected = session.doc.getTextRange(selection);
		            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
		                return getWrapped(selection, selected, '[', ']');
		            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
		                CstyleBehaviour.recordAutoInsert(editor, session, "]");
		                return {
		                    text: '[]',
		                    selection: [1, 1]
		                };
		            }
		        } else if (text == ']') {
		            initContext(editor);
		            var cursor = editor.getCursorPosition();
		            var line = session.doc.getLine(cursor.row);
		            var rightChar = line.substring(cursor.column, cursor.column + 1);
		            if (rightChar == ']') {
		                var matching = session.$findOpeningBracket(']', {column: cursor.column + 1, row: cursor.row});
		                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
		                    CstyleBehaviour.popAutoInsertedClosing();
		                    return {
		                        text: '',
		                        selection: [1, 1]
		                    };
		                }
		            }
		        }
		    });
		
		    this.add("brackets", "deletion", function(state, action, editor, session, range) {
		        var selected = session.doc.getTextRange(range);
		        if (!range.isMultiLine() && selected == '[') {
		            initContext(editor);
		            var line = session.doc.getLine(range.start.row);
		            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
		            if (rightChar == ']') {
		                range.end.column++;
		                return range;
		            }
		        }
		    });
		
		    this.add("string_dquotes", "insertion", function(state, action, editor, session, text) {
		        var quotes = session.$mode.$quotes || defaultQuotes;
		        if (text.length == 1 && quotes[text]) {
		            if (this.lineCommentStart && this.lineCommentStart.indexOf(text) != -1) 
		                return;
		            initContext(editor);
		            var quote = text;
		            var selection = editor.getSelectionRange();
		            var selected = session.doc.getTextRange(selection);
		            if (selected !== "" && (selected.length != 1 || !quotes[selected]) && editor.getWrapBehavioursEnabled()) {
		                return getWrapped(selection, selected, quote, quote);
		            } else if (!selected) {
		                var cursor = editor.getCursorPosition();
		                var line = session.doc.getLine(cursor.row);
		                var leftChar = line.substring(cursor.column-1, cursor.column);
		                var rightChar = line.substring(cursor.column, cursor.column + 1);
		                
		                var token = session.getTokenAt(cursor.row, cursor.column);
		                var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);
		                // We're escaped.
		                if (leftChar == "\\" && token && /escape/.test(token.type))
		                    return null;
		                
		                var stringBefore = token && /string|escape/.test(token.type);
		                var stringAfter = !rightToken || /string|escape/.test(rightToken.type);
		                
		                var pair;
		                if (rightChar == quote) {
		                    pair = stringBefore !== stringAfter;
		                    if (pair && /string\.end/.test(rightToken.type))
		                        pair = false;
		                } else {
		                    if (stringBefore && !stringAfter)
		                        return null; // wrap string with different quote
		                    if (stringBefore && stringAfter)
		                        return null; // do not pair quotes inside strings
		                    var wordRe = session.$mode.tokenRe;
		                    wordRe.lastIndex = 0;
		                    var isWordBefore = wordRe.test(leftChar);
		                    wordRe.lastIndex = 0;
		                    var isWordAfter = wordRe.test(leftChar);
		                    if (isWordBefore || isWordAfter)
		                        return null; // before or after alphanumeric
		                    if (rightChar && !/[\s;,.})\]\\]/.test(rightChar))
		                        return null; // there is rightChar and it isn't closing
		                    pair = true;
		                }
		                return {
		                    text: pair ? quote + quote : "",
		                    selection: [1,1]
		                };
		            }
		        }
		    });
		
		    this.add("string_dquotes", "deletion", function(state, action, editor, session, range) {
		        var selected = session.doc.getTextRange(range);
		        if (!range.isMultiLine() && (selected == '"' || selected == "'")) {
		            initContext(editor);
		            var line = session.doc.getLine(range.start.row);
		            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
		            if (rightChar == selected) {
		                range.end.column++;
		                return range;
		            }
		        }
		    });
		
		};
		
		    
		CstyleBehaviour.isSaneInsertion = function(editor, session) {
		    var cursor = editor.getCursorPosition();
		    var iterator = new TokenIterator(session, cursor.row, cursor.column);
		    
		    // Don't insert in the middle of a keyword/identifier/lexical
		    if (!this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
		        // Look ahead in case we're at the end of a token
		        var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);
		        if (!this.$matchTokenType(iterator2.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS))
		            return false;
		    }
		    
		    // Only insert in front of whitespace/comments
		    iterator.stepForward();
		    return iterator.getCurrentTokenRow() !== cursor.row ||
		        this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_BEFORE_TOKENS);
		};
		
		CstyleBehaviour.$matchTokenType = function(token, types) {
		    return types.indexOf(token.type || token) > -1;
		};
		
		CstyleBehaviour.recordAutoInsert = function(editor, session, bracket) {
		    var cursor = editor.getCursorPosition();
		    var line = session.doc.getLine(cursor.row);
		    // Reset previous state if text or context changed too much
		    if (!this.isAutoInsertedClosing(cursor, line, context.autoInsertedLineEnd[0]))
		        context.autoInsertedBrackets = 0;
		    context.autoInsertedRow = cursor.row;
		    context.autoInsertedLineEnd = bracket + line.substr(cursor.column);
		    context.autoInsertedBrackets++;
		};
		
		CstyleBehaviour.recordMaybeInsert = function(editor, session, bracket) {
		    var cursor = editor.getCursorPosition();
		    var line = session.doc.getLine(cursor.row);
		    if (!this.isMaybeInsertedClosing(cursor, line))
		        context.maybeInsertedBrackets = 0;
		    context.maybeInsertedRow = cursor.row;
		    context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
		    context.maybeInsertedLineEnd = line.substr(cursor.column);
		    context.maybeInsertedBrackets++;
		};
		
		CstyleBehaviour.isAutoInsertedClosing = function(cursor, line, bracket) {
		    return context.autoInsertedBrackets > 0 &&
		        cursor.row === context.autoInsertedRow &&
		        bracket === context.autoInsertedLineEnd[0] &&
		        line.substr(cursor.column) === context.autoInsertedLineEnd;
		};
		
		CstyleBehaviour.isMaybeInsertedClosing = function(cursor, line) {
		    return context.maybeInsertedBrackets > 0 &&
		        cursor.row === context.maybeInsertedRow &&
		        line.substr(cursor.column) === context.maybeInsertedLineEnd &&
		        line.substr(0, cursor.column) == context.maybeInsertedLineStart;
		};
		
		CstyleBehaviour.popAutoInsertedClosing = function() {
		    context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);
		    context.autoInsertedBrackets--;
		};
		
		CstyleBehaviour.clearMaybeInsertedClosing = function() {
		    if (context) {
		        context.maybeInsertedBrackets = 0;
		        context.maybeInsertedRow = -1;
		    }
		};
		
		
		
		oop.inherits(CstyleBehaviour, Behaviour);
		
		exports.CstyleBehaviour = CstyleBehaviour;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/mode/behaviour/html.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var oop = require("../../lib/oop");
		var XmlBehaviour = require("./xml").XmlBehaviour;
		
		var HtmlBehaviour = function () {
		
		    XmlBehaviour.call(this);
		
		};
		
		oop.inherits(HtmlBehaviour, XmlBehaviour);
		
		exports.HtmlBehaviour = HtmlBehaviour;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/mode/behaviour/xml.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var oop = require("../../lib/oop");
		var Behaviour = require("../behaviour").Behaviour;
		var TokenIterator = require("../../token_iterator").TokenIterator;
		var lang = require("../../lib/lang");
		
		function is(token, type) {
		    return token.type.lastIndexOf(type + ".xml") > -1;
		}
		
		var XmlBehaviour = function () {
		
		    this.add("string_dquotes", "insertion", function (state, action, editor, session, text) {
		        if (text == '"' || text == "'") {
		            var quote = text;
		            var selected = session.doc.getTextRange(editor.getSelectionRange());
		            if (selected !== "" && selected !== "'" && selected != '"' && editor.getWrapBehavioursEnabled()) {
		                return {
		                    text: quote + selected + quote,
		                    selection: false
		                };
		            }
		
		            var cursor = editor.getCursorPosition();
		            var line = session.doc.getLine(cursor.row);
		            var rightChar = line.substring(cursor.column, cursor.column + 1);
		            var iterator = new TokenIterator(session, cursor.row, cursor.column);
		            var token = iterator.getCurrentToken();
		
		            if (rightChar == quote && (is(token, "attribute-value") || is(token, "string"))) {
		                // Ignore input and move right one if we're typing over the closing quote.
		                return {
		                    text: "",
		                    selection: [1, 1]
		                };
		            }
		
		            if (!token)
		                token = iterator.stepBackward();
		
		            if (!token)
		                return;
		
		            while (is(token, "tag-whitespace") || is(token, "whitespace")) {
		                token = iterator.stepBackward();
		            }
		            var rightSpace = !rightChar || rightChar.match(/\s/);
		            if (is(token, "attribute-equals") && (rightSpace || rightChar == '>') || (is(token, "decl-attribute-equals") && (rightSpace || rightChar == '?'))) {
		                return {
		                    text: quote + quote,
		                    selection: [1, 1]
		                };
		            }
		        }
		    });
		
		    this.add("string_dquotes", "deletion", function(state, action, editor, session, range) {
		        var selected = session.doc.getTextRange(range);
		        if (!range.isMultiLine() && (selected == '"' || selected == "'")) {
		            var line = session.doc.getLine(range.start.row);
		            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
		            if (rightChar == selected) {
		                range.end.column++;
		                return range;
		            }
		        }
		    });
		
		    this.add("autoclosing", "insertion", function (state, action, editor, session, text) {
		        if (text == '>') {
		            var position = editor.getSelectionRange().start;
		            var iterator = new TokenIterator(session, position.row, position.column);
		            var token = iterator.getCurrentToken() || iterator.stepBackward();
		
		            // exit if we're not in a tag
		            if (!token || !(is(token, "tag-name") || is(token, "tag-whitespace") || is(token, "attribute-name") || is(token, "attribute-equals") || is(token, "attribute-value")))
		                return;
		
		            // exit if we're inside of a quoted attribute value
		            if (is(token, "reference.attribute-value"))
		                return;
		            if (is(token, "attribute-value")) {
		                var firstChar = token.value.charAt(0);
		                if (firstChar == '"' || firstChar == "'") {
		                    var lastChar = token.value.charAt(token.value.length - 1);
		                    var tokenEnd = iterator.getCurrentTokenColumn() + token.value.length;
		                    if (tokenEnd > position.column || tokenEnd == position.column && firstChar != lastChar)
		                        return;
		                }
		            }
		
		            // find tag name
		            while (!is(token, "tag-name")) {
		                token = iterator.stepBackward();
		                if (token.value == "<") {
		                    token = iterator.stepForward();
		                    break;
		                }
		            }
		
		            var tokenRow = iterator.getCurrentTokenRow();
		            var tokenColumn = iterator.getCurrentTokenColumn();
		
		            // exit if the tag is ending
		            if (is(iterator.stepBackward(), "end-tag-open"))
		                return;
		
		            var element = token.value;
		            if (tokenRow == position.row)
		                element = element.substring(0, position.column - tokenColumn);
		
		            if (this.voidElements.hasOwnProperty(element.toLowerCase()))
		                 return;
		
		            return {
		               text: ">" + "</" + element + ">",
		               selection: [1, 1]
		            };
		        }
		    });
		
		    this.add("autoindent", "insertion", function (state, action, editor, session, text) {
		        if (text == "\n") {
		            var cursor = editor.getCursorPosition();
		            var line = session.getLine(cursor.row);
		            var iterator = new TokenIterator(session, cursor.row, cursor.column);
		            var token = iterator.getCurrentToken();
		
		            if (token && token.type.indexOf("tag-close") !== -1) {
		                if (token.value == "/>")
		                    return;
		                //get tag name
		                while (token && token.type.indexOf("tag-name") === -1) {
		                    token = iterator.stepBackward();
		                }
		
		                if (!token) {
		                    return;
		                }
		
		                var tag = token.value;
		                var row = iterator.getCurrentTokenRow();
		
		                //don't indent after closing tag
		                token = iterator.stepBackward();
		                if (!token || token.type.indexOf("end-tag") !== -1) {
		                    return;
		                }
		
		                if (this.voidElements && !this.voidElements[tag]) {
		                    var nextToken = session.getTokenAt(cursor.row, cursor.column+1);
		                    var line = session.getLine(row);
		                    var nextIndent = this.$getIndent(line);
		                    var indent = nextIndent + session.getTabString();
		
		                    if (nextToken && nextToken.value === "</") {
		                        return {
		                            text: "\n" + indent + "\n" + nextIndent,
		                            selection: [1, indent.length, 1, indent.length]
		                        };
		                    } else {
		                        return {
		                            text: "\n" + indent
		                        };
		                    }
		                }
		            }
		        }
		    });
		
		};
		
		oop.inherits(XmlBehaviour, Behaviour);
		
		exports.XmlBehaviour = XmlBehaviour;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/mode/behaviour.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var Behaviour = function() {
		   this.$behaviours = {};
		};
		
		(function () {
		
		    this.add = function (name, action, callback) {
		        switch (undefined) {
		          case this.$behaviours:
		              this.$behaviours = {};
		          case this.$behaviours[name]:
		              this.$behaviours[name] = {};
		        }
		        this.$behaviours[name][action] = callback;
		    }
		    
		    this.addBehaviours = function (behaviours) {
		        for (var key in behaviours) {
		            for (var action in behaviours[key]) {
		                this.add(key, action, behaviours[key][action]);
		            }
		        }
		    }
		    
		    this.remove = function (name) {
		        if (this.$behaviours && this.$behaviours[name]) {
		            delete this.$behaviours[name];
		        }
		    }
		    
		    this.inherit = function (mode, filter) {
		        if (typeof mode === "function") {
		            var behaviours = new mode().getBehaviours(filter);
		        } else {
		            var behaviours = mode.getBehaviours(filter);
		        }
		        this.addBehaviours(behaviours);
		    }
		    
		    this.getBehaviours = function (filter) {
		        if (!filter) {
		            return this.$behaviours;
		        } else {
		            var ret = {}
		            for (var i = 0; i < filter.length; i++) {
		                if (this.$behaviours[filter[i]]) {
		                    ret[filter[i]] = this.$behaviours[filter[i]];
		                }
		            }
		            return ret;
		        }
		    }
		
		}).call(Behaviour.prototype);
		
		exports.Behaviour = Behaviour;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/mode/doc_comment_highlight_rules.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var oop = require("../lib/oop");
		var TextHighlightRules = require("./text/text_highlight_rules").TextHighlightRules;
		
		var DocCommentHighlightRules = function() {
		    this.$rules = {
		        "start" : [ {
		            token : "comment.doc.tag",
		            regex : "@[\\w\\d_]+" // TODO: fix email addresses
		        }, 
		        DocCommentHighlightRules.getTagRule(),
		        {
		            defaultToken : "comment.doc",
		            caseInsensitive: true
		        }]
		    };
		};
		
		oop.inherits(DocCommentHighlightRules, TextHighlightRules);
		
		DocCommentHighlightRules.getTagRule = function(start) {
		    return {
		        token : "comment.doc.tag.storage.type",
		        regex : "\\b(?:TODO|FIXME|XXX|HACK)\\b"
		    };
		}
		
		DocCommentHighlightRules.getStartRule = function(start) {
		    return {
		        token : "comment.doc", // doc comment
		        regex : "\\/\\*(?=\\*)",
		        next  : start
		    };
		};
		
		DocCommentHighlightRules.getEndRule = function (start) {
		    return {
		        token : "comment.doc", // closing comment
		        regex : "\\*\\/",
		        next  : start
		    };
		};
		
		
		exports.DocCommentHighlightRules = DocCommentHighlightRules;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/mode/folding/coffee.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var oop = require("../../lib/oop");
		var BaseFoldMode = require("./fold_mode").FoldMode;
		var Range = require("../../range").Range;
		
		var FoldMode = exports.FoldMode = function() {};
		oop.inherits(FoldMode, BaseFoldMode);
		
		(function() {
		
		    this.getFoldWidgetRange = function(session, foldStyle, row) {
		        var range = this.indentationBlock(session, row);
		        if (range)
		            return range;
		
		        var re = /\S/;
		        var line = session.getLine(row);
		        var startLevel = line.search(re);
		        if (startLevel == -1 || line[startLevel] != "#")
		            return;
		
		        var startColumn = line.length;
		        var maxRow = session.getLength();
		        var startRow = row;
		        var endRow = row;
		
		        while (++row < maxRow) {
		            line = session.getLine(row);
		            var level = line.search(re);
		
		            if (level == -1)
		                continue;
		
		            if (line[level] != "#")
		                break;
		
		            endRow = row;
		        }
		
		        if (endRow > startRow) {
		            var endColumn = session.getLine(endRow).length;
		            return new Range(startRow, startColumn, endRow, endColumn);
		        }
		    };
		
		    // must return "" if there's no fold, to enable caching
		    this.getFoldWidget = function(session, foldStyle, row) {
		        var line = session.getLine(row);
		        var indent = line.search(/\S/);
		        var next = session.getLine(row + 1);
		        var prev = session.getLine(row - 1);
		        var prevIndent = prev.search(/\S/);
		        var nextIndent = next.search(/\S/);
		
		        if (indent == -1) {
		            session.foldWidgets[row - 1] = prevIndent!= -1 && prevIndent < nextIndent ? "start" : "";
		            return "";
		        }
		
		        // documentation comments
		        if (prevIndent == -1) {
		            if (indent == nextIndent && line[indent] == "#" && next[indent] == "#") {
		                session.foldWidgets[row - 1] = "";
		                session.foldWidgets[row + 1] = "";
		                return "start";
		            }
		        } else if (prevIndent == indent && line[indent] == "#" && prev[indent] == "#") {
		            if (session.getLine(row - 2).search(/\S/) == -1) {
		                session.foldWidgets[row - 1] = "start";
		                session.foldWidgets[row + 1] = "";
		                return "";
		            }
		        }
		
		        if (prevIndent!= -1 && prevIndent < indent)
		            session.foldWidgets[row - 1] = "start";
		        else
		            session.foldWidgets[row - 1] = "";
		
		        if (indent < nextIndent)
		            return "start";
		        else
		            return "";
		    };
		
		}).call(FoldMode.prototype);
		
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/mode/folding/cstyle.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var oop = require("../../lib/oop");
		var Range = require("../../range").Range;
		var BaseFoldMode = require("./fold_mode").FoldMode;
		
		var FoldMode = exports.FoldMode = function(commentRegex) {
		    if (commentRegex) {
		        this.foldingStartMarker = new RegExp(
		            this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start)
		        );
		        this.foldingStopMarker = new RegExp(
		            this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end)
		        );
		    }
		};
		oop.inherits(FoldMode, BaseFoldMode);
		
		(function() {
		    
		    this.foldingStartMarker = /(\{|\[)[^\}\]]*$|^\s*(\/\*)/;
		    this.foldingStopMarker = /^[^\[\{]*(\}|\])|^[\s\*]*(\*\/)/;
		    this.singleLineBlockCommentRe= /^\s*(\/\*).*\*\/\s*$/;
		    this.tripleStarBlockCommentRe = /^\s*(\/\*\*\*).*\*\/\s*$/;
		    this.startRegionRe = /^\s*(\/\*|\/\/)#?region\b/;
		    
		    //prevent naming conflict with any modes that inherit from cstyle and override this (like csharp)
		    this._getFoldWidgetBase = this.getFoldWidget;
		    
		    /**
		     * Gets fold widget with some non-standard extras:
		     *
		     * @example lineCommentRegionStart
		     *      //#region [optional description]
		     *
		     * @example blockCommentRegionStart
		     *      /*#region [optional description] *[/]
		     *
		     * @example tripleStarFoldingSection
		     *      /*** this folds even though 1 line because it has 3 stars ***[/]
		     * 
		     * @note the pound symbol for region tags is optional
		     */
		    this.getFoldWidget = function(session, foldStyle, row) {
		        var line = session.getLine(row);
		    
		        if (this.singleLineBlockCommentRe.test(line)) {
		            // No widget for single line block comment unless region or triple star
		            if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line))
		                return "";
		        }
		    
		        var fw = this._getFoldWidgetBase(session, foldStyle, row);
		    
		        if (!fw && this.startRegionRe.test(line))
		            return "start"; // lineCommentRegionStart
		    
		        return fw;
		    };
		
		    this.getFoldWidgetRange = function(session, foldStyle, row, forceMultiline) {
		        var line = session.getLine(row);
		        
		        if (this.startRegionRe.test(line))
		            return this.getCommentRegionBlock(session, line, row);
		        
		        var match = line.match(this.foldingStartMarker);
		        if (match) {
		            var i = match.index;
		
		            if (match[1])
		                return this.openingBracketBlock(session, match[1], row, i);
		                
		            var range = session.getCommentFoldRange(row, i + match[0].length, 1);
		            
		            if (range && !range.isMultiLine()) {
		                if (forceMultiline) {
		                    range = this.getSectionRange(session, row);
		                } else if (foldStyle != "all")
		                    range = null;
		            }
		            
		            return range;
		        }
		
		        if (foldStyle === "markbegin")
		            return;
		
		        var match = line.match(this.foldingStopMarker);
		        if (match) {
		            var i = match.index + match[0].length;
		
		            if (match[1])
		                return this.closingBracketBlock(session, match[1], row, i);
		
		            return session.getCommentFoldRange(row, i, -1);
		        }
		    };
		    
		    this.getSectionRange = function(session, row) {
		        var line = session.getLine(row);
		        var startIndent = line.search(/\S/);
		        var startRow = row;
		        var startColumn = line.length;
		        row = row + 1;
		        var endRow = row;
		        var maxRow = session.getLength();
		        while (++row < maxRow) {
		            line = session.getLine(row);
		            var indent = line.search(/\S/);
		            if (indent === -1)
		                continue;
		            if  (startIndent > indent)
		                break;
		            var subRange = this.getFoldWidgetRange(session, "all", row);
		            
		            if (subRange) {
		                if (subRange.start.row <= startRow) {
		                    break;
		                } else if (subRange.isMultiLine()) {
		                    row = subRange.end.row;
		                } else if (startIndent == indent) {
		                    break;
		                }
		            }
		            endRow = row;
		        }
		        
		        return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);
		    };
		    
		    /**
		     * gets comment region block with end region assumed to be start of comment in any cstyle mode or SQL mode (--) which inherits from this.
		     * There may optionally be a pound symbol before the region/endregion statement
		     */
		    this.getCommentRegionBlock = function(session, line, row) {
		        var startColumn = line.search(/\s*$/);
		        var maxRow = session.getLength();
		        var startRow = row;
		        
		        var re = /^\s*(?:\/\*|\/\/|--)#?(end)?region\b/;
		        var depth = 1;
		        while (++row < maxRow) {
		            line = session.getLine(row);
		            var m = re.exec(line);
		            if (!m) continue;
		            if (m[1]) depth--;
		            else depth++;
		
		            if (!depth) break;
		        }
		
		        var endRow = row;
		        if (endRow > startRow) {
		            return new Range(startRow, startColumn, endRow, line.length);
		        }
		    };
		
		}).call(FoldMode.prototype);
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/mode/folding/fold_mode.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var Range = require("../../range").Range;
		
		var FoldMode = exports.FoldMode = function() {};
		
		(function() {
		
		    this.foldingStartMarker = null;
		    this.foldingStopMarker = null;
		
		    // must return "" if there's no fold, to enable caching
		    this.getFoldWidget = function(session, foldStyle, row) {
		        var line = session.getLine(row);
		        if (this.foldingStartMarker.test(line))
		            return "start";
		        if (foldStyle == "markbeginend"
		                && this.foldingStopMarker
		                && this.foldingStopMarker.test(line))
		            return "end";
		        return "";
		    };
		
		    this.getFoldWidgetRange = function(session, foldStyle, row) {
		        return null;
		    };
		
		    this.indentationBlock = function(session, row, column) {
		        var re = /\S/;
		        var line = session.getLine(row);
		        var startLevel = line.search(re);
		        if (startLevel == -1)
		            return;
		
		        var startColumn = column || line.length;
		        var maxRow = session.getLength();
		        var startRow = row;
		        var endRow = row;
		
		        while (++row < maxRow) {
		            var level = session.getLine(row).search(re);
		
		            if (level == -1)
		                continue;
		
		            if (level <= startLevel)
		                break;
		
		            endRow = row;
		        }
		
		        if (endRow > startRow) {
		            var endColumn = session.getLine(endRow).length;
		            return new Range(startRow, startColumn, endRow, endColumn);
		        }
		    };
		
		    this.openingBracketBlock = function(session, bracket, row, column, typeRe) {
		        var start = {row: row, column: column + 1};
		        var end = session.$findClosingBracket(bracket, start, typeRe);
		        if (!end)
		            return;
		
		        var fw = session.foldWidgets[end.row];
		        if (fw == null)
		            fw = session.getFoldWidget(end.row);
		
		        if (fw == "start" && end.row > start.row) {
		            end.row --;
		            end.column = session.getLine(end.row).length;
		        }
		        return Range.fromPoints(start, end);
		    };
		
		    this.closingBracketBlock = function(session, bracket, row, column, typeRe) {
		        var end = {row: row, column: column};
		        var start = session.$findOpeningBracket(bracket, end);
		
		        if (!start)
		            return;
		
		        start.column++;
		        end.column--;
		
		        return  Range.fromPoints(start, end);
		    };
		}).call(FoldMode.prototype);
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/mode/folding/html.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var oop = require("../../lib/oop");
		var MixedFoldMode = require("./mixed").FoldMode;
		var XmlFoldMode = require("./xml").FoldMode;
		var CStyleFoldMode = require("./cstyle").FoldMode;
		
		var FoldMode = exports.FoldMode = function(voidElements, optionalTags) {
		    MixedFoldMode.call(this, new XmlFoldMode(voidElements, optionalTags), {
		        "js-": new CStyleFoldMode(),
		        "css-": new CStyleFoldMode()
		    });
		};
		
		oop.inherits(FoldMode, MixedFoldMode);
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/mode/folding/ini.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var oop = require("../../lib/oop");
		var Range = require("../../range").Range;
		var BaseFoldMode = require("./fold_mode").FoldMode;
		
		var FoldMode = exports.FoldMode = function() {
		};
		oop.inherits(FoldMode, BaseFoldMode);
		
		(function() {
		
		    this.foldingStartMarker = /^\s*\[([^\])]*)]\s*(?:$|[;#])/;
		
		    this.getFoldWidgetRange = function(session, foldStyle, row) {
		        var re = this.foldingStartMarker;
		        var line = session.getLine(row);
		        
		        var m = line.match(re);
		        
		        if (!m) return;
		        
		        var startName = m[1] + ".";
		        
		        var startColumn = line.length;
		        var maxRow = session.getLength();
		        var startRow = row;
		        var endRow = row;
		
		        while (++row < maxRow) {
		            line = session.getLine(row);
		            if (/^\s*$/.test(line))
		                continue;
		            m = line.match(re);
		            if (m && m[1].lastIndexOf(startName, 0) !== 0)
		                break;
		
		            endRow = row;
		        }
		
		        if (endRow > startRow) {
		            var endColumn = session.getLine(endRow).length;
		            return new Range(startRow, startColumn, endRow, endColumn);
		        }
		    };
		
		}).call(FoldMode.prototype);
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/mode/folding/markdown.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var oop = require("../../lib/oop");
		var BaseFoldMode = require("./fold_mode").FoldMode;
		var Range = require("../../range").Range;
		
		var FoldMode = exports.FoldMode = function() {};
		oop.inherits(FoldMode, BaseFoldMode);
		
		(function() {
		    this.foldingStartMarker = /^(?:[=-]+\s*$|#{1,6} |`{3})/;
		
		    this.getFoldWidget = function(session, foldStyle, row) {
		        var line = session.getLine(row);
		        if (!this.foldingStartMarker.test(line))
		            return "";
		
		        if (line[0] == "`") {
		            if (session.bgTokenizer.getState(row) == "start")
		                return "end";
		            return "start";
		        }
		
		        return "start";
		    };
		
		    this.getFoldWidgetRange = function(session, foldStyle, row) {
		        var line = session.getLine(row);
		        var startColumn = line.length;
		        var maxRow = session.getLength();
		        var startRow = row;
		        var endRow = row;
		        if (!line.match(this.foldingStartMarker))
		            return;
		
		        if (line[0] == "`") {
		            if (session.bgTokenizer.getState(row) !== "start") {
		                while (++row < maxRow) {
		                    line = session.getLine(row);
		                    if (line[0] == "`" & line.substring(0, 3) == "```")
		                        break;
		                }
		                return new Range(startRow, startColumn, row, 0);
		            } else {
		                while (row -- > 0) {
		                    line = session.getLine(row);
		                    if (line[0] == "`" & line.substring(0, 3) == "```")
		                        break;
		                }
		                return new Range(row, line.length, startRow, 0);
		            }
		        }
		
		        var token;
		        function isHeading(row) {
		            token = session.getTokens(row)[0];
		            return token && token.type.lastIndexOf(heading, 0) === 0;
		        }
		
		        var heading = "markup.heading";
		        function getLevel() {
		            var ch = token.value[0];
		            if (ch == "=") return 6;
		            if (ch == "-") return 5;
		            return 7 - token.value.search(/[^#]/);
		        }
		
		        if (isHeading(row)) {
		            var startHeadingLevel = getLevel();
		            while (++row < maxRow) {
		                if (!isHeading(row))
		                    continue;
		                var level = getLevel();
		                if (level >= startHeadingLevel)
		                    break;
		            }
		
		            endRow = row - (!token || ["=", "-"].indexOf(token.value[0]) == -1 ? 1 : 2);
		
		            if (endRow > startRow) {
		                while (endRow > startRow && /^\s*$/.test(session.getLine(endRow)))
		                    endRow--;
		            }
		
		            if (endRow > startRow) {
		                var endColumn = session.getLine(endRow).length;
		                return new Range(startRow, startColumn, endRow, endColumn);
		            }
		        }
		    };
		
		}).call(FoldMode.prototype);
		
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/mode/folding/mixed.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var oop = require("../../lib/oop");
		var BaseFoldMode = require("./fold_mode").FoldMode;
		
		var FoldMode = exports.FoldMode = function(defaultMode, subModes) {
		    this.defaultMode = defaultMode;
		    this.subModes = subModes;
		};
		oop.inherits(FoldMode, BaseFoldMode);
		
		(function() {
		
		
		    this.$getMode = function(state) {
		        if (typeof state != "string") 
		            state = state[0];
		        for (var key in this.subModes) {
		            if (state.indexOf(key) === 0)
		                return this.subModes[key];
		        }
		        return null;
		    };
		    
		    this.$tryMode = function(state, session, foldStyle, row) {
		        var mode = this.$getMode(state);
		        return (mode ? mode.getFoldWidget(session, foldStyle, row) : "");
		    };
		
		    this.getFoldWidget = function(session, foldStyle, row) {
		        return (
		            this.$tryMode(session.getState(row-1), session, foldStyle, row) ||
		            this.$tryMode(session.getState(row), session, foldStyle, row) ||
		            this.defaultMode.getFoldWidget(session, foldStyle, row)
		        );
		    };
		
		    this.getFoldWidgetRange = function(session, foldStyle, row) {
		        var mode = this.$getMode(session.getState(row-1));
		        
		        if (!mode || !mode.getFoldWidget(session, foldStyle, row))
		            mode = this.$getMode(session.getState(row));
		        
		        if (!mode || !mode.getFoldWidget(session, foldStyle, row))
		            mode = this.defaultMode;
		        
		        return mode.getFoldWidgetRange(session, foldStyle, row);
		    };
		
		}).call(FoldMode.prototype);
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/mode/folding/pythonic.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		"use strict";
		
		var oop = require("../../lib/oop");
		var BaseFoldMode = require("./fold_mode").FoldMode;
		
		var FoldMode = exports.FoldMode = function(markers) {
		    this.foldingStartMarker = new RegExp("([\\[{])(?:\\s*)$|(" + markers + ")(?:\\s*)(?:#.*)?$");
		};
		oop.inherits(FoldMode, BaseFoldMode);
		
		(function() {
		
		    this.getFoldWidgetRange = function(session, foldStyle, row) {
		        var line = session.getLine(row);
		        var match = line.match(this.foldingStartMarker);
		        if (match) {
		            if (match[1])
		                return this.openingBracketBlock(session, match[1], row, match.index);
		            if (match[2])
		                return this.indentationBlock(session, row, match.index + match[2].length);
		            return this.indentationBlock(session, row);
		        }
		    }
		
		}).call(FoldMode.prototype);
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/mode/folding/xml.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var oop = require("../../lib/oop");
		var lang = require("../../lib/lang");
		var Range = require("../../range").Range;
		var BaseFoldMode = require("./fold_mode").FoldMode;
		var TokenIterator = require("../../token_iterator").TokenIterator;
		
		var FoldMode = exports.FoldMode = function(voidElements, optionalEndTags) {
		    BaseFoldMode.call(this);
		    this.voidElements = voidElements || {};
		    this.optionalEndTags = oop.mixin({}, this.voidElements);
		    if (optionalEndTags)
		        oop.mixin(this.optionalEndTags, optionalEndTags);
		    
		};
		oop.inherits(FoldMode, BaseFoldMode);
		
		var Tag = function() {
		    this.tagName = "";
		    this.closing = false;
		    this.selfClosing = false;
		    this.start = {row: 0, column: 0};
		    this.end = {row: 0, column: 0};
		};
		
		function is(token, type) {
		    return token.type.lastIndexOf(type + ".xml") > -1;
		}
		
		(function() {
		
		    this.getFoldWidget = function(session, foldStyle, row) {
		        var tag = this._getFirstTagInLine(session, row);
		
		        if (!tag)
		            return this.getCommentFoldWidget(session, row);
		
		        if (tag.closing || (!tag.tagName && tag.selfClosing))
		            return foldStyle == "markbeginend" ? "end" : "";
		
		        if (!tag.tagName || tag.selfClosing || this.voidElements.hasOwnProperty(tag.tagName.toLowerCase()))
		            return "";
		
		        if (this._findEndTagInLine(session, row, tag.tagName, tag.end.column))
		            return "";
		
		        return "start";
		    };
		    
		    this.getCommentFoldWidget = function(session, row) {
		        if (/comment/.test(session.getState(row)) && /<!-/.test(session.getLine(row)))
		            return "start";
		        return "";
		    }
		
		    /*
		     * returns a first tag (or a fragment) in a line
		     */
		    this._getFirstTagInLine = function(session, row) {
		        var tokens = session.getTokens(row);
		        var tag = new Tag();
		
		        for (var i = 0; i < tokens.length; i++) {
		            var token = tokens[i];
		            if (is(token, "tag-open")) {
		                tag.end.column = tag.start.column + token.value.length;
		                tag.closing = is(token, "end-tag-open");
		                token = tokens[++i];
		                if (!token)
		                    return null;
		                tag.tagName = token.value;
		                tag.end.column += token.value.length;
		                for (i++; i < tokens.length; i++) {
		                    token = tokens[i];
		                    tag.end.column += token.value.length;
		                    if (is(token, "tag-close")) {
		                        tag.selfClosing = token.value == '/>';
		                        break;
		                    }
		                }
		                return tag;
		            } else if (is(token, "tag-close")) {
		                tag.selfClosing = token.value == '/>';
		                return tag;
		            }
		            tag.start.column += token.value.length;
		        }
		
		        return null;
		    };
		
		    this._findEndTagInLine = function(session, row, tagName, startColumn) {
		        var tokens = session.getTokens(row);
		        var column = 0;
		        for (var i = 0; i < tokens.length; i++) {
		            var token = tokens[i];
		            column += token.value.length;
		            if (column < startColumn)
		                continue;
		            if (is(token, "end-tag-open")) {
		                token = tokens[i + 1];
		                if (token && token.value == tagName)
		                    return true;
		            }
		        }
		        return false;
		    };
		
		    /*
		     * reads a full tag and places the iterator after the tag
		     */
		    this._readTagForward = function(iterator) {
		        var token = iterator.getCurrentToken();
		        if (!token)
		            return null;
		
		        var tag = new Tag();
		        do {
		            if (is(token, "tag-open")) {
		                tag.closing = is(token, "end-tag-open");
		                tag.start.row = iterator.getCurrentTokenRow();
		                tag.start.column = iterator.getCurrentTokenColumn();
		            } else if (is(token, "tag-name")) {
		                tag.tagName = token.value;
		            } else if (is(token, "tag-close")) {
		                tag.selfClosing = token.value == "/>";
		                tag.end.row = iterator.getCurrentTokenRow();
		                tag.end.column = iterator.getCurrentTokenColumn() + token.value.length;
		                iterator.stepForward();
		                return tag;
		            }
		        } while(token = iterator.stepForward());
		
		        return null;
		    };
		    
		    this._readTagBackward = function(iterator) {
		        var token = iterator.getCurrentToken();
		        if (!token)
		            return null;
		
		        var tag = new Tag();
		        do {
		            if (is(token, "tag-open")) {
		                tag.closing = is(token, "end-tag-open");
		                tag.start.row = iterator.getCurrentTokenRow();
		                tag.start.column = iterator.getCurrentTokenColumn();
		                iterator.stepBackward();
		                return tag;
		            } else if (is(token, "tag-name")) {
		                tag.tagName = token.value;
		            } else if (is(token, "tag-close")) {
		                tag.selfClosing = token.value == "/>";
		                tag.end.row = iterator.getCurrentTokenRow();
		                tag.end.column = iterator.getCurrentTokenColumn() + token.value.length;
		            }
		        } while(token = iterator.stepBackward());
		
		        return null;
		    };
		    
		    this._pop = function(stack, tag) {
		        while (stack.length) {
		            
		            var top = stack[stack.length-1];
		            if (!tag || top.tagName == tag.tagName) {
		                return stack.pop();
		            }
		            else if (this.optionalEndTags.hasOwnProperty(top.tagName)) {
		                stack.pop();
		                continue;
		            } else {
		                return null;
		            }
		        }
		    };
		    
		    this.getFoldWidgetRange = function(session, foldStyle, row) {
		        var firstTag = this._getFirstTagInLine(session, row);
		        
		        if (!firstTag) {
		            return this.getCommentFoldWidget(session, row)
		                && session.getCommentFoldRange(row, session.getLine(row).length);
		        }
		        
		        var isBackward = firstTag.closing || firstTag.selfClosing;
		        var stack = [];
		        var tag;
		        
		        if (!isBackward) {
		            var iterator = new TokenIterator(session, row, firstTag.start.column);
		            var start = {
		                row: row,
		                column: firstTag.start.column + firstTag.tagName.length + 2
		            };
		            if (firstTag.start.row == firstTag.end.row)
		                start.column = firstTag.end.column;
		            while (tag = this._readTagForward(iterator)) {
		                if (tag.selfClosing) {
		                    if (!stack.length) {
		                        tag.start.column += tag.tagName.length + 2;
		                        tag.end.column -= 2;
		                        return Range.fromPoints(tag.start, tag.end);
		                    } else
		                        continue;
		                }
		                
		                if (tag.closing) {
		                    this._pop(stack, tag);
		                    if (stack.length == 0)
		                        return Range.fromPoints(start, tag.start);
		                }
		                else {
		                    stack.push(tag);
		                }
		            }
		        }
		        else {
		            var iterator = new TokenIterator(session, row, firstTag.end.column);
		            var end = {
		                row: row,
		                column: firstTag.start.column
		            };
		            
		            while (tag = this._readTagBackward(iterator)) {
		                if (tag.selfClosing) {
		                    if (!stack.length) {
		                        tag.start.column += tag.tagName.length + 2;
		                        tag.end.column -= 2;
		                        return Range.fromPoints(tag.start, tag.end);
		                    } else
		                        continue;
		                }
		                
		                if (!tag.closing) {
		                    this._pop(stack, tag);
		                    if (stack.length == 0) {
		                        tag.start.column += tag.tagName.length + 2;
		                        if (tag.start.row == tag.end.row && tag.start.column < tag.end.column)
		                            tag.start.column = tag.end.column;
		                        return Range.fromPoints(tag.start, end);
		                    }
		                }
		                else {
		                    stack.push(tag);
		                }
		            }
		        }
		        
		    };
		
		}).call(FoldMode.prototype);
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/mode/matching_brace_outdent.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var Range = require("../range").Range;
		
		var MatchingBraceOutdent = function() {};
		
		(function() {
		
		    this.checkOutdent = function(line, input) {
		        if (! /^\s+$/.test(line))
		            return false;
		
		        return /^\s*\}/.test(input);
		    };
		
		    this.autoOutdent = function(doc, row) {
		        var line = doc.getLine(row);
		        var match = line.match(/^(\s*\})/);
		
		        if (!match) return 0;
		
		        var column = match[1].length;
		        var openBracePos = doc.findMatchingBracket({row: row, column: column});
		
		        if (!openBracePos || openBracePos.row == row) return 0;
		
		        var indent = this.$getIndent(doc.getLine(openBracePos.row));
		        doc.replace(new Range(row, 0, row, column-1), indent);
		    };
		
		    this.$getIndent = function(line) {
		        return line.match(/^\s*/)[0];
		    };
		
		}).call(MatchingBraceOutdent.prototype);
		
		exports.MatchingBraceOutdent = MatchingBraceOutdent;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/mode/text/index.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var Tokenizer = require("../../tokenizer").Tokenizer;
		var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
		var CstyleBehaviour = require("../behaviour/cstyle").CstyleBehaviour;
		var unicode = require("../../unicode");
		var lang = require("../../lib/lang");
		var TokenIterator = require("../../token_iterator").TokenIterator;
		var Range = require("../../range").Range;
		
		var Mode = function() {
		    this.HighlightRules = TextHighlightRules;
		};
		
		(function() {
		    this.$defaultBehaviour = new CstyleBehaviour();
		
		    this.tokenRe = new RegExp("^[" + unicode.wordChars + "\\$_]+", "g");
		
		    this.nonTokenRe = new RegExp("^(?:[^" + unicode.wordChars + "\\$_]|\\s])+", "g");
		
		    this.getTokenizer = function() {
		        if (!this.$tokenizer) {
		            this.$highlightRules = this.$highlightRules || new this.HighlightRules(this.$highlightRuleConfig);
		            this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
		        }
		        return this.$tokenizer;
		    };
		
		    this.lineCommentStart = "";
		    this.blockComment = "";
		
		    this.toggleCommentLines = function(state, session, startRow, endRow) {
		        var doc = session.doc;
		
		        var ignoreBlankLines = true;
		        var shouldRemove = true;
		        var minIndent = Infinity;
		        var tabSize = session.getTabSize();
		        var insertAtTabStop = false;
		
		        if (!this.lineCommentStart) {
		            if (!this.blockComment)
		                return false;
		            var lineCommentStart = this.blockComment.start;
		            var lineCommentEnd = this.blockComment.end;
		            var regexpStart = new RegExp("^(\\s*)(?:" + lang.escapeRegExp(lineCommentStart) + ")");
		            var regexpEnd = new RegExp("(?:" + lang.escapeRegExp(lineCommentEnd) + ")\\s*$");
		
		            var comment = function(line, i) {
		                if (testRemove(line, i))
		                    return;
		                if (!ignoreBlankLines || /\S/.test(line)) {
		                    doc.insertInLine({row: i, column: line.length}, lineCommentEnd);
		                    doc.insertInLine({row: i, column: minIndent}, lineCommentStart);
		                }
		            };
		
		            var uncomment = function(line, i) {
		                var m;
		                if (m = line.match(regexpEnd))
		                    doc.removeInLine(i, line.length - m[0].length, line.length);
		                if (m = line.match(regexpStart))
		                    doc.removeInLine(i, m[1].length, m[0].length);
		            };
		
		            var testRemove = function(line, row) {
		                if (regexpStart.test(line))
		                    return true;
		                var tokens = session.getTokens(row);
		                for (var i = 0; i < tokens.length; i++) {
		                    if (tokens[i].type === "comment")
		                        return true;
		                }
		            };
		        } else {
		            if (Array.isArray(this.lineCommentStart)) {
		                var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join("|");
		                var lineCommentStart = this.lineCommentStart[0];
		            } else {
		                var regexpStart = lang.escapeRegExp(this.lineCommentStart);
		                var lineCommentStart = this.lineCommentStart;
		            }
		            regexpStart = new RegExp("^(\\s*)(?:" + regexpStart + ") ?");
		            
		            insertAtTabStop = session.getUseSoftTabs();
		
		            var uncomment = function(line, i) {
		                var m = line.match(regexpStart);
		                if (!m) return;
		                var start = m[1].length, end = m[0].length;
		                if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == " ")
		                    end--;
		                doc.removeInLine(i, start, end);
		            };
		            var commentWithSpace = lineCommentStart + " ";
		            var comment = function(line, i) {
		                if (!ignoreBlankLines || /\S/.test(line)) {
		                    if (shouldInsertSpace(line, minIndent, minIndent))
		                        doc.insertInLine({row: i, column: minIndent}, commentWithSpace);
		                    else
		                        doc.insertInLine({row: i, column: minIndent}, lineCommentStart);
		                }
		            };
		            var testRemove = function(line, i) {
		                return regexpStart.test(line);
		            };
		            
		            var shouldInsertSpace = function(line, before, after) {
		                var spaces = 0;
		                while (before-- && line.charAt(before) == " ")
		                    spaces++;
		                if (spaces % tabSize != 0)
		                    return false;
		                var spaces = 0;
		                while (line.charAt(after++) == " ")
		                    spaces++;
		                if (tabSize > 2)
		                    return spaces % tabSize != tabSize - 1;
		                else
		                    return spaces % tabSize == 0;
		            };
		        }
		
		        function iter(fun) {
		            for (var i = startRow; i <= endRow; i++)
		                fun(doc.getLine(i), i);
		        }
		
		
		        var minEmptyLength = Infinity;
		        iter(function(line, i) {
		            var indent = line.search(/\S/);
		            if (indent !== -1) {
		                if (indent < minIndent)
		                    minIndent = indent;
		                if (shouldRemove && !testRemove(line, i))
		                    shouldRemove = false;
		            } else if (minEmptyLength > line.length) {
		                minEmptyLength = line.length;
		            }
		        });
		
		        if (minIndent == Infinity) {
		            minIndent = minEmptyLength;
		            ignoreBlankLines = false;
		            shouldRemove = false;
		        }
		
		        if (insertAtTabStop && minIndent % tabSize != 0)
		            minIndent = Math.floor(minIndent / tabSize) * tabSize;
		
		        iter(shouldRemove ? uncomment : comment);
		    };
		
		    this.toggleBlockComment = function(state, session, range, cursor) {
		        var comment = this.blockComment;
		        if (!comment)
		            return;
		        if (!comment.start && comment[0])
		            comment = comment[0];
		
		        var iterator = new TokenIterator(session, cursor.row, cursor.column);
		        var token = iterator.getCurrentToken();
		
		        var sel = session.selection;
		        var initialRange = session.selection.toOrientedRange();
		        var startRow, colDiff;
		
		        if (token && /comment/.test(token.type)) {
		            var startRange, endRange;
		            while (token && /comment/.test(token.type)) {
		                var i = token.value.indexOf(comment.start);
		                if (i != -1) {
		                    var row = iterator.getCurrentTokenRow();
		                    var column = iterator.getCurrentTokenColumn() + i;
		                    startRange = new Range(row, column, row, column + comment.start.length);
		                    break;
		                }
		                token = iterator.stepBackward();
		            }
		
		            var iterator = new TokenIterator(session, cursor.row, cursor.column);
		            var token = iterator.getCurrentToken();
		            while (token && /comment/.test(token.type)) {
		                var i = token.value.indexOf(comment.end);
		                if (i != -1) {
		                    var row = iterator.getCurrentTokenRow();
		                    var column = iterator.getCurrentTokenColumn() + i;
		                    endRange = new Range(row, column, row, column + comment.end.length);
		                    break;
		                }
		                token = iterator.stepForward();
		            }
		            if (endRange)
		                session.remove(endRange);
		            if (startRange) {
		                session.remove(startRange);
		                startRow = startRange.start.row;
		                colDiff = -comment.start.length;
		            }
		        } else {
		            colDiff = comment.start.length;
		            startRow = range.start.row;
		            session.insert(range.end, comment.end);
		            session.insert(range.start, comment.start);
		        }
		        // todo: selection should have ended up in the right place automatically!
		        if (initialRange.start.row == startRow)
		            initialRange.start.column += colDiff;
		        if (initialRange.end.row == startRow)
		            initialRange.end.column += colDiff;
		        session.selection.fromOrientedRange(initialRange);
		    };
		
		    this.getNextLineIndent = function(state, line, tab) {
		        return this.$getIndent(line);
		    };
		
		    this.checkOutdent = function(state, line, input) {
		        return false;
		    };
		
		    this.autoOutdent = function(state, doc, row) {
		    };
		
		    this.$getIndent = function(line) {
		        return line.match(/^\s*/)[0];
		    };
		
		    this.createWorker = function(session) {
		        return null;
		    };
		
		    this.createModeDelegates = function (mapping) {
		        this.$embeds = [];
		        this.$modes = {};
		        for (var i in mapping) {
		            if (mapping[i]) {
		                this.$embeds.push(i);
		                this.$modes[i] = new mapping[i]();
		            }
		        }
		
		        var delegations = ["toggleBlockComment", "toggleCommentLines", "getNextLineIndent", 
		            "checkOutdent", "autoOutdent", "transformAction", "getCompletions"];
		
		        for (var i = 0; i < delegations.length; i++) {
		            (function(scope) {
		              var functionName = delegations[i];
		              var defaultHandler = scope[functionName];
		              scope[delegations[i]] = function() {
		                  return this.$delegator(functionName, arguments, defaultHandler);
		              };
		            }(this));
		        }
		    };
		
		    this.$delegator = function(method, args, defaultHandler) {
		        var state = args[0];
		        if (typeof state != "string")
		            state = state[0];
		        for (var i = 0; i < this.$embeds.length; i++) {
		            if (!this.$modes[this.$embeds[i]]) continue;
		
		            var split = state.split(this.$embeds[i]);
		            if (!split[0] && split[1]) {
		                args[0] = split[1];
		                var mode = this.$modes[this.$embeds[i]];
		                return mode[method].apply(mode, args);
		            }
		        }
		        var ret = defaultHandler.apply(this, args);
		        return defaultHandler ? ret : undefined;
		    };
		
		    this.transformAction = function(state, action, editor, session, param) {
		        if (this.$behaviour) {
		            var behaviours = this.$behaviour.getBehaviours();
		            for (var key in behaviours) {
		                if (behaviours[key][action]) {
		                    var ret = behaviours[key][action].apply(this, arguments);
		                    if (ret) {
		                        return ret;
		                    }
		                }
		            }
		        }
		    };
		    
		    this.getKeywords = function(append) {
		        // this is for autocompletion to pick up regexp'ed keywords
		        if (!this.completionKeywords) {
		            var rules = this.$tokenizer.rules;
		            var completionKeywords = [];
		            for (var rule in rules) {
		                var ruleItr = rules[rule];
		                for (var r = 0, l = ruleItr.length; r < l; r++) {
		                    if (typeof ruleItr[r].token === "string") {
		                        if (/keyword|support|storage/.test(ruleItr[r].token))
		                            completionKeywords.push(ruleItr[r].regex);
		                    }
		                    else if (typeof ruleItr[r].token === "object") {
		                        for (var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++) {    
		                            if (/keyword|support|storage/.test(ruleItr[r].token[a])) {
		                                // drop surrounding parens
		                                var rule = ruleItr[r].regex.match(/\(.+?\)/g)[a];
		                                completionKeywords.push(rule.substr(1, rule.length - 2));
		                            }
		                        }
		                    }
		                }
		            }
		            this.completionKeywords = completionKeywords;
		        }
		        // this is for highlighting embed rules, like HAML/Ruby or Obj-C/C
		        if (!append)
		            return this.$keywordList;
		        return completionKeywords.concat(this.$keywordList || []);
		    };
		    
		    this.$createKeywordList = function() {
		        if (!this.$highlightRules)
		            this.getTokenizer();
		        return this.$keywordList = this.$highlightRules.$keywordList || [];
		    };
		
		    this.getCompletions = function(state, session, pos, prefix) {
		        var keywords = this.$keywordList || this.$createKeywordList();
		        return keywords.map(function(word) {
		            return {
		                name: word,
		                value: word,
		                score: 0,
		                meta: "keyword"
		            };
		        });
		    };
		
		    this.$id = "ace/mode/text";
		}).call(Mode.prototype);
		
		exports.Mode = Mode;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/mode/text/text_highlight_rules.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var lang = require("../../lib/lang");
		
		var TextHighlightRules = function() {
		
		    // regexp must not have capturing parentheses
		    // regexps are ordered -> the first match is used
		
		    this.$rules = {
		        "start" : [{
		            token : "empty_line",
		            regex : '^$'
		        }, {
		            defaultToken : "text"
		        }]
		    };
		};
		
		(function() {
		
		    this.addRules = function(rules, prefix) {
		        if (!prefix) {
		            for (var key in rules)
		                this.$rules[key] = rules[key];
		            return;
		        }
		        for (var key in rules) {
		            var state = rules[key];
		            for (var i = 0; i < state.length; i++) {
		                var rule = state[i];
		                if (rule.next || rule.onMatch) {
		                    if (typeof rule.next == "string") {
		                        if (rule.next.indexOf(prefix) !== 0)
		                            rule.next = prefix + rule.next;
		                    }
		                    if (rule.nextState && rule.nextState.indexOf(prefix) !== 0)
		                        rule.nextState = prefix + rule.nextState;
		                }
		            }
		            this.$rules[prefix + key] = state;
		        }
		    };
		
		    this.getRules = function() {
		        return this.$rules;
		    };
		
		    this.embedRules = function (HighlightRules, prefix, escapeRules, states, append) {
		        var embedRules = typeof HighlightRules == "function"
		            ? new HighlightRules().getRules()
		            : HighlightRules;
		        if (states) {
		            for (var i = 0; i < states.length; i++)
		                states[i] = prefix + states[i];
		        } else {
		            states = [];
		            for (var key in embedRules)
		                states.push(prefix + key);
		        }
		
		        this.addRules(embedRules, prefix);
		
		        if (escapeRules) {
		            var addRules = Array.prototype[append ? "push" : "unshift"];
		            for (var i = 0; i < states.length; i++)
		                addRules.apply(this.$rules[states[i]], lang.deepCopy(escapeRules));
		        }
		
		        if (!this.$embeds)
		            this.$embeds = [];
		        this.$embeds.push(prefix);
		    };
		
		    this.getEmbeds = function() {
		        return this.$embeds;
		    };
		
		    var pushState = function(currentState, stack) {
		        if (currentState != "start" || stack.length)
		            stack.unshift(this.nextState, currentState);
		        return this.nextState;
		    };
		    var popState = function(currentState, stack) {
		        // if (stack[0] === currentState)
		        stack.shift();
		        return stack.shift() || "start";
		    };
		
		    this.normalizeRules = function() {
		        var id = 0;
		        var rules = this.$rules;
		        function processState(key) {
		            var state = rules[key];
		            state.processed = true;
		            for (var i = 0; i < state.length; i++) {
		                var rule = state[i];
		                var toInsert = null;
		                if (Array.isArray(rule)) {
		                    toInsert = rule;
		                    rule = {};
		                }
		                if (!rule.regex && rule.start) {
		                    rule.regex = rule.start;
		                    if (!rule.next)
		                        rule.next = [];
		                    rule.next.push({
		                        defaultToken: rule.token
		                    }, {
		                        token: rule.token + ".end",
		                        regex: rule.end || rule.start,
		                        next: "pop"
		                    });
		                    rule.token = rule.token + ".start";
		                    rule.push = true;
		                }
		                var next = rule.next || rule.push;
		                if (next && Array.isArray(next)) {
		                    var stateName = rule.stateName;
		                    if (!stateName)  {
		                        stateName = rule.token;
		                        if (typeof stateName != "string")
		                            stateName = stateName[0] || "";
		                        if (rules[stateName])
		                            stateName += id++;
		                    }
		                    rules[stateName] = next;
		                    rule.next = stateName;
		                    processState(stateName);
		                } else if (next == "pop") {
		                    rule.next = popState;
		                }
		
		                if (rule.push) {
		                    rule.nextState = rule.next || rule.push;
		                    rule.next = pushState;
		                    delete rule.push;
		                }
		
		                if (rule.rules) {
		                    for (var r in rule.rules) {
		                        if (rules[r]) {
		                            if (rules[r].push)
		                                rules[r].push.apply(rules[r], rule.rules[r]);
		                        } else {
		                            rules[r] = rule.rules[r];
		                        }
		                    }
		                }
		                var includeName = typeof rule == "string"
		                    ? rule
		                    : typeof rule.include == "string"
		                    ? rule.include
		                    : "";
		                if (includeName) {
		                    toInsert = rules[includeName];
		                }
		
		                if (toInsert) {
		                    var args = [i, 1].concat(toInsert);
		                    if (rule.noEscape)
		                        args = args.filter(function(x) {return !x.next;});
		                    state.splice.apply(state, args);
		                    // skip included rules since they are already processed
		                    //i += args.length - 3;
		                    i--;
		                }
		                
		                if (rule.keywordMap) {
		                    rule.token = this.createKeywordMapper(
		                        rule.keywordMap, rule.defaultToken || "text", rule.caseInsensitive
		                    );
		                    delete rule.defaultToken;
		                }
		            }
		        }
		        Object.keys(rules).forEach(processState, this);
		    };
		
		    this.createKeywordMapper = function(map, defaultToken, ignoreCase, splitChar) {
		        var keywords = Object.create(null);
		        Object.keys(map).forEach(function(className) {
		            var a = map[className];
		            if (ignoreCase)
		                a = a.toLowerCase();
		            var list = a.split(splitChar || "|");
		            for (var i = list.length; i--; )
		                keywords[list[i]] = className;
		        });
		        // in old versions of opera keywords["__proto__"] sets prototype
		        // even on objects with __proto__=null
		        if (Object.getPrototypeOf(keywords)) {
		            keywords.__proto__ = null;
		        }
		        this.$keywordList = Object.keys(keywords);
		        map = null;
		        return ignoreCase
		            ? function(value) {return keywords[value.toLowerCase()] || defaultToken }
		            : function(value) {return keywords[value] || defaultToken };
		    };
		
		    this.getKeywords = function() {
		        return this.$keywords;
		    };
		
		}).call(TextHighlightRules.prototype);
		
		exports.TextHighlightRules = TextHighlightRules;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/mouse/default_gutter_handler.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var dom = require("../lib/dom");
		var oop = require("../lib/oop");
		var event = require("../lib/event");
		var Tooltip = require("../tooltip").Tooltip;
		
		function GutterHandler(mouseHandler) {
		    var editor = mouseHandler.editor;
		    var gutter = editor.renderer.$gutterLayer;
		    var tooltip = new GutterTooltip(editor.container);
		
		    mouseHandler.editor.setDefaultHandler("guttermousedown", function(e) {
		        if (!editor.isFocused() || e.getButton() != 0)
		            return;
		        var gutterRegion = gutter.getRegion(e);
		
		        if (gutterRegion == "foldWidgets")
		            return;
		
		        var row = e.getDocumentPosition().row;
		        var selection = editor.session.selection;
		
		        if (e.getShiftKey())
		            selection.selectTo(row, 0);
		        else {
		            if (e.domEvent.detail == 2) {
		                editor.selectAll();
		                return e.preventDefault();
		            }
		            mouseHandler.$clickSelection = editor.selection.getLineRange(row);
		        }
		        mouseHandler.setState("selectByLines");
		        mouseHandler.captureMouse(e);
		        return e.preventDefault();
		    });
		
		
		    var tooltipTimeout, mouseEvent, tooltipAnnotation;
		
		    function showTooltip() {
		        var row = mouseEvent.getDocumentPosition().row;
		        var annotation = gutter.$annotations[row];
		        if (!annotation)
		            return hideTooltip();
		
		        var maxRow = editor.session.getLength();
		        if (row == maxRow) {
		            var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;
		            var pos = mouseEvent.$pos;
		            if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column))
		                return hideTooltip();
		        }
		
		        if (tooltipAnnotation == annotation)
		            return;
		        tooltipAnnotation = annotation.text.join("<br/>");
		
		        tooltip.setHtml(tooltipAnnotation);
		        tooltip.show();
		        editor.on("mousewheel", hideTooltip);
		
		        if (mouseHandler.$tooltipFollowsMouse) {
		            moveTooltip(mouseEvent);
		        } else {
		            var gutterElement = mouseEvent.domEvent.target;
		            var rect = gutterElement.getBoundingClientRect();
		            var style = tooltip.getElement().style;
		            style.left = rect.right + "px";
		            style.top = rect.bottom + "px";
		        }
		    }
		
		    function hideTooltip() {
		        if (tooltipTimeout)
		            tooltipTimeout = clearTimeout(tooltipTimeout);
		        if (tooltipAnnotation) {
		            tooltip.hide();
		            tooltipAnnotation = null;
		            editor.removeEventListener("mousewheel", hideTooltip);
		        }
		    }
		
		    function moveTooltip(e) {
		        tooltip.setPosition(e.x, e.y);
		    }
		
		    mouseHandler.editor.setDefaultHandler("guttermousemove", function(e) {
		        var target = e.domEvent.target || e.domEvent.srcElement;
		        if (dom.hasCssClass(target, "ace_fold-widget"))
		            return hideTooltip();
		
		        if (tooltipAnnotation && mouseHandler.$tooltipFollowsMouse)
		            moveTooltip(e);
		
		        mouseEvent = e;
		        if (tooltipTimeout)
		            return;
		        tooltipTimeout = setTimeout(function() {
		            tooltipTimeout = null;
		            if (mouseEvent && !mouseHandler.isMousePressed)
		                showTooltip();
		            else
		                hideTooltip();
		        }, 50);
		    });
		
		    event.addListener(editor.renderer.$gutter, "mouseout", function(e) {
		        mouseEvent = null;
		        if (!tooltipAnnotation || tooltipTimeout)
		            return;
		
		        tooltipTimeout = setTimeout(function() {
		            tooltipTimeout = null;
		            hideTooltip();
		        }, 50);
		    });
		    
		    editor.on("changeSession", hideTooltip);
		}
		
		function GutterTooltip(parentNode) {
		    Tooltip.call(this, parentNode);
		}
		
		oop.inherits(GutterTooltip, Tooltip);
		
		(function(){
		    this.setPosition = function(x, y) {
		        var windowWidth = window.innerWidth || document.documentElement.clientWidth;
		        var windowHeight = window.innerHeight || document.documentElement.clientHeight;
		        var width = this.getWidth();
		        var height = this.getHeight();
		        x += 15;
		        y += 15;
		        if (x + width > windowWidth) {
		            x -= (x + width) - windowWidth;
		        }
		        if (y + height > windowHeight) {
		            y -= 20 + height;
		        }
		        Tooltip.prototype.setPosition.call(this, x, y);
		    };
		
		}).call(GutterTooltip.prototype);
		
		
		
		exports.GutterHandler = GutterHandler;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/mouse/default_handlers.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var dom = require("../lib/dom");
		var event = require("../lib/event");
		var useragent = require("../lib/useragent");
		
		var DRAG_OFFSET = 0; // pixels
		
		function DefaultHandlers(mouseHandler) {
		    mouseHandler.$clickSelection = null;
		
		    var editor = mouseHandler.editor;
		    editor.setDefaultHandler("mousedown", this.onMouseDown.bind(mouseHandler));
		    editor.setDefaultHandler("dblclick", this.onDoubleClick.bind(mouseHandler));
		    editor.setDefaultHandler("tripleclick", this.onTripleClick.bind(mouseHandler));
		    editor.setDefaultHandler("quadclick", this.onQuadClick.bind(mouseHandler));
		    editor.setDefaultHandler("mousewheel", this.onMouseWheel.bind(mouseHandler));
		    editor.setDefaultHandler("touchmove", this.onTouchMove.bind(mouseHandler));
		
		    var exports = ["select", "startSelect", "selectEnd", "selectAllEnd", "selectByWordsEnd",
		        "selectByLinesEnd", "dragWait", "dragWaitEnd", "focusWait"];
		
		    exports.forEach(function(x) {
		        mouseHandler[x] = this[x];
		    }, this);
		
		    mouseHandler.selectByLines = this.extendSelectionBy.bind(mouseHandler, "getLineRange");
		    mouseHandler.selectByWords = this.extendSelectionBy.bind(mouseHandler, "getWordRange");
		}
		
		(function() {
		
		    this.onMouseDown = function(ev) {
		        var inSelection = ev.inSelection();
		        var pos = ev.getDocumentPosition();
		        this.mousedownEvent = ev;
		        var editor = this.editor;
		
		        var button = ev.getButton();
		        if (button !== 0) {
		            var selectionRange = editor.getSelectionRange();
		            var selectionEmpty = selectionRange.isEmpty();
		            editor.$blockScrolling++;
		            if (selectionEmpty || button == 1)
		                editor.selection.moveToPosition(pos);
		            editor.$blockScrolling--;
		            // 2: contextmenu, 1: linux paste
		            if (button == 2)
		                editor.textInput.onContextMenu(ev.domEvent);
		            return; // stopping event here breaks contextmenu on ff mac
		        }
		
		        this.mousedownEvent.time = Date.now();
		        // if this click caused the editor to be focused should not clear the
		        // selection
		        if (inSelection && !editor.isFocused()) {
		            editor.focus();
		            if (this.$focusTimout && !this.$clickSelection && !editor.inMultiSelectMode) {
		                this.setState("focusWait");
		                this.captureMouse(ev);
		                return;
		            }
		        }
		
		        this.captureMouse(ev);
		        this.startSelect(pos, ev.domEvent._clicks > 1);
		        return ev.preventDefault();
		    };
		
		    this.startSelect = function(pos, waitForClickSelection) {
		        pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
		        var editor = this.editor;
		        // allow double/triple click handlers to change selection
		        editor.$blockScrolling++;
		        if (this.mousedownEvent.getShiftKey())
		            editor.selection.selectToPosition(pos);
		        else if (!waitForClickSelection)
		            editor.selection.moveToPosition(pos);
		        if (!waitForClickSelection)
		            this.select();
		        if (editor.renderer.scroller.setCapture) {
		            editor.renderer.scroller.setCapture();
		        }
		        editor.setStyle("ace_selecting");
		        this.setState("select");
		        editor.$blockScrolling--;
		    };
		
		    this.select = function() {
		        var anchor, editor = this.editor;
		        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
		        editor.$blockScrolling++;
		        if (this.$clickSelection) {
		            var cmp = this.$clickSelection.comparePoint(cursor);
		
		            if (cmp == -1) {
		                anchor = this.$clickSelection.end;
		            } else if (cmp == 1) {
		                anchor = this.$clickSelection.start;
		            } else {
		                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
		                cursor = orientedRange.cursor;
		                anchor = orientedRange.anchor;
		            }
		            editor.selection.setSelectionAnchor(anchor.row, anchor.column);
		        }
		        editor.selection.selectToPosition(cursor);
		        editor.$blockScrolling--;
		        editor.renderer.scrollCursorIntoView();
		    };
		
		    this.extendSelectionBy = function(unitName) {
		        var anchor, editor = this.editor;
		        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
		        var range = editor.selection[unitName](cursor.row, cursor.column);
		        editor.$blockScrolling++;
		        if (this.$clickSelection) {
		            var cmpStart = this.$clickSelection.comparePoint(range.start);
		            var cmpEnd = this.$clickSelection.comparePoint(range.end);
		
		            if (cmpStart == -1 && cmpEnd <= 0) {
		                anchor = this.$clickSelection.end;
		                if (range.end.row != cursor.row || range.end.column != cursor.column)
		                    cursor = range.start;
		            } else if (cmpEnd == 1 && cmpStart >= 0) {
		                anchor = this.$clickSelection.start;
		                if (range.start.row != cursor.row || range.start.column != cursor.column)
		                    cursor = range.end;
		            } else if (cmpStart == -1 && cmpEnd == 1) {
		                cursor = range.end;
		                anchor = range.start;
		            } else {
		                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
		                cursor = orientedRange.cursor;
		                anchor = orientedRange.anchor;
		            }
		            editor.selection.setSelectionAnchor(anchor.row, anchor.column);
		        }
		        editor.selection.selectToPosition(cursor);
		        editor.$blockScrolling--;
		        editor.renderer.scrollCursorIntoView();
		    };
		
		    this.selectEnd =
		    this.selectAllEnd =
		    this.selectByWordsEnd =
		    this.selectByLinesEnd = function() {
		        this.$clickSelection = null;
		        this.editor.unsetStyle("ace_selecting");
		        if (this.editor.renderer.scroller.releaseCapture) {
		            this.editor.renderer.scroller.releaseCapture();
		        }
		    };
		
		    this.focusWait = function() {
		        var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
		        var time = Date.now();
		
		        if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimout)
		            this.startSelect(this.mousedownEvent.getDocumentPosition());
		    };
		
		    this.onDoubleClick = function(ev) {
		        var pos = ev.getDocumentPosition();
		        var editor = this.editor;
		        var session = editor.session;
		
		        var range = session.getBracketRange(pos);
		        if (range) {
		            if (range.isEmpty()) {
		                range.start.column--;
		                range.end.column++;
		            }
		            this.setState("select");
		        } else {
		            range = editor.selection.getWordRange(pos.row, pos.column);
		            this.setState("selectByWords");
		        }
		        this.$clickSelection = range;
		        this.select();
		    };
		
		    this.onTripleClick = function(ev) {
		        var pos = ev.getDocumentPosition();
		        var editor = this.editor;
		
		        this.setState("selectByLines");
		        var range = editor.getSelectionRange();
		        if (range.isMultiLine() && range.contains(pos.row, pos.column)) {
		            this.$clickSelection = editor.selection.getLineRange(range.start.row);
		            this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;
		        } else {
		            this.$clickSelection = editor.selection.getLineRange(pos.row);
		        }
		        this.select();
		    };
		
		    this.onQuadClick = function(ev) {
		        var editor = this.editor;
		
		        editor.selectAll();
		        this.$clickSelection = editor.getSelectionRange();
		        this.setState("selectAll");
		    };
		
		    this.onMouseWheel = function(ev) {
		        if (ev.getAccelKey())
		            return;
		
		        //shift wheel to horiz scroll
		        if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {
		            ev.wheelX = ev.wheelY;
		            ev.wheelY = 0;
		        }
		
		        var t = ev.domEvent.timeStamp;
		        var dt = t - (this.$lastScrollTime||0);
		        
		        var editor = this.editor;
		        var isScrolable = editor.renderer.isScrollableBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
		        if (isScrolable || dt < 200) {
		            this.$lastScrollTime = t;
		            editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
		            return ev.stop();
		        }
		    };
		    
		    this.onTouchMove = function (ev) {
		        var t = ev.domEvent.timeStamp;
		        var dt = t - (this.$lastScrollTime || 0);
		
		        var editor = this.editor;
		        var isScrolable = editor.renderer.isScrollableBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
		        if (isScrolable || dt < 200) {
		            this.$lastScrollTime = t;
		            editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
		            return ev.stop();
		        }
		    };
		
		}).call(DefaultHandlers.prototype);
		
		exports.DefaultHandlers = DefaultHandlers;
		
		function calcDistance(ax, ay, bx, by) {
		    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
		}
		
		function calcRangeOrientation(range, cursor) {
		    if (range.start.row == range.end.row)
		        var cmp = 2 * cursor.column - range.start.column - range.end.column;
		    else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column)
		        var cmp = cursor.column - 4;
		    else
		        var cmp = 2 * cursor.row - range.start.row - range.end.row;
		
		    if (cmp < 0)
		        return {cursor: range.start, anchor: range.end};
		    else
		        return {cursor: range.end, anchor: range.start};
		}
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/mouse/dragdrop_handler.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var dom = require("../lib/dom");
		var event = require("../lib/event");
		var useragent = require("../lib/useragent");
		
		var AUTOSCROLL_DELAY = 200;
		var SCROLL_CURSOR_DELAY = 200;
		var SCROLL_CURSOR_HYSTERESIS = 5;
		
		function DragdropHandler(mouseHandler) {
		
		    var editor = mouseHandler.editor;
		
		    var blankImage = dom.createElement("img");
		    // Safari crashes without image data
		    blankImage.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
		    if (useragent.isOpera)
		        blankImage.style.cssText = "width:1px;height:1px;position:fixed;top:0;left:0;z-index:2147483647;opacity:0;";
		
		    var exports = ["dragWait", "dragWaitEnd", "startDrag", "dragReadyEnd", "onMouseDrag"];
		
		     exports.forEach(function(x) {
		         mouseHandler[x] = this[x];
		    }, this);
		    editor.addEventListener("mousedown", this.onMouseDown.bind(mouseHandler));
		
		
		    var mouseTarget = editor.container;
		    var dragSelectionMarker, x, y;
		    var timerId, range;
		    var dragCursor, counter = 0;
		    var dragOperation;
		    var isInternal;
		    var autoScrollStartTime;
		    var cursorMovedTime;
		    var cursorPointOnCaretMoved;
		
		    this.onDragStart = function(e) {
		        // webkit workaround, see this.onMouseDown
		        if (this.cancelDrag || !mouseTarget.draggable) {
		            var self = this;
		            setTimeout(function(){
		                self.startSelect();
		                self.captureMouse(e);
		            }, 0);
		            return e.preventDefault();
		        }
		        range = editor.getSelectionRange();
		
		        var dataTransfer = e.dataTransfer;
		        dataTransfer.effectAllowed = editor.getReadOnly() ? "copy" : "copyMove";
		        if (useragent.isOpera) {
		            editor.container.appendChild(blankImage);
		            // force layout
		            blankImage.scrollTop = 0;
		        }
		        dataTransfer.setDragImage && dataTransfer.setDragImage(blankImage, 0, 0);
		        if (useragent.isOpera) {
		            editor.container.removeChild(blankImage);
		        }
		        // clear Opera garbage
		        dataTransfer.clearData();
		        dataTransfer.setData("Text", editor.session.getTextRange());
		
		        isInternal = true;
		        this.setState("drag");
		    };
		
		    this.onDragEnd = function(e) {
		        mouseTarget.draggable = false;
		        isInternal = false;
		        this.setState(null);
		        if (!editor.getReadOnly()) {
		            var dropEffect = e.dataTransfer.dropEffect;
		            if (!dragOperation && dropEffect == "move")
		                // text was dragged outside the editor
		                editor.session.remove(editor.getSelectionRange());
		            editor.renderer.$cursorLayer.setBlinking(true);
		        }
		        this.editor.unsetStyle("ace_dragging");
		        this.editor.renderer.setCursorStyle("");
		    };
		
		    this.onDragEnter = function(e) {
		        if (editor.getReadOnly() || !canAccept(e.dataTransfer))
		            return;
		        x = e.clientX;
		        y = e.clientY;
		        if (!dragSelectionMarker)
		            addDragMarker();
		        counter++;
		        // dataTransfer object does not save dropEffect across events on IE, so we store it in dragOperation
		        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
		        return event.preventDefault(e);
		    };
		
		    this.onDragOver = function(e) {
		        if (editor.getReadOnly() || !canAccept(e.dataTransfer))
		            return;
		        x = e.clientX;
		        y = e.clientY;
		        // Opera doesn't trigger dragenter event on drag start
		        if (!dragSelectionMarker) {
		            addDragMarker();
		            counter++;
		        }
		        if (onMouseMoveTimer !== null)
		            onMouseMoveTimer = null;
		
		        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
		        return event.preventDefault(e);
		    };
		
		    this.onDragLeave = function(e) {
		        counter--;
		        if (counter <= 0 && dragSelectionMarker) {
		            clearDragMarker();
		            dragOperation = null;
		            return event.preventDefault(e);
		        }
		    };
		
		    this.onDrop = function(e) {
		        if (!dragCursor)
		            return;
		        var dataTransfer = e.dataTransfer;
		        if (isInternal) {
		            switch (dragOperation) {
		                case "move":
		                    if (range.contains(dragCursor.row, dragCursor.column)) {
		                        // clear selection
		                        range = {
		                            start: dragCursor,
		                            end: dragCursor
		                        };
		                    } else {
		                        // move text
		                        range = editor.moveText(range, dragCursor);
		                    }
		                    break;
		                case "copy":
		                    // copy text
		                    range = editor.moveText(range, dragCursor, true);
		                    break;
		            }
		        } else {
		            var dropData = dataTransfer.getData('Text');
		            range = {
		                start: dragCursor,
		                end: editor.session.insert(dragCursor, dropData)
		            };
		            editor.focus();
		            dragOperation = null;
		        }
		        clearDragMarker();
		        return event.preventDefault(e);
		    };
		
		    event.addListener(mouseTarget, "dragstart", this.onDragStart.bind(mouseHandler));
		    event.addListener(mouseTarget, "dragend", this.onDragEnd.bind(mouseHandler));
		    event.addListener(mouseTarget, "dragenter", this.onDragEnter.bind(mouseHandler));
		    event.addListener(mouseTarget, "dragover", this.onDragOver.bind(mouseHandler));
		    event.addListener(mouseTarget, "dragleave", this.onDragLeave.bind(mouseHandler));
		    event.addListener(mouseTarget, "drop", this.onDrop.bind(mouseHandler));
		
		    function scrollCursorIntoView(cursor, prevCursor) {
		        var now = Date.now();
		        var vMovement = !prevCursor || cursor.row != prevCursor.row;
		        var hMovement = !prevCursor || cursor.column != prevCursor.column;
		        if (!cursorMovedTime || vMovement || hMovement) {
		            editor.$blockScrolling += 1;
		            editor.moveCursorToPosition(cursor);
		            editor.$blockScrolling -= 1;
		            cursorMovedTime = now;
		            cursorPointOnCaretMoved = {x: x, y: y};
		        } else {
		            var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);
		            if (distance > SCROLL_CURSOR_HYSTERESIS) {
		                cursorMovedTime = null;
		            } else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {
		                editor.renderer.scrollCursorIntoView();
		                cursorMovedTime = null;
		            }
		        }
		    }
		
		    function autoScroll(cursor, prevCursor) {
		        var now = Date.now();
		        var lineHeight = editor.renderer.layerConfig.lineHeight;
		        var characterWidth = editor.renderer.layerConfig.characterWidth;
		        var editorRect = editor.renderer.scroller.getBoundingClientRect();
		        var offsets = {
		           x: {
		               left: x - editorRect.left,
		               right: editorRect.right - x
		           },
		           y: {
		               top: y - editorRect.top,
		               bottom: editorRect.bottom - y
		           }
		        };
		        var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);
		        var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);
		        var scrollCursor = {row: cursor.row, column: cursor.column};
		        if (nearestXOffset / characterWidth <= 2) {
		            scrollCursor.column += (offsets.x.left < offsets.x.right ? -3 : +2);
		        }
		        if (nearestYOffset / lineHeight <= 1) {
		            scrollCursor.row += (offsets.y.top < offsets.y.bottom ? -1 : +1);
		        }
		        var vScroll = cursor.row != scrollCursor.row;
		        var hScroll = cursor.column != scrollCursor.column;
		        var vMovement = !prevCursor || cursor.row != prevCursor.row;
		        if (vScroll || (hScroll && !vMovement)) {
		            if (!autoScrollStartTime)
		                autoScrollStartTime = now;
		            else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY)
		                editor.renderer.scrollCursorIntoView(scrollCursor);
		        } else {
		            autoScrollStartTime = null;
		        }
		    }
		
		    function onDragInterval() {
		        var prevCursor = dragCursor;
		        dragCursor = editor.renderer.screenToTextCoordinates(x, y);
		        scrollCursorIntoView(dragCursor, prevCursor);
		        autoScroll(dragCursor, prevCursor);
		    }
		
		    function addDragMarker() {
		        range = editor.selection.toOrientedRange();
		        dragSelectionMarker = editor.session.addMarker(range, "ace_selection", editor.getSelectionStyle());
		        editor.clearSelection();
		        if (editor.isFocused())
		            editor.renderer.$cursorLayer.setBlinking(false);
		        clearInterval(timerId);
		        onDragInterval();
		        timerId = setInterval(onDragInterval, 20);
		        counter = 0;
		        event.addListener(document, "mousemove", onMouseMove);
		    }
		
		    function clearDragMarker() {
		        clearInterval(timerId);
		        editor.session.removeMarker(dragSelectionMarker);
		        dragSelectionMarker = null;
		        editor.$blockScrolling += 1;
		        editor.selection.fromOrientedRange(range);
		        editor.$blockScrolling -= 1;
		        if (editor.isFocused() && !isInternal)
		            editor.renderer.$cursorLayer.setBlinking(!editor.getReadOnly());
		        range = null;
		        dragCursor = null;
		        counter = 0;
		        autoScrollStartTime = null;
		        cursorMovedTime = null;
		        event.removeListener(document, "mousemove", onMouseMove);
		    }
		
		    // sometimes other code on the page can stop dragleave event leaving editor stuck in the drag state
		    var onMouseMoveTimer = null;
		    function onMouseMove() {
		        if (onMouseMoveTimer == null) {
		            onMouseMoveTimer = setTimeout(function() {
		                if (onMouseMoveTimer != null && dragSelectionMarker)
		                    clearDragMarker();
		            }, 20);
		        }
		    }
		
		    function canAccept(dataTransfer) {
		        var types = dataTransfer.types;
		        return !types || Array.prototype.some.call(types, function(type) {
		            return type == 'text/plain' || type == 'Text';
		        });
		    }
		
		    function getDropEffect(e) {
		        var copyAllowed = ['copy', 'copymove', 'all', 'uninitialized'];
		        var moveAllowed = ['move', 'copymove', 'linkmove', 'all', 'uninitialized'];
		
		        var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;
		
		        // IE throws error while dragging from another app
		        var effectAllowed = "uninitialized";
		        try {
		            effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();
		        } catch (e) {}
		        var dropEffect = "none";
		
		        if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0)
		            dropEffect = "copy";
		        else if (moveAllowed.indexOf(effectAllowed) >= 0)
		            dropEffect = "move";
		        else if (copyAllowed.indexOf(effectAllowed) >= 0)
		            dropEffect = "copy";
		
		        return dropEffect;
		    }
		}
		
		(function() {
		
		    this.dragWait = function() {
		        var interval = Date.now() - this.mousedownEvent.time;
		        if (interval > this.editor.getDragDelay())
		            this.startDrag();
		    };
		
		    this.dragWaitEnd = function() {
		        var target = this.editor.container;
		        target.draggable = false;
		        this.startSelect(this.mousedownEvent.getDocumentPosition());
		        this.selectEnd();
		    };
		
		    this.dragReadyEnd = function(e) {
		        this.editor.renderer.$cursorLayer.setBlinking(!this.editor.getReadOnly());
		        this.editor.unsetStyle("ace_dragging");
		        this.editor.renderer.setCursorStyle("");
		        this.dragWaitEnd();
		    };
		
		    this.startDrag = function(){
		        this.cancelDrag = false;
		        var editor = this.editor;
		        var target = editor.container;
		        target.draggable = true;
		        editor.renderer.$cursorLayer.setBlinking(false);
		        editor.setStyle("ace_dragging");
		        var cursorStyle = useragent.isWin ? "default" : "move";
		        editor.renderer.setCursorStyle(cursorStyle);
		        this.setState("dragReady");
		    };
		
		    this.onMouseDrag = function(e) {
		        var target = this.editor.container;
		        if (useragent.isIE && this.state == "dragReady") {
		            // IE does not handle [draggable] attribute set after mousedown
		            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
		            if (distance > 3)
		                target.dragDrop();
		        }
		        if (this.state === "dragWait") {
		            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
		            if (distance > 0) {
		                target.draggable = false;
		                this.startSelect(this.mousedownEvent.getDocumentPosition());
		            }
		        }
		    };
		
		    this.onMouseDown = function(e) {
		        if (!this.$dragEnabled)
		            return;
		        this.mousedownEvent = e;
		        var editor = this.editor;
		
		        var inSelection = e.inSelection();
		        var button = e.getButton();
		        var clickCount = e.domEvent.detail || 1;
		        if (clickCount === 1 && button === 0 && inSelection) {
		            if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey()))
		                return;
		            this.mousedownEvent.time = Date.now();
		            var eventTarget = e.domEvent.target || e.domEvent.srcElement;
		            if ("unselectable" in eventTarget)
		                eventTarget.unselectable = "on";
		            if (editor.getDragDelay()) {
		                // https://code.google.com/p/chromium/issues/detail?id=286700
		                if (useragent.isWebKit) {
		                    this.cancelDrag = true;
		                    var mouseTarget = editor.container;
		                    mouseTarget.draggable = true;
		                }
		                this.setState("dragWait");
		            } else {
		                this.startDrag();
		            }
		            this.captureMouse(e, this.onMouseDrag.bind(this));
		            // TODO: a better way to prevent default handler without preventing browser default action
		            e.defaultPrevented = true;
		        }
		    };
		
		}).call(DragdropHandler.prototype);
		
		
		function calcDistance(ax, ay, bx, by) {
		    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
		}
		
		exports.DragdropHandler = DragdropHandler;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/mouse/fold_handler.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		function FoldHandler(editor) {
		
		    editor.on("click", function(e) {
		        var position = e.getDocumentPosition();
		        var session = editor.session;
		
		        // If the user clicked on a fold, then expand it.
		        var fold = session.getFoldAt(position.row, position.column, 1);
		        if (fold) {
		            if (e.getAccelKey())
		                session.removeFold(fold);
		            else
		                session.expandFold(fold);
		
		            e.stop();
		        }
		    });
		
		    editor.on("gutterclick", function(e) {
		        var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);
		
		        if (gutterRegion == "foldWidgets") {
		            var row = e.getDocumentPosition().row;
		            var session = editor.session;
		            if (session.foldWidgets && session.foldWidgets[row])
		                editor.session.onFoldWidgetClick(row, e);
		            if (!editor.isFocused())
		                editor.focus();
		            e.stop();
		        }
		    });
		
		    editor.on("gutterdblclick", function(e) {
		        var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);
		
		        if (gutterRegion == "foldWidgets") {
		            var row = e.getDocumentPosition().row;
		            var session = editor.session;
		            var data = session.getParentFoldRangeData(row, true);
		            var range = data.range || data.firstRange;
		
		            if (range) {
		                row = range.start.row;
		                var fold = session.getFoldAt(row, session.getLine(row).length, 1);
		
		                if (fold) {
		                    session.removeFold(fold);
		                } else {
		                    session.addFold("...", range);
		                    editor.renderer.scrollCursorIntoView({row: range.start.row, column: 0});
		                }
		            }
		            e.stop();
		        }
		    });
		}
		
		exports.FoldHandler = FoldHandler;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/mouse/mouse_event.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var event = require("../lib/event");
		var useragent = require("../lib/useragent");
		
		/*
		 * Custom Ace mouse event
		 */
		var MouseEvent = exports.MouseEvent = function(domEvent, editor) {
		    this.domEvent = domEvent;
		    this.editor = editor;
		    
		    this.x = this.clientX = domEvent.clientX;
		    this.y = this.clientY = domEvent.clientY;
		
		    this.$pos = null;
		    this.$inSelection = null;
		    
		    this.propagationStopped = false;
		    this.defaultPrevented = false;
		};
		
		(function() {  
		    
		    this.stopPropagation = function() {
		        event.stopPropagation(this.domEvent);
		        this.propagationStopped = true;
		    };
		    
		    this.preventDefault = function() {
		        event.preventDefault(this.domEvent);
		        this.defaultPrevented = true;
		    };
		    
		    this.stop = function() {
		        this.stopPropagation();
		        this.preventDefault();
		    };
		
		    /*
		     * Get the document position below the mouse cursor
		     * 
		     * @return {Object} 'row' and 'column' of the document position
		     */
		    this.getDocumentPosition = function() {
		        if (this.$pos)
		            return this.$pos;
		        
		        this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
		        return this.$pos;
		    };
		    
		    /*
		     * Check if the mouse cursor is inside of the text selection
		     * 
		     * @return {Boolean} whether the mouse cursor is inside of the selection
		     */
		    this.inSelection = function() {
		        if (this.$inSelection !== null)
		            return this.$inSelection;
		            
		        var editor = this.editor;
		        
		
		        var selectionRange = editor.getSelectionRange();
		        if (selectionRange.isEmpty())
		            this.$inSelection = false;
		        else {
		            var pos = this.getDocumentPosition();
		            this.$inSelection = selectionRange.contains(pos.row, pos.column);
		        }
		
		        return this.$inSelection;
		    };
		    
		    /*
		     * Get the clicked mouse button
		     * 
		     * @return {Number} 0 for left button, 1 for middle button, 2 for right button
		     */
		    this.getButton = function() {
		        return event.getButton(this.domEvent);
		    };
		    
		    /*
		     * @return {Boolean} whether the shift key was pressed when the event was emitted
		     */
		    this.getShiftKey = function() {
		        return this.domEvent.shiftKey;
		    };
		    
		    this.getAccelKey = useragent.isMac
		        ? function() { return this.domEvent.metaKey; }
		        : function() { return this.domEvent.ctrlKey; };
		    
		}).call(MouseEvent.prototype);
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/mouse/mouse_handler.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var event = require("../lib/event");
		var useragent = require("../lib/useragent");
		var DefaultHandlers = require("./default_handlers").DefaultHandlers;
		var DefaultGutterHandler = require("./default_gutter_handler").GutterHandler;
		var MouseEvent = require("./mouse_event").MouseEvent;
		var DragdropHandler = require("./dragdrop_handler").DragdropHandler;
		var config = require("../config");
		
		var MouseHandler = function(editor) {
		    var _self = this;
		    this.editor = editor;
		
		    new DefaultHandlers(this);
		    new DefaultGutterHandler(this);
		    new DragdropHandler(this);
		
		    var focusEditor = function(e) {
		        // because we have to call event.preventDefault() any window on ie and iframes
		        // on other browsers do not get focus, so we have to call window.focus() here
		        var windowBlurred = !document.hasFocus || !document.hasFocus()
		            || !editor.isFocused() && document.activeElement == (editor.textInput && editor.textInput.getElement())
		        if (windowBlurred)
		            window.focus();
		        editor.focus();
		    };
		
		    var mouseTarget = editor.renderer.getMouseEventTarget();
		    event.addListener(mouseTarget, "click", this.onMouseEvent.bind(this, "click"));
		    event.addListener(mouseTarget, "mousemove", this.onMouseMove.bind(this, "mousemove"));
		    event.addMultiMouseDownListener([
		        mouseTarget,
		        editor.renderer.scrollBarV && editor.renderer.scrollBarV.inner,
		        editor.renderer.scrollBarH && editor.renderer.scrollBarH.inner,
		        editor.textInput && editor.textInput.getElement()
		    ].filter(Boolean), [400, 300, 250], this, "onMouseEvent");
		    event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, "mousewheel"));
		    event.addTouchMoveListener(editor.container, this.onTouchMove.bind(this, "touchmove"));
		
		    var gutterEl = editor.renderer.$gutter;
		    event.addListener(gutterEl, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"));
		    event.addListener(gutterEl, "click", this.onMouseEvent.bind(this, "gutterclick"));
		    event.addListener(gutterEl, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"));
		    event.addListener(gutterEl, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"));
		
		    event.addListener(mouseTarget, "mousedown", focusEditor);
		    event.addListener(gutterEl, "mousedown", focusEditor);
		    if (useragent.isIE && editor.renderer.scrollBarV) {
		        event.addListener(editor.renderer.scrollBarV.element, "mousedown", focusEditor);
		        event.addListener(editor.renderer.scrollBarH.element, "mousedown", focusEditor);
		    }
		
		    editor.on("mousemove", function(e){
		        if (_self.state || _self.$dragDelay || !_self.$dragEnabled)
		            return;
		
		        var character = editor.renderer.screenToTextCoordinates(e.x, e.y);
		        var range = editor.session.selection.getRange();
		        var renderer = editor.renderer;
		
		        if (!range.isEmpty() && range.insideStart(character.row, character.column)) {
		            renderer.setCursorStyle("default");
		        } else {
		            renderer.setCursorStyle("");
		        }
		    });
		};
		
		(function() {
		    this.onMouseEvent = function(name, e) {
		        this.editor._emit(name, new MouseEvent(e, this.editor));
		    };
		
		    this.onMouseMove = function(name, e) {
		        // optimization, because mousemove doesn't have a default handler.
		        var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
		        if (!listeners || !listeners.length)
		            return;
		
		        this.editor._emit(name, new MouseEvent(e, this.editor));
		    };
		
		    this.onMouseWheel = function(name, e) {
		        var mouseEvent = new MouseEvent(e, this.editor);
		        mouseEvent.speed = this.$scrollSpeed * 2;
		        mouseEvent.wheelX = e.wheelX;
		        mouseEvent.wheelY = e.wheelY;
		
		        this.editor._emit(name, mouseEvent);
		    };
		    
		    this.onTouchMove = function (name, e) {
		        var mouseEvent = new MouseEvent(e, this.editor);
		        mouseEvent.speed = 1;//this.$scrollSpeed * 2;
		        mouseEvent.wheelX = e.wheelX;
		        mouseEvent.wheelY = e.wheelY;
		        this.editor._emit(name, mouseEvent);
		    };
		
		    this.setState = function(state) {
		        this.state = state;
		    };
		
		    this.captureMouse = function(ev, mouseMoveHandler) {
		        this.x = ev.x;
		        this.y = ev.y;
		
		        this.isMousePressed = true;
		
		        // do not move textarea during selection
		        var renderer = this.editor.renderer;
		        if (renderer.$keepTextAreaAtCursor)
		            renderer.$keepTextAreaAtCursor = null;
		
		        var self = this;
		        var onMouseMove = function(e) {
		            if (!e) return;
		            // if editor is loaded inside iframe, and mouseup event is outside
		            // we won't recieve it, so we cancel on first mousemove without button
		            if (useragent.isWebKit && !e.which && self.releaseMouse)
		                return self.releaseMouse();
		
		            self.x = e.clientX;
		            self.y = e.clientY;
		            mouseMoveHandler && mouseMoveHandler(e);
		            self.mouseEvent = new MouseEvent(e, self.editor);
		            self.$mouseMoved = true;
		        };
		
		        var onCaptureEnd = function(e) {
		            clearInterval(timerId);
		            onCaptureInterval();
		            self[self.state + "End"] && self[self.state + "End"](e);
		            self.state = "";
		            if (renderer.$keepTextAreaAtCursor == null) {
		                renderer.$keepTextAreaAtCursor = true;
		                renderer.$moveTextAreaToCursor();
		            }
		            self.isMousePressed = false;
		            self.$onCaptureMouseMove = self.releaseMouse = null;
		            e && self.onMouseEvent("mouseup", e);
		        };
		
		        var onCaptureInterval = function() {
		            self[self.state] && self[self.state]();
		            self.$mouseMoved = false;
		        };
		
		        if (useragent.isOldIE && ev.domEvent.type == "dblclick") {
		            return setTimeout(function() {onCaptureEnd(ev);});
		        }
		
		        self.$onCaptureMouseMove = onMouseMove;
		        self.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
		        var timerId = setInterval(onCaptureInterval, 20);
		    };
		    this.releaseMouse = null;
		    this.cancelContextMenu = function() {
		        var stop = function(e) {
		            if (e && e.domEvent && e.domEvent.type != "contextmenu")
		                return;
		            this.editor.off("nativecontextmenu", stop);
		            if (e && e.domEvent)
		                event.stopEvent(e.domEvent);
		        }.bind(this);
		        setTimeout(stop, 10);
		        this.editor.on("nativecontextmenu", stop);
		    };
		}).call(MouseHandler.prototype);
		
		config.defineOptions(MouseHandler.prototype, "mouseHandler", {
		    scrollSpeed: {initialValue: 2},
		    dragDelay: {initialValue: (useragent.isMac ? 150 : 0)},
		    dragEnabled: {initialValue: true},
		    focusTimout: {initialValue: 0},
		    tooltipFollowsMouse: {initialValue: true}
		});
		
		
		exports.MouseHandler = MouseHandler;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/mouse/multi_select_handler.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var event = require("../lib/event");
		var useragent = require("../lib/useragent");
		
		// mouse
		function isSamePoint(p1, p2) {
		    return p1.row == p2.row && p1.column == p2.column;
		}
		
		function onMouseDown(e) {
		    var ev = e.domEvent;
		    var alt = ev.altKey;
		    var shift = ev.shiftKey;
		    var ctrl = ev.ctrlKey;
		    var accel = e.getAccelKey();
		    var button = e.getButton();
		    
		    if (ctrl && useragent.isMac)
		        button = ev.button;
		
		    if (e.editor.inMultiSelectMode && button == 2) {
		        e.editor.textInput.onContextMenu(e.domEvent);
		        return;
		    }
		    
		    if (!ctrl && !alt && !accel) {
		        if (button === 0 && e.editor.inMultiSelectMode)
		            e.editor.exitMultiSelectMode();
		        return;
		    }
		    
		    if (button !== 0)
		        return;
		
		    var editor = e.editor;
		    var selection = editor.selection;
		    var isMultiSelect = editor.inMultiSelectMode;
		    var pos = e.getDocumentPosition();
		    var cursor = selection.getCursor();
		    var inSelection = e.inSelection() || (selection.isEmpty() && isSamePoint(pos, cursor));
		
		    var mouseX = e.x, mouseY = e.y;
		    var onMouseSelection = function(e) {
		        mouseX = e.clientX;
		        mouseY = e.clientY;
		    };
		    
		    var session = editor.session;
		    var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
		    var screenCursor = screenAnchor;
		    
		    var selectionMode;
		    if (editor.$mouseHandler.$enableJumpToDef) {
		        if (ctrl && alt || accel && alt)
		            selectionMode = shift ? "block" : "add";
		        else if (alt && editor.$blockSelectEnabled)
		            selectionMode = "block";
		    } else {
		        if (accel && !alt) {
		            selectionMode = "add";
		            if (!isMultiSelect && shift)
		                return;
		        } else if (alt && editor.$blockSelectEnabled) {
		            selectionMode = "block";
		        }
		    }
		    
		    if (selectionMode && useragent.isMac && ev.ctrlKey) {
		        editor.$mouseHandler.cancelContextMenu();
		    }
		
		    if (selectionMode == "add") {
		        if (!isMultiSelect && inSelection)
		            return; // dragging
		
		        if (!isMultiSelect) {
		            var range = selection.toOrientedRange();
		            editor.addSelectionMarker(range);
		        }
		
		        var oldRange = selection.rangeList.rangeAtPoint(pos);
		        
		        
		        editor.$blockScrolling++;
		        editor.inVirtualSelectionMode = true;
		        
		        if (shift) {
		            oldRange = null;
		            range = selection.ranges[0] || range;
		            editor.removeSelectionMarker(range);
		        }
		        editor.once("mouseup", function() {
		            var tmpSel = selection.toOrientedRange();
		
		            if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor))
		                selection.substractPoint(tmpSel.cursor);
		            else {
		                if (shift) {
		                    selection.substractPoint(range.cursor);
		                } else if (range) {
		                    editor.removeSelectionMarker(range);
		                    selection.addRange(range);
		                }
		                selection.addRange(tmpSel);
		            }
		            editor.$blockScrolling--;
		            editor.inVirtualSelectionMode = false;
		        });
		
		    } else if (selectionMode == "block") {
		        e.stop();
		        editor.inVirtualSelectionMode = true;        
		        var initialRange;
		        var rectSel = [];
		        var blockSelect = function() {
		            var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
		            var cursor = session.screenToDocumentPosition(newCursor.row, newCursor.column);
		
		            if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor, selection.lead))
		                return;
		            screenCursor = newCursor;
		            
		            editor.$blockScrolling++;
		            editor.selection.moveToPosition(cursor);
		            editor.renderer.scrollCursorIntoView();
		
		            editor.removeSelectionMarkers(rectSel);
		            rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
		            if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty())
		                rectSel[0] = editor.$mouseHandler.$clickSelection.clone();
		            rectSel.forEach(editor.addSelectionMarker, editor);
		            editor.updateSelectionMarkers();
		            editor.$blockScrolling--;
		        };
		        editor.$blockScrolling++;
		        if (isMultiSelect && !accel) {
		            selection.toSingleRange();
		        } else if (!isMultiSelect && accel) {
		            initialRange = selection.toOrientedRange();
		            editor.addSelectionMarker(initialRange);
		        }
		        
		        if (shift)
		            screenAnchor = session.documentToScreenPosition(selection.lead);            
		        else
		            selection.moveToPosition(pos);
		        editor.$blockScrolling--;
		        
		        screenCursor = {row: -1, column: -1};
		
		        var onMouseSelectionEnd = function(e) {
		            clearInterval(timerId);
		            editor.removeSelectionMarkers(rectSel);
		            if (!rectSel.length)
		                rectSel = [selection.toOrientedRange()];
		            editor.$blockScrolling++;
		            if (initialRange) {
		                editor.removeSelectionMarker(initialRange);
		                selection.toSingleRange(initialRange);
		            }
		            for (var i = 0; i < rectSel.length; i++)
		                selection.addRange(rectSel[i]);
		            editor.inVirtualSelectionMode = false;
		            editor.$mouseHandler.$clickSelection = null;
		            editor.$blockScrolling--;
		        };
		
		        var onSelectionInterval = blockSelect;
		
		        event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);
		        var timerId = setInterval(function() {onSelectionInterval();}, 20);
		
		        return e.preventDefault();
		    }
		}
		
		
		exports.onMouseDown = onMouseDown;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/multi_select.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var RangeList = require("./range_list").RangeList;
		var Range = require("./range").Range;
		var Selection = require("./selection").Selection;
		var onMouseDown = require("./mouse/multi_select_handler").onMouseDown;
		var event = require("./lib/event");
		var lang = require("./lib/lang");
		var commands = require("./commands/multi_select_commands");
		exports.commands = commands.defaultCommands.concat(commands.multiSelectCommands);
		
		// Todo: session.find or editor.findVolatile that returns range
		var Search = require("./search").Search;
		var search = new Search();
		
		function find(session, needle, dir) {
		    search.$options.wrap = true;
		    search.$options.needle = needle;
		    search.$options.backwards = dir == -1;
		    return search.find(session);
		}
		
		// extend EditSession
		var EditSession = require("./edit_session").EditSession;
		(function() {
		    this.getSelectionMarkers = function() {
		        return this.$selectionMarkers;
		    };
		}).call(EditSession.prototype);
		
		// extend Selection
		(function() {
		    // list of ranges in reverse addition order
		    this.ranges = null;
		
		    // automatically sorted list of ranges
		    this.rangeList = null;
		
		    /** 
		     * Adds a range to a selection by entering multiselect mode, if necessary.
		     * @param {Range} range The new range to add
		     * @param {Boolean} $blockChangeEvents Whether or not to block changing events
		     * @method Selection.addRange
		     **/
		    this.addRange = function(range, $blockChangeEvents) {
		        if (!range)
		            return;
		
		        if (!this.inMultiSelectMode && this.rangeCount === 0) {
		            var oldRange = this.toOrientedRange();
		            this.rangeList.add(oldRange);
		            this.rangeList.add(range);
		            if (this.rangeList.ranges.length != 2) {
		                this.rangeList.removeAll();
		                return $blockChangeEvents || this.fromOrientedRange(range);
		            }
		            this.rangeList.removeAll();
		            this.rangeList.add(oldRange);
		            this.$onAddRange(oldRange);
		        }
		
		        if (!range.cursor)
		            range.cursor = range.end;
		
		        var removed = this.rangeList.add(range);
		
		        this.$onAddRange(range);
		
		        if (removed.length)
		            this.$onRemoveRange(removed);
		
		        if (this.rangeCount > 1 && !this.inMultiSelectMode) {
		            this._signal("multiSelect");
		            this.inMultiSelectMode = true;
		            this.session.$undoSelect = false;
		            this.rangeList.attach(this.session);
		        }
		
		        return $blockChangeEvents || this.fromOrientedRange(range);
		    };
		
		    /**
		     * @method Selection.toSingleRange
		     **/
		
		    this.toSingleRange = function(range) {
		        range = range || this.ranges[0];
		        var removed = this.rangeList.removeAll();
		        if (removed.length)
		            this.$onRemoveRange(removed);
		
		        range && this.fromOrientedRange(range);
		    };
		
		    /**
		     * Removes a Range containing pos (if it exists).
		     * @param {Range} pos The position to remove, as a `{row, column}` object
		     * @method Selection.substractPoint
		     **/
		    this.substractPoint = function(pos) {
		        var removed = this.rangeList.substractPoint(pos);
		        if (removed) {
		            this.$onRemoveRange(removed);
		            return removed[0];
		        }
		    };
		
		    /**
		     * Merges overlapping ranges ensuring consistency after changes
		     * @method Selection.mergeOverlappingRanges
		     **/
		    this.mergeOverlappingRanges = function() {
		        var removed = this.rangeList.merge();
		        if (removed.length)
		            this.$onRemoveRange(removed);
		        else if(this.ranges[0])
		            this.fromOrientedRange(this.ranges[0]);
		    };
		
		    this.$onAddRange = function(range) {
		        this.rangeCount = this.rangeList.ranges.length;
		        this.ranges.unshift(range);
		        this._signal("addRange", {range: range});
		    };
		
		    this.$onRemoveRange = function(removed) {
		        this.rangeCount = this.rangeList.ranges.length;
		        if (this.rangeCount == 1 && this.inMultiSelectMode) {
		            var lastRange = this.rangeList.ranges.pop();
		            removed.push(lastRange);
		            this.rangeCount = 0;
		        }
		
		        for (var i = removed.length; i--; ) {
		            var index = this.ranges.indexOf(removed[i]);
		            this.ranges.splice(index, 1);
		        }
		
		        this._signal("removeRange", {ranges: removed});
		
		        if (this.rangeCount === 0 && this.inMultiSelectMode) {
		            this.inMultiSelectMode = false;
		            this._signal("singleSelect");
		            this.session.$undoSelect = true;
		            this.rangeList.detach(this.session);
		        }
		
		        lastRange = lastRange || this.ranges[0];
		        if (lastRange && !lastRange.isEqual(this.getRange()))
		            this.fromOrientedRange(lastRange);
		    };
		
		    // adds multicursor support to selection
		    this.$initRangeList = function() {
		        if (this.rangeList)
		            return;
		
		        this.rangeList = new RangeList();
		        this.ranges = [];
		        this.rangeCount = 0;
		    };
		
		    /**
		     * Returns a concatenation of all the ranges.
		     * @returns {Array}
		     * @method Selection.getAllRanges
		     **/
		    this.getAllRanges = function() {
		        return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
		    };
		
		    /**
		     * Splits all the ranges into lines.
		     * @method Selection.splitIntoLines
		     **/
		
		    this.splitIntoLines = function () {
		        if (this.rangeCount > 1) {
		            var ranges = this.rangeList.ranges;
		            var lastRange = ranges[ranges.length - 1];
		            var range = Range.fromPoints(ranges[0].start, lastRange.end);
		
		            this.toSingleRange();
		            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
		        } else {
		            var range = this.getRange();
		            var isBackwards = this.isBackwards();
		            var startRow = range.start.row;
		            var endRow = range.end.row;
		            if (startRow == endRow) {
		                if (isBackwards)
		                    var start = range.end, end = range.start;
		                else
		                    var start = range.start, end = range.end;
		                
		                this.addRange(Range.fromPoints(end, end));
		                this.addRange(Range.fromPoints(start, start));
		                return;
		            }
		
		            var rectSel = [];
		            var r = this.getLineRange(startRow, true);
		            r.start.column = range.start.column;
		            rectSel.push(r);
		
		            for (var i = startRow + 1; i < endRow; i++)
		                rectSel.push(this.getLineRange(i, true));
		
		            r = this.getLineRange(endRow, true);
		            r.end.column = range.end.column;
		            rectSel.push(r);
		
		            rectSel.forEach(this.addRange, this);
		        }
		    };
		
		    /**
		     * @method Selection.toggleBlockSelection
		     **/
		    this.toggleBlockSelection = function () {
		        if (this.rangeCount > 1) {
		            var ranges = this.rangeList.ranges;
		            var lastRange = ranges[ranges.length - 1];
		            var range = Range.fromPoints(ranges[0].start, lastRange.end);
		
		            this.toSingleRange();
		            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
		        } else {
		            var cursor = this.session.documentToScreenPosition(this.selectionLead);
		            var anchor = this.session.documentToScreenPosition(this.selectionAnchor);
		
		            var rectSel = this.rectangularRangeBlock(cursor, anchor);
		            rectSel.forEach(this.addRange, this);
		        }
		    };
		
		    /**
		     * 
		     * Gets list of ranges composing rectangular block on the screen
		     * 
		     * @param {Cursor} screenCursor The cursor to use
		     * @param {Anchor} screenAnchor The anchor to use
		     * @param {Boolean} includeEmptyLines If true, this includes ranges inside the block which are empty due to clipping
		     * @returns {Range}
		     * @method Selection.rectangularRangeBlock
		     **/
		    this.rectangularRangeBlock = function(screenCursor, screenAnchor, includeEmptyLines) {
		        var rectSel = [];
		
		        var xBackwards = screenCursor.column < screenAnchor.column;
		        if (xBackwards) {
		            var startColumn = screenCursor.column;
		            var endColumn = screenAnchor.column;
		        } else {
		            var startColumn = screenAnchor.column;
		            var endColumn = screenCursor.column;
		        }
		
		        var yBackwards = screenCursor.row < screenAnchor.row;
		        if (yBackwards) {
		            var startRow = screenCursor.row;
		            var endRow = screenAnchor.row;
		        } else {
		            var startRow = screenAnchor.row;
		            var endRow = screenCursor.row;
		        }
		
		        if (startColumn < 0)
		            startColumn = 0;
		        if (startRow < 0)
		            startRow = 0;
		
		        if (startRow == endRow)
		            includeEmptyLines = true;
		
		        for (var row = startRow; row <= endRow; row++) {
		            var range = Range.fromPoints(
		                this.session.screenToDocumentPosition(row, startColumn),
		                this.session.screenToDocumentPosition(row, endColumn)
		            );
		            if (range.isEmpty()) {
		                if (docEnd && isSamePoint(range.end, docEnd))
		                    break;
		                var docEnd = range.end;
		            }
		            range.cursor = xBackwards ? range.start : range.end;
		            rectSel.push(range);
		        }
		
		        if (yBackwards)
		            rectSel.reverse();
		
		        if (!includeEmptyLines) {
		            var end = rectSel.length - 1;
		            while (rectSel[end].isEmpty() && end > 0)
		                end--;
		            if (end > 0) {
		                var start = 0;
		                while (rectSel[start].isEmpty())
		                    start++;
		            }
		            for (var i = end; i >= start; i--) {
		                if (rectSel[i].isEmpty())
		                    rectSel.splice(i, 1);
		            }
		        }
		
		        return rectSel;
		    };
		}).call(Selection.prototype);
		
		// extend Editor
		var Editor = require("./editor").Editor;
		(function() {
		
		    /** 
		     * 
		     * Updates the cursor and marker layers.
		     * @method Editor.updateSelectionMarkers
		     *
		     **/
		    this.updateSelectionMarkers = function() {
		        this.renderer.updateCursor();
		        this.renderer.updateBackMarkers();
		    };
		
		    /** 
		     * Adds the selection and cursor.
		     * @param {Range} orientedRange A range containing a cursor
		     * @returns {Range}
		     * @method Editor.addSelectionMarker
		     **/
		    this.addSelectionMarker = function(orientedRange) {
		        if (!orientedRange.cursor)
		            orientedRange.cursor = orientedRange.end;
		
		        var style = this.getSelectionStyle();
		        orientedRange.marker = this.session.addMarker(orientedRange, "ace_selection", style);
		
		        this.session.$selectionMarkers.push(orientedRange);
		        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
		        return orientedRange;
		    };
		
		    /** 
		     * Removes the selection marker.
		     * @param {Range} range The selection range added with [[Editor.addSelectionMarker `addSelectionMarker()`]].
		     * @method Editor.removeSelectionMarker
		     **/
		    this.removeSelectionMarker = function(range) {
		        if (!range.marker)
		            return;
		        this.session.removeMarker(range.marker);
		        var index = this.session.$selectionMarkers.indexOf(range);
		        if (index != -1)
		            this.session.$selectionMarkers.splice(index, 1);
		        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
		    };
		
		    this.removeSelectionMarkers = function(ranges) {
		        var markerList = this.session.$selectionMarkers;
		        for (var i = ranges.length; i--; ) {
		            var range = ranges[i];
		            if (!range.marker)
		                continue;
		            this.session.removeMarker(range.marker);
		            var index = markerList.indexOf(range);
		            if (index != -1)
		                markerList.splice(index, 1);
		        }
		        this.session.selectionMarkerCount = markerList.length;
		    };
		
		    this.$onAddRange = function(e) {
		        this.addSelectionMarker(e.range);
		        this.renderer.updateCursor();
		        this.renderer.updateBackMarkers();
		    };
		
		    this.$onRemoveRange = function(e) {
		        this.removeSelectionMarkers(e.ranges);
		        this.renderer.updateCursor();
		        this.renderer.updateBackMarkers();
		    };
		
		    this.$onMultiSelect = function(e) {
		        if (this.inMultiSelectMode)
		            return;
		        this.inMultiSelectMode = true;
		
		        this.setStyle("ace_multiselect");
		        this.keyBinding.addKeyboardHandler(commands.keyboardHandler);
		        this.commands.setDefaultHandler("exec", this.$onMultiSelectExec);
		
		        this.renderer.updateCursor();
		        this.renderer.updateBackMarkers();
		    };
		
		    this.$onSingleSelect = function(e) {
		        if (this.session.multiSelect.inVirtualMode)
		            return;
		        this.inMultiSelectMode = false;
		
		        this.unsetStyle("ace_multiselect");
		        this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);
		
		        this.commands.removeDefaultHandler("exec", this.$onMultiSelectExec);
		        this.renderer.updateCursor();
		        this.renderer.updateBackMarkers();
		        this._emit("changeSelection");
		    };
		
		    this.$onMultiSelectExec = function(e) {
		        var command = e.command;
		        var editor = e.editor;
		        if (!editor.multiSelect)
		            return;
		        if (!command.multiSelectAction) {
		            var result = command.exec(editor, e.args || {});
		            editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());
		            editor.multiSelect.mergeOverlappingRanges();
		        } else if (command.multiSelectAction == "forEach") {
		            result = editor.forEachSelection(command, e.args);
		        } else if (command.multiSelectAction == "forEachLine") {
		            result = editor.forEachSelection(command, e.args, true);
		        } else if (command.multiSelectAction == "single") {
		            editor.exitMultiSelectMode();
		            result = command.exec(editor, e.args || {});
		        } else {
		            result = command.multiSelectAction(editor, e.args || {});
		        }
		        return result;
		    };
		
		    /** 
		     * Executes a command for each selection range.
		     * @param {Object} cmd The command to execute
		     * @param {String} args Any arguments for the command
		     * @method Editor.forEachSelection
		     **/ 
		    this.forEachSelection = function(cmd, args, options) {
		        if (this.inVirtualSelectionMode)
		            return;
		        var keepOrder = options && options.keepOrder;
		        var $byLines = options == true || options && options.$byLines
		        var session = this.session;
		        var selection = this.selection;
		        var rangeList = selection.rangeList;
		        var ranges = (keepOrder ? selection : rangeList).ranges;
		        var result;
		        
		        if (!ranges.length)
		            return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
		        
		        var reg = selection._eventRegistry;
		        selection._eventRegistry = {};
		
		        var tmpSel = new Selection(session);
		        this.inVirtualSelectionMode = true;
		        for (var i = ranges.length; i--;) {
		            if ($byLines) {
		                while (i > 0 && ranges[i].start.row == ranges[i - 1].end.row)
		                    i--;
		            }
		            tmpSel.fromOrientedRange(ranges[i]);
		            tmpSel.index = i;
		            this.selection = session.selection = tmpSel;
		            var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
		            if (!result && cmdResult !== undefined)
		                result = cmdResult;
		            tmpSel.toOrientedRange(ranges[i]);
		        }
		        tmpSel.detach();
		
		        this.selection = session.selection = selection;
		        this.inVirtualSelectionMode = false;
		        selection._eventRegistry = reg;
		        selection.mergeOverlappingRanges();
		        
		        var anim = this.renderer.$scrollAnimation;
		        this.onCursorChange();
		        this.onSelectionChange();
		        if (anim && anim.from == anim.to)
		            this.renderer.animateScrolling(anim.from);
		        
		        return result;
		    };
		
		    /** 
		    * Removes all the selections except the last added one.
		    * @method Editor.exitMultiSelectMode
		    **/
		    this.exitMultiSelectMode = function() {
		        if (!this.inMultiSelectMode || this.inVirtualSelectionMode)
		            return;
		        this.multiSelect.toSingleRange();
		    };
		
		    this.getSelectedText = function() {
		        var text = "";
		        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
		            var ranges = this.multiSelect.rangeList.ranges;
		            var buf = [];
		            for (var i = 0; i < ranges.length; i++) {
		                buf.push(this.session.getTextRange(ranges[i]));
		            }
		            var nl = this.session.getDocument().getNewLineCharacter();
		            text = buf.join(nl);
		            if (text.length == (buf.length - 1) * nl.length)
		                text = "";
		        } else if (!this.selection.isEmpty()) {
		            text = this.session.getTextRange(this.getSelectionRange());
		        }
		        return text;
		    };
		    
		    this.$checkMultiselectChange = function(e, anchor) {
		        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
		            var range = this.multiSelect.ranges[0];
		            if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor)
		                return;
		            var pos = anchor == this.multiSelect.anchor
		                ? range.cursor == range.start ? range.end : range.start
		                : range.cursor;
		            if (pos.row != anchor.row 
		                || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column)
		                this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());
		        }
		    };
		
		    /**
		     * Finds and selects all the occurences of `needle`.
		     * @param {String} The text to find
		     * @param {Object} The search options
		     * @param {Boolean} keeps
		     *
		     * @returns {Number} The cumulative count of all found matches 
		     * @method Editor.findAll
		     **/
		    this.findAll = function(needle, options, additive) {
		        options = options || {};
		        options.needle = needle || options.needle;
		        if (options.needle == undefined) {
		            var range = this.selection.isEmpty()
		                ? this.selection.getWordRange()
		                : this.selection.getRange();
		            options.needle = this.session.getTextRange(range);
		        }    
		        this.$search.set(options);
		        
		        var ranges = this.$search.findAll(this.session);
		        if (!ranges.length)
		            return 0;
		
		        this.$blockScrolling += 1;
		        var selection = this.multiSelect;
		
		        if (!additive)
		            selection.toSingleRange(ranges[0]);
		
		        for (var i = ranges.length; i--; )
		            selection.addRange(ranges[i], true);
		
		        // keep old selection as primary if possible
		        if (range && selection.rangeList.rangeAtPoint(range.start))
		            selection.addRange(range, true);
		        
		        this.$blockScrolling -= 1;
		
		        return ranges.length;
		    };
		
		    /**
		     * Adds a cursor above or below the active cursor.
		     * 
		     * @param {Number} dir The direction of lines to select: -1 for up, 1 for down
		     * @param {Boolean} skip If `true`, removes the active selection range
		     *
		     * @method Editor.selectMoreLines 
		     */
		    this.selectMoreLines = function(dir, skip) {
		        var range = this.selection.toOrientedRange();
		        var isBackwards = range.cursor == range.end;
		
		        var screenLead = this.session.documentToScreenPosition(range.cursor);
		        if (this.selection.$desiredColumn)
		            screenLead.column = this.selection.$desiredColumn;
		
		        var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);
		
		        if (!range.isEmpty()) {
		            var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);
		            var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
		        } else {
		            var anchor = lead;
		        }
		
		        if (isBackwards) {
		            var newRange = Range.fromPoints(lead, anchor);
		            newRange.cursor = newRange.start;
		        } else {
		            var newRange = Range.fromPoints(anchor, lead);
		            newRange.cursor = newRange.end;
		        }
		
		        newRange.desiredColumn = screenLead.column;
		        if (!this.selection.inMultiSelectMode) {
		            this.selection.addRange(range);
		        } else {
		            if (skip)
		                var toRemove = range.cursor;
		        }
		
		        this.selection.addRange(newRange);
		        if (toRemove)
		            this.selection.substractPoint(toRemove);
		    };
		
		    /** 
		     * Transposes the selected ranges.
		     * @param {Number} dir The direction to rotate selections
		     * @method Editor.transposeSelections
		     **/
		    this.transposeSelections = function(dir) {
		        var session = this.session;
		        var sel = session.multiSelect;
		        var all = sel.ranges;
		
		        for (var i = all.length; i--; ) {
		            var range = all[i];
		            if (range.isEmpty()) {
		                var tmp = session.getWordRange(range.start.row, range.start.column);
		                range.start.row = tmp.start.row;
		                range.start.column = tmp.start.column;
		                range.end.row = tmp.end.row;
		                range.end.column = tmp.end.column;
		            }
		        }
		        sel.mergeOverlappingRanges();
		
		        var words = [];
		        for (var i = all.length; i--; ) {
		            var range = all[i];
		            words.unshift(session.getTextRange(range));
		        }
		
		        if (dir < 0)
		            words.unshift(words.pop());
		        else
		            words.push(words.shift());
		
		        for (var i = all.length; i--; ) {
		            var range = all[i];
		            var tmp = range.clone();
		            session.replace(range, words[i]);
		            range.start.row = tmp.start.row;
		            range.start.column = tmp.start.column;
		        }
		    };
		
		    /** 
		     * Finds the next occurence of text in an active selection and adds it to the selections.
		     * @param {Number} dir The direction of lines to select: -1 for up, 1 for down
		     * @param {Boolean} skip If `true`, removes the active selection range
		     * @method Editor.selectMore
		     **/
		    this.selectMore = function(dir, skip, stopAtFirst) {
		        var session = this.session;
		        var sel = session.multiSelect;
		
		        var range = sel.toOrientedRange();
		        if (range.isEmpty()) {
		            range = session.getWordRange(range.start.row, range.start.column);
		            range.cursor = dir == -1 ? range.start : range.end;
		            this.multiSelect.addRange(range);
		            if (stopAtFirst)
		                return;
		        }
		        var needle = session.getTextRange(range);
		
		        var newRange = find(session, needle, dir);
		        if (newRange) {
		            newRange.cursor = dir == -1 ? newRange.start : newRange.end;
		            this.$blockScrolling += 1;
		            this.session.unfold(newRange);
		            this.multiSelect.addRange(newRange);
		            this.$blockScrolling -= 1;
		            this.renderer.scrollCursorIntoView(null, 0.5);
		        }
		        if (skip)
		            this.multiSelect.substractPoint(range.cursor);
		    };
		
		    /** 
		     * Aligns the cursors or selected text.
		     * @method Editor.alignCursors
		     **/
		    this.alignCursors = function() {
		        var session = this.session;
		        var sel = session.multiSelect;
		        var ranges = sel.ranges;
		        // filter out ranges on same row
		        var row = -1;
		        var sameRowRanges = ranges.filter(function(r) {
		            if (r.cursor.row == row)
		                return true;
		            row = r.cursor.row;
		        });
		        
		        if (!ranges.length || sameRowRanges.length == ranges.length - 1) {
		            var range = this.selection.getRange();
		            var fr = range.start.row, lr = range.end.row;
		            var guessRange = fr == lr;
		            if (guessRange) {
		                var max = this.session.getLength();
		                var line;
		                do {
		                    line = this.session.getLine(lr);
		                } while (/[=:]/.test(line) && ++lr < max);
		                do {
		                    line = this.session.getLine(fr);
		                } while (/[=:]/.test(line) && --fr > 0);
		                
		                if (fr < 0) fr = 0;
		                if (lr >= max) lr = max - 1;
		            }
		            var lines = this.session.removeFullLines(fr, lr);
		            lines = this.$reAlignText(lines, guessRange);
		            this.session.insert({row: fr, column: 0}, lines.join("\n") + "\n");
		            if (!guessRange) {
		                range.start.column = 0;
		                range.end.column = lines[lines.length - 1].length;
		            }
		            this.selection.setRange(range);
		        } else {
		            sameRowRanges.forEach(function(r) {
		                sel.substractPoint(r.cursor);
		            });
		
		            var maxCol = 0;
		            var minSpace = Infinity;
		            var spaceOffsets = ranges.map(function(r) {
		                var p = r.cursor;
		                var line = session.getLine(p.row);
		                var spaceOffset = line.substr(p.column).search(/\S/g);
		                if (spaceOffset == -1)
		                    spaceOffset = 0;
		
		                if (p.column > maxCol)
		                    maxCol = p.column;
		                if (spaceOffset < minSpace)
		                    minSpace = spaceOffset;
		                return spaceOffset;
		            });
		            ranges.forEach(function(r, i) {
		                var p = r.cursor;
		                var l = maxCol - p.column;
		                var d = spaceOffsets[i] - minSpace;
		                if (l > d)
		                    session.insert(p, lang.stringRepeat(" ", l - d));
		                else
		                    session.remove(new Range(p.row, p.column, p.row, p.column - l + d));
		
		                r.start.column = r.end.column = maxCol;
		                r.start.row = r.end.row = p.row;
		                r.cursor = r.end;
		            });
		            sel.fromOrientedRange(ranges[0]);
		            this.renderer.updateCursor();
		            this.renderer.updateBackMarkers();
		        }
		    };
		
		    this.$reAlignText = function(lines, forceLeft) {
		        var isLeftAligned = true, isRightAligned = true;
		        var startW, textW, endW;
		
		        return lines.map(function(line) {
		            var m = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
		            if (!m)
		                return [line];
		
		            if (startW == null) {
		                startW = m[1].length;
		                textW = m[2].length;
		                endW = m[3].length;
		                return m;
		            }
		
		            if (startW + textW + endW != m[1].length + m[2].length + m[3].length)
		                isRightAligned = false;
		            if (startW != m[1].length)
		                isLeftAligned = false;
		
		            if (startW > m[1].length)
		                startW = m[1].length;
		            if (textW < m[2].length)
		                textW = m[2].length;
		            if (endW > m[3].length)
		                endW = m[3].length;
		
		            return m;
		        }).map(forceLeft ? alignLeft :
		            isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);
		
		        function spaces(n) {
		            return lang.stringRepeat(" ", n);
		        }
		
		        function alignLeft(m) {
		            return !m[2] ? m[0] : spaces(startW) + m[2]
		                + spaces(textW - m[2].length + endW)
		                + m[4].replace(/^([=:])\s+/, "$1 ");
		        }
		        function alignRight(m) {
		            return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2]
		                + spaces(endW, " ")
		                + m[4].replace(/^([=:])\s+/, "$1 ");
		        }
		        function unAlign(m) {
		            return !m[2] ? m[0] : spaces(startW) + m[2]
		                + spaces(endW)
		                + m[4].replace(/^([=:])\s+/, "$1 ");
		        }
		    };
		}).call(Editor.prototype);
		
		
		function isSamePoint(p1, p2) {
		    return p1.row == p2.row && p1.column == p2.column;
		}
		
		// patch
		// adds multicursor support to a session
		exports.onSessionChange = function(e) {
		    var session = e.session;
		    if (session && !session.multiSelect) {
		        session.$selectionMarkers = [];
		        session.selection.$initRangeList();
		        session.multiSelect = session.selection;
		    }
		    this.multiSelect = session && session.multiSelect;
		
		    var oldSession = e.oldSession;
		    if (oldSession) {
		        oldSession.multiSelect.off("addRange", this.$onAddRange);
		        oldSession.multiSelect.off("removeRange", this.$onRemoveRange);
		        oldSession.multiSelect.off("multiSelect", this.$onMultiSelect);
		        oldSession.multiSelect.off("singleSelect", this.$onSingleSelect);
		        oldSession.multiSelect.lead.off("change", this.$checkMultiselectChange);
		        oldSession.multiSelect.anchor.off("change", this.$checkMultiselectChange);
		    }
		
		    if (session) {
		        session.multiSelect.on("addRange", this.$onAddRange);
		        session.multiSelect.on("removeRange", this.$onRemoveRange);
		        session.multiSelect.on("multiSelect", this.$onMultiSelect);
		        session.multiSelect.on("singleSelect", this.$onSingleSelect);
		        session.multiSelect.lead.on("change", this.$checkMultiselectChange);
		        session.multiSelect.anchor.on("change", this.$checkMultiselectChange);
		    }
		
		    if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {
		        if (session.selection.inMultiSelectMode)
		            this.$onMultiSelect();
		        else
		            this.$onSingleSelect();
		    }
		};
		
		// MultiSelect(editor)
		// adds multiple selection support to the editor
		// (note: should be called only once for each editor instance)
		function MultiSelect(editor) {
		    if (editor.$multiselectOnSessionChange)
		        return;
		    editor.$onAddRange = editor.$onAddRange.bind(editor);
		    editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);
		    editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);
		    editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);
		    editor.$multiselectOnSessionChange = exports.onSessionChange.bind(editor);
		    editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);
		
		    editor.$multiselectOnSessionChange(editor);
		    editor.on("changeSession", editor.$multiselectOnSessionChange);
		
		    editor.on("mousedown", onMouseDown);
		    editor.commands.addCommands(commands.defaultCommands);
		
		    addAltCursorListeners(editor);
		}
		
		function addAltCursorListeners(editor){
		    var el = editor.textInput.getElement();
		    var altCursor = false;
		    event.addListener(el, "keydown", function(e) {
		        var altDown = e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey);
		        if (editor.$blockSelectEnabled && altDown) {
		            if (!altCursor) {
		                editor.renderer.setMouseCursor("crosshair");
		                altCursor = true;
		            }
		        } else if (altCursor) {
		            reset();
		        }
		    });
		
		    event.addListener(el, "keyup", reset);
		    event.addListener(el, "blur", reset);
		    function reset(e) {
		        if (altCursor) {
		            editor.renderer.setMouseCursor("");
		            altCursor = false;
		            // TODO disable menu poping up
		            // e && e.preventDefault()
		        }
		    }
		}
		
		exports.MultiSelect = MultiSelect;
		
		
		require("./config").defineOptions(Editor.prototype, "editor", {
		    enableMultiselect: {
		        set: function(val) {
		            MultiSelect(this);
		            if (val) {
		                this.on("changeSession", this.$multiselectOnSessionChange);
		                this.on("mousedown", onMouseDown);
		            } else {
		                this.off("changeSession", this.$multiselectOnSessionChange);
		                this.off("mousedown", onMouseDown);
		            }
		        },
		        value: true
		    },
		    enableBlockSelect: {
		        set: function(val) {
		            this.$blockSelectEnabled = val;
		        },
		        value: true
		    }
		});
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/multi_select_handler.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var event = require("../lib/event");
		var useragent = require("../lib/useragent");
		
		// mouse
		function isSamePoint(p1, p2) {
		    return p1.row == p2.row && p1.column == p2.column;
		}
		
		function onMouseDown(e) {
		    var ev = e.domEvent;
		    var alt = ev.altKey;
		    var shift = ev.shiftKey;
		    var ctrl = ev.ctrlKey;
		    var accel = e.getAccelKey();
		    var button = e.getButton();
		    
		    if (ctrl && useragent.isMac)
		        button = ev.button;
		
		    if (e.editor.inMultiSelectMode && button == 2) {
		        e.editor.textInput.onContextMenu(e.domEvent);
		        return;
		    }
		    
		    if (!ctrl && !alt && !accel) {
		        if (button === 0 && e.editor.inMultiSelectMode)
		            e.editor.exitMultiSelectMode();
		        return;
		    }
		    
		    if (button !== 0)
		        return;
		
		    var editor = e.editor;
		    var selection = editor.selection;
		    var isMultiSelect = editor.inMultiSelectMode;
		    var pos = e.getDocumentPosition();
		    var cursor = selection.getCursor();
		    var inSelection = e.inSelection() || (selection.isEmpty() && isSamePoint(pos, cursor));
		
		    var mouseX = e.x, mouseY = e.y;
		    var onMouseSelection = function(e) {
		        mouseX = e.clientX;
		        mouseY = e.clientY;
		    };
		    
		    var session = editor.session;
		    var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
		    var screenCursor = screenAnchor;
		    
		    var selectionMode;
		    if (editor.$mouseHandler.$enableJumpToDef) {
		        if (ctrl && alt || accel && alt)
		            selectionMode = shift ? "block" : "add";
		        else if (alt && editor.$blockSelectEnabled)
		            selectionMode = "block";
		    } else {
		        if (accel && !alt) {
		            selectionMode = "add";
		            if (!isMultiSelect && shift)
		                return;
		        } else if (alt && editor.$blockSelectEnabled) {
		            selectionMode = "block";
		        }
		    }
		    
		    if (selectionMode && useragent.isMac && ev.ctrlKey) {
		        editor.$mouseHandler.cancelContextMenu();
		    }
		
		    if (selectionMode == "add") {
		        if (!isMultiSelect && inSelection)
		            return; // dragging
		
		        if (!isMultiSelect) {
		            var range = selection.toOrientedRange();
		            editor.addSelectionMarker(range);
		        }
		
		        var oldRange = selection.rangeList.rangeAtPoint(pos);
		        
		        
		        editor.$blockScrolling++;
		        editor.inVirtualSelectionMode = true;
		        
		        if (shift) {
		            oldRange = null;
		            range = selection.ranges[0] || range;
		            editor.removeSelectionMarker(range);
		        }
		        editor.once("mouseup", function() {
		            var tmpSel = selection.toOrientedRange();
		
		            if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor))
		                selection.substractPoint(tmpSel.cursor);
		            else {
		                if (shift) {
		                    selection.substractPoint(range.cursor);
		                } else if (range) {
		                    editor.removeSelectionMarker(range);
		                    selection.addRange(range);
		                }
		                selection.addRange(tmpSel);
		            }
		            editor.$blockScrolling--;
		            editor.inVirtualSelectionMode = false;
		        });
		
		    } else if (selectionMode == "block") {
		        e.stop();
		        editor.inVirtualSelectionMode = true;        
		        var initialRange;
		        var rectSel = [];
		        var blockSelect = function() {
		            var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
		            var cursor = session.screenToDocumentPosition(newCursor.row, newCursor.column);
		
		            if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor, selection.lead))
		                return;
		            screenCursor = newCursor;
		            
		            editor.$blockScrolling++;
		            editor.selection.moveToPosition(cursor);
		            editor.renderer.scrollCursorIntoView();
		
		            editor.removeSelectionMarkers(rectSel);
		            rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
		            if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty())
		                rectSel[0] = editor.$mouseHandler.$clickSelection.clone();
		            rectSel.forEach(editor.addSelectionMarker, editor);
		            editor.updateSelectionMarkers();
		            editor.$blockScrolling--;
		        };
		        editor.$blockScrolling++;
		        if (isMultiSelect && !accel) {
		            selection.toSingleRange();
		        } else if (!isMultiSelect && accel) {
		            initialRange = selection.toOrientedRange();
		            editor.addSelectionMarker(initialRange);
		        }
		        
		        if (shift)
		            screenAnchor = session.documentToScreenPosition(selection.lead);            
		        else
		            selection.moveToPosition(pos);
		        editor.$blockScrolling--;
		        
		        screenCursor = {row: -1, column: -1};
		
		        var onMouseSelectionEnd = function(e) {
		            clearInterval(timerId);
		            editor.removeSelectionMarkers(rectSel);
		            if (!rectSel.length)
		                rectSel = [selection.toOrientedRange()];
		            editor.$blockScrolling++;
		            if (initialRange) {
		                editor.removeSelectionMarker(initialRange);
		                selection.toSingleRange(initialRange);
		            }
		            for (var i = 0; i < rectSel.length; i++)
		                selection.addRange(rectSel[i]);
		            editor.inVirtualSelectionMode = false;
		            editor.$mouseHandler.$clickSelection = null;
		            editor.$blockScrolling--;
		        };
		
		        var onSelectionInterval = blockSelect;
		
		        event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);
		        var timerId = setInterval(function() {onSelectionInterval();}, 20);
		
		        return e.preventDefault();
		    }
		}
		
		
		exports.onMouseDown = onMouseDown;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/placeholder.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var Range = require("./range").Range;
		var EventEmitter = require("./lib/event_emitter").EventEmitter;
		var oop = require("./lib/oop");
		
		/**
		 * @class PlaceHolder
		 *
		 **/
		
		/**
		 * - session (Document): The document to associate with the anchor
		 * - length (Number): The starting row position
		 * - pos (Number): The starting column position
		 * - others (String):
		 * - mainClass (String):
		 * - othersClass (String):
		 * 
		 * @constructor
		 **/
		
		var PlaceHolder = function(session, length, pos, others, mainClass, othersClass) {
		    var _self = this;
		    this.length = length;
		    this.session = session;
		    this.doc = session.getDocument();
		    this.mainClass = mainClass;
		    this.othersClass = othersClass;
		    this.$onUpdate = this.onUpdate.bind(this);
		    this.doc.on("change", this.$onUpdate);
		    this.$others = others;
		    
		    this.$onCursorChange = function() {
		        setTimeout(function() {
		            _self.onCursorChange();
		        });
		    };
		    
		    this.$pos = pos;
		    // Used for reset
		    var undoStack = session.getUndoManager().$undoStack || session.getUndoManager().$undostack || {length: -1};
		    this.$undoStackDepth = undoStack.length;
		    this.setup();
		
		    session.selection.on("changeCursor", this.$onCursorChange);
		};
		
		(function() {
		
		    oop.implement(this, EventEmitter);
		
		    /**
		     * PlaceHolder.setup()
		     *
		     * TODO
		     *
		     **/
		    this.setup = function() {
		        var _self = this;
		        var doc = this.doc;
		        var session = this.session;
		        
		        this.selectionBefore = session.selection.toJSON();
		        if (session.selection.inMultiSelectMode)
		            session.selection.toSingleRange();
		
		        this.pos = doc.createAnchor(this.$pos.row, this.$pos.column);
		        var pos = this.pos;
		        pos.$insertRight = true;
		        pos.detach();
		        pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
		        this.others = [];
		        this.$others.forEach(function(other) {
		            var anchor = doc.createAnchor(other.row, other.column);
		            anchor.$insertRight = true;
		            anchor.detach();
		            _self.others.push(anchor);
		        });
		        session.setUndoSelect(false);
		    };
		    
		    /**
		     * PlaceHolder.showOtherMarkers()
		     *
		     * TODO
		     *
		     **/
		    this.showOtherMarkers = function() {
		        if (this.othersActive) return;
		        var session = this.session;
		        var _self = this;
		        this.othersActive = true;
		        this.others.forEach(function(anchor) {
		            anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column+_self.length), _self.othersClass, null, false);
		        });
		    };
		    
		    /**
		     * PlaceHolder.hideOtherMarkers()
		     *
		     * Hides all over markers in the [[EditSession `EditSession`]] that are not the currently selected one.
		     *
		     **/
		    this.hideOtherMarkers = function() {
		        if (!this.othersActive) return;
		        this.othersActive = false;
		        for (var i = 0; i < this.others.length; i++) {
		            this.session.removeMarker(this.others[i].markerId);
		        }
		    };
		
		    /**
		     * PlaceHolder@onUpdate(e)
		     * 
		     * Emitted when the place holder updates.
		     *
		     **/
		    this.onUpdate = function(delta) {
		        if (this.$updating)
		            return this.updateAnchors(delta);
		            
		        var range = delta;
		        if (range.start.row !== range.end.row) return;
		        if (range.start.row !== this.pos.row) return;
		        this.$updating = true;
		        var lengthDiff = delta.action === "insert" ? range.end.column - range.start.column : range.start.column - range.end.column;
		        var inMainRange = range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1;
		        var distanceFromStart = range.start.column - this.pos.column;
		        
		        this.updateAnchors(delta);
		        
		        if (inMainRange)
		            this.length += lengthDiff;
		
		        if (inMainRange && !this.session.$fromUndo) {
		            if (delta.action === 'insert') {
		                for (var i = this.others.length - 1; i >= 0; i--) {
		                    var otherPos = this.others[i];
		                    var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};
		                    this.doc.insertMergedLines(newPos, delta.lines);
		                }
		            } else if (delta.action === 'remove') {
		                for (var i = this.others.length - 1; i >= 0; i--) {
		                    var otherPos = this.others[i];
		                    var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};
		                    this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
		                }
		            }
		        }
		        
		        this.$updating = false;
		        this.updateMarkers();
		    };
		    
		    this.updateAnchors = function(delta) {
		        this.pos.onChange(delta);
		        for (var i = this.others.length; i--;)
		            this.others[i].onChange(delta);
		        this.updateMarkers();
		    };
		    
		    this.updateMarkers = function() {
		        if (this.$updating)
		            return;
		        var _self = this;
		        var session = this.session;
		        var updateMarker = function(pos, className) {
		            session.removeMarker(pos.markerId);
		            pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column+_self.length), className, null, false);
		        };
		        updateMarker(this.pos, this.mainClass);
		        for (var i = this.others.length; i--;)
		            updateMarker(this.others[i], this.othersClass);
		    };
		    
		    /**
		     * PlaceHolder@onCursorChange(e)
		     * 
		     * Emitted when the cursor changes.
		     *
		     **/
		
		    this.onCursorChange = function(event) {
		        if (this.$updating || !this.session) return;
		        var pos = this.session.selection.getCursor();
		        if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {
		            this.showOtherMarkers();
		            this._emit("cursorEnter", event);
		        } else {
		            this.hideOtherMarkers();
		            this._emit("cursorLeave", event);
		        }
		    };
		    
		    /**
		     * PlaceHolder.detach()
		     * 
		     * TODO
		     *
		     **/    
		    this.detach = function() {
		        this.session.removeMarker(this.pos && this.pos.markerId);
		        this.hideOtherMarkers();
		        this.doc.removeEventListener("change", this.$onUpdate);
		        this.session.selection.removeEventListener("changeCursor", this.$onCursorChange);
		        this.session.setUndoSelect(true);
		        this.session = null;
		    };
		    
		    /**
		     * PlaceHolder.cancel()
		     * 
		     * TODO
		     *
		     **/
		    this.cancel = function() {
		        if (this.$undoStackDepth === -1)
		            return;
		        var undoManager = this.session.getUndoManager();
		        var undosRequired = (undoManager.$undoStack || undoManager.$undostack).length - this.$undoStackDepth;
		        for (var i = 0; i < undosRequired; i++) {
		            undoManager.undo(true);
		        }
		        if (this.selectionBefore)
		            this.session.selection.fromJSON(this.selectionBefore);
		    };
		}).call(PlaceHolder.prototype);
		
		
		exports.PlaceHolder = PlaceHolder;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/range.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var comparePoints = function(p1, p2) {
		    return p1.row - p2.row || p1.column - p2.column;
		};
		/**
		 * This object is used in various places to indicate a region within the editor. To better visualize how this works, imagine a rectangle. Each quadrant of the rectangle is analogus to a range, as ranges contain a starting row and starting column, and an ending row, and ending column.
		 * @class Range
		 **/
		
		/**
		 * Creates a new `Range` object with the given starting and ending row and column points.
		 * @param {Number} startRow The starting row
		 * @param {Number} startColumn The starting column
		 * @param {Number} endRow The ending row
		 * @param {Number} endColumn The ending column
		 *
		 * @constructor
		 **/
		var Range = function(startRow, startColumn, endRow, endColumn) {
		    this.start = {
		        row: startRow,
		        column: startColumn
		    };
		
		    this.end = {
		        row: endRow,
		        column: endColumn
		    };
		};
		
		(function() {
		    /**
		     * Returns `true` if and only if the starting row and column, and ending row and column, are equivalent to those given by `range`.
		     * @param {Range} range A range to check against
		     *
		     * @return {Boolean}
		     **/
		    this.isEqual = function(range) {
		        return this.start.row === range.start.row &&
		            this.end.row === range.end.row &&
		            this.start.column === range.start.column &&
		            this.end.column === range.end.column;
		    };
		
		    /**
		     *
		     * Returns a string containing the range's row and column information, given like this:
		     * ```
		     *    [start.row/start.column] -> [end.row/end.column]
		     * ```
		     * @return {String}
		     **/
		    this.toString = function() {
		        return ("Range: [" + this.start.row + "/" + this.start.column +
		            "] -> [" + this.end.row + "/" + this.end.column + "]");
		    };
		
		    /**
		     *
		     * Returns `true` if the `row` and `column` provided are within the given range. This can better be expressed as returning `true` if:
		     * ```javascript
		     *    this.start.row <= row <= this.end.row &&
		     *    this.start.column <= column <= this.end.column
		     * ```
		     * @param {Number} row A row to check for
		     * @param {Number} column A column to check for
		     * @returns {Boolean}
		     * @related Range.compare
		     **/
		
		    this.contains = function(row, column) {
		        return this.compare(row, column) == 0;
		    };
		
		    /**
		     * Compares `this` range (A) with another range (B).
		     * @param {Range} range A range to compare with
		     *
		     * @related Range.compare
		     * @returns {Number} This method returns one of the following numbers:<br/>
		     * <br/>
		     * * `-2`: (B) is in front of (A), and doesn't intersect with (A)<br/>
		     * * `-1`: (B) begins before (A) but ends inside of (A)<br/>
		     * * `0`: (B) is completely inside of (A) OR (A) is completely inside of (B)<br/>
		     * * `+1`: (B) begins inside of (A) but ends outside of (A)<br/>
		     * * `+2`: (B) is after (A) and doesn't intersect with (A)<br/>
		     * * `42`: FTW state: (B) ends in (A) but starts outside of (A)
		     **/
		    this.compareRange = function(range) {
		        var cmp,
		            end = range.end,
		            start = range.start;
		
		        cmp = this.compare(end.row, end.column);
		        if (cmp == 1) {
		            cmp = this.compare(start.row, start.column);
		            if (cmp == 1) {
		                return 2;
		            } else if (cmp == 0) {
		                return 1;
		            } else {
		                return 0;
		            }
		        } else if (cmp == -1) {
		            return -2;
		        } else {
		            cmp = this.compare(start.row, start.column);
		            if (cmp == -1) {
		                return -1;
		            } else if (cmp == 1) {
		                return 42;
		            } else {
		                return 0;
		            }
		        }
		    };
		
		    /**
		     * Checks the row and column points of `p` with the row and column points of the calling range.
		     *
		     * @param {Range} p A point to compare with
		     *
		     * @related Range.compare
		     * @returns {Number} This method returns one of the following numbers:<br/>
		     * * `0` if the two points are exactly equal<br/>
		     * * `-1` if `p.row` is less then the calling range<br/>
		     * * `1` if `p.row` is greater than the calling range<br/>
		     * <br/>
		     * If the starting row of the calling range is equal to `p.row`, and:<br/>
		     * * `p.column` is greater than or equal to the calling range's starting column, this returns `0`<br/>
		     * * Otherwise, it returns -1<br/>
		     *<br/>
		     * If the ending row of the calling range is equal to `p.row`, and:<br/>
		     * * `p.column` is less than or equal to the calling range's ending column, this returns `0`<br/>
		     * * Otherwise, it returns 1<br/>
		     **/
		    this.comparePoint = function(p) {
		        return this.compare(p.row, p.column);
		    };
		
		    /**
		     * Checks the start and end points of `range` and compares them to the calling range. Returns `true` if the `range` is contained within the caller's range.
		     * @param {Range} range A range to compare with
		     *
		     * @returns {Boolean}
		     * @related Range.comparePoint
		     **/
		    this.containsRange = function(range) {
		        return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
		    };
		
		    /**
		     * Returns `true` if passed in `range` intersects with the one calling this method.
		     * @param {Range} range A range to compare with
		     *
		     * @returns {Boolean}
		     **/
		    this.intersects = function(range) {
		        var cmp = this.compareRange(range);
		        return (cmp == -1 || cmp == 0 || cmp == 1);
		    };
		
		    /**
		     * Returns `true` if the caller's ending row point is the same as `row`, and if the caller's ending column is the same as `column`.
		     * @param {Number} row A row point to compare with
		     * @param {Number} column A column point to compare with
		     *
		     * @returns {Boolean}
		     **/
		    this.isEnd = function(row, column) {
		        return this.end.row == row && this.end.column == column;
		    };
		
		    /**
		     * Returns `true` if the caller's starting row point is the same as `row`, and if the caller's starting column is the same as `column`.
		     * @param {Number} row A row point to compare with
		     * @param {Number} column A column point to compare with
		     *
		     * @returns {Boolean}
		     **/
		    this.isStart = function(row, column) {
		        return this.start.row == row && this.start.column == column;
		    };
		
		    /**
		     * Sets the starting row and column for the range.
		     * @param {Number} row A row point to set
		     * @param {Number} column A column point to set
		     *
		     **/
		    this.setStart = function(row, column) {
		        if (typeof row == "object") {
		            this.start.column = row.column;
		            this.start.row = row.row;
		        } else {
		            this.start.row = row;
		            this.start.column = column;
		        }
		    };
		
		    /**
		     * Sets the starting row and column for the range.
		     * @param {Number} row A row point to set
		     * @param {Number} column A column point to set
		     *
		     **/
		    this.setEnd = function(row, column) {
		        if (typeof row == "object") {
		            this.end.column = row.column;
		            this.end.row = row.row;
		        } else {
		            this.end.row = row;
		            this.end.column = column;
		        }
		    };
		
		    /**
		     * Returns `true` if the `row` and `column` are within the given range.
		     * @param {Number} row A row point to compare with
		     * @param {Number} column A column point to compare with
		     *
		     *
		     * @returns {Boolean}
		     * @related Range.compare
		     **/
		    this.inside = function(row, column) {
		        if (this.compare(row, column) == 0) {
		            if (this.isEnd(row, column) || this.isStart(row, column)) {
		                return false;
		            } else {
		                return true;
		            }
		        }
		        return false;
		    };
		
		    /**
		     * Returns `true` if the `row` and `column` are within the given range's starting points.
		     * @param {Number} row A row point to compare with
		     * @param {Number} column A column point to compare with
		     *
		     * @returns {Boolean}
		     * @related Range.compare
		     **/
		    this.insideStart = function(row, column) {
		        if (this.compare(row, column) == 0) {
		            if (this.isEnd(row, column)) {
		                return false;
		            } else {
		                return true;
		            }
		        }
		        return false;
		    };
		
		    /**
		     * Returns `true` if the `row` and `column` are within the given range's ending points.
		     * @param {Number} row A row point to compare with
		     * @param {Number} column A column point to compare with
		     *
		     * @returns {Boolean}
		     * @related Range.compare
		     *
		     **/
		    this.insideEnd = function(row, column) {
		        if (this.compare(row, column) == 0) {
		            if (this.isStart(row, column)) {
		                return false;
		            } else {
		                return true;
		            }
		        }
		        return false;
		    };
		
		    /**
		     * Checks the row and column points with the row and column points of the calling range.
		     * @param {Number} row A row point to compare with
		     * @param {Number} column A column point to compare with
		     *
		     *
		     * @returns {Number} This method returns one of the following numbers:<br/>
		     * `0` if the two points are exactly equal <br/>
		     * `-1` if `p.row` is less then the calling range <br/>
		     * `1` if `p.row` is greater than the calling range <br/>
		     *  <br/>
		     * If the starting row of the calling range is equal to `p.row`, and: <br/>
		     * `p.column` is greater than or equal to the calling range's starting column, this returns `0`<br/>
		     * Otherwise, it returns -1<br/>
		     * <br/>
		     * If the ending row of the calling range is equal to `p.row`, and: <br/>
		     * `p.column` is less than or equal to the calling range's ending column, this returns `0` <br/>
		     * Otherwise, it returns 1
		     **/
		    this.compare = function(row, column) {
		        if (!this.isMultiLine()) {
		            if (row === this.start.row) {
		                return column < this.start.column ? -1 : (column > this.end.column ? 1 : 0);
		            }
		        }
		
		        if (row < this.start.row)
		            return -1;
		
		        if (row > this.end.row)
		            return 1;
		
		        if (this.start.row === row)
		            return column >= this.start.column ? 0 : -1;
		
		        if (this.end.row === row)
		            return column <= this.end.column ? 0 : 1;
		
		        return 0;
		    };
		
		    /**
		     * Checks the row and column points with the row and column points of the calling range.
		     * @param {Number} row A row point to compare with
		     * @param {Number} column A column point to compare with
		     *
		     * @returns {Number} This method returns one of the following numbers:<br/>
		     * <br/>
		     * `0` if the two points are exactly equal<br/>
		     * `-1` if `p.row` is less then the calling range<br/>
		     * `1` if `p.row` is greater than the calling range, or if `isStart` is `true`.<br/>
		     * <br/>
		     * If the starting row of the calling range is equal to `p.row`, and:<br/>
		     * `p.column` is greater than or equal to the calling range's starting column, this returns `0`<br/>
		     * Otherwise, it returns -1<br/>
		     * <br/>
		     * If the ending row of the calling range is equal to `p.row`, and:<br/>
		     * `p.column` is less than or equal to the calling range's ending column, this returns `0`<br/>
		     * Otherwise, it returns 1
		     *
		     **/
		    this.compareStart = function(row, column) {
		        if (this.start.row == row && this.start.column == column) {
		            return -1;
		        } else {
		            return this.compare(row, column);
		        }
		    };
		
		    /**
		     * Checks the row and column points with the row and column points of the calling range.
		     * @param {Number} row A row point to compare with
		     * @param {Number} column A column point to compare with
		     *
		     *
		     * @returns {Number} This method returns one of the following numbers:<br/>
		     * `0` if the two points are exactly equal<br/>
		     * `-1` if `p.row` is less then the calling range<br/>
		     * `1` if `p.row` is greater than the calling range, or if `isEnd` is `true.<br/>
		     * <br/>
		     * If the starting row of the calling range is equal to `p.row`, and:<br/>
		     * `p.column` is greater than or equal to the calling range's starting column, this returns `0`<br/>
		     * Otherwise, it returns -1<br/>
		     *<br/>
		     * If the ending row of the calling range is equal to `p.row`, and:<br/>
		     * `p.column` is less than or equal to the calling range's ending column, this returns `0`<br/>
		     * Otherwise, it returns 1
		     */
		    this.compareEnd = function(row, column) {
		        if (this.end.row == row && this.end.column == column) {
		            return 1;
		        } else {
		            return this.compare(row, column);
		        }
		    };
		
		    /**
		     * Checks the row and column points with the row and column points of the calling range.
		     * @param {Number} row A row point to compare with
		     * @param {Number} column A column point to compare with
		     *
		     *
		     * @returns {Number} This method returns one of the following numbers:<br/>
		     * * `1` if the ending row of the calling range is equal to `row`, and the ending column of the calling range is equal to `column`<br/>
		     * * `-1` if the starting row of the calling range is equal to `row`, and the starting column of the calling range is equal to `column`<br/>
		     * <br/>
		     * Otherwise, it returns the value after calling [[Range.compare `compare()`]].
		     *
		     **/
		    this.compareInside = function(row, column) {
		        if (this.end.row == row && this.end.column == column) {
		            return 1;
		        } else if (this.start.row == row && this.start.column == column) {
		            return -1;
		        } else {
		            return this.compare(row, column);
		        }
		    };
		
		    /**
		     * Returns the part of the current `Range` that occurs within the boundaries of `firstRow` and `lastRow` as a new `Range` object.
		     * @param {Number} firstRow The starting row
		     * @param {Number} lastRow The ending row
		     *
		     *
		     * @returns {Range}
		    **/
		    this.clipRows = function(firstRow, lastRow) {
		        if (this.end.row > lastRow)
		            var end = {row: lastRow + 1, column: 0};
		        else if (this.end.row < firstRow)
		            var end = {row: firstRow, column: 0};
		
		        if (this.start.row > lastRow)
		            var start = {row: lastRow + 1, column: 0};
		        else if (this.start.row < firstRow)
		            var start = {row: firstRow, column: 0};
		
		        return Range.fromPoints(start || this.start, end || this.end);
		    };
		
		    /**
		     * Changes the row and column points for the calling range for both the starting and ending points.
		     * @param {Number} row A new row to extend to
		     * @param {Number} column A new column to extend to
		     *
		     *
		     * @returns {Range} The original range with the new row
		    **/
		    this.extend = function(row, column) {
		        var cmp = this.compare(row, column);
		
		        if (cmp == 0)
		            return this;
		        else if (cmp == -1)
		            var start = {row: row, column: column};
		        else
		            var end = {row: row, column: column};
		
		        return Range.fromPoints(start || this.start, end || this.end);
		    };
		
		    this.isEmpty = function() {
		        return (this.start.row === this.end.row && this.start.column === this.end.column);
		    };
		
		    /**
		     *
		     * Returns `true` if the range spans across multiple lines.
		     * @returns {Boolean}
		    **/
		    this.isMultiLine = function() {
		        return (this.start.row !== this.end.row);
		    };
		
		    /**
		     *
		     * Returns a duplicate of the calling range.
		     * @returns {Range}
		    **/
		    this.clone = function() {
		        return Range.fromPoints(this.start, this.end);
		    };
		
		    /**
		     *
		     * Returns a range containing the starting and ending rows of the original range, but with a column value of `0`.
		     * @returns {Range}
		    **/
		    this.collapseRows = function() {
		        if (this.end.column == 0)
		            return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row-1), 0)
		        else
		            return new Range(this.start.row, 0, this.end.row, 0)
		    };
		
		    /**
		     * Given the current `Range`, this function converts those starting and ending points into screen positions, and then returns a new `Range` object.
		     * @param {EditSession} session The `EditSession` to retrieve coordinates from
		     *
		     *
		     * @returns {Range}
		    **/
		    this.toScreenRange = function(session) {
		        var screenPosStart = session.documentToScreenPosition(this.start);
		        var screenPosEnd = session.documentToScreenPosition(this.end);
		
		        return new Range(
		            screenPosStart.row, screenPosStart.column,
		            screenPosEnd.row, screenPosEnd.column
		        );
		    };
		    
		    
		    /* experimental */
		    this.moveBy = function(row, column) {
		        this.start.row += row;
		        this.start.column += column;
		        this.end.row += row;
		        this.end.column += column;
		    };
		
		}).call(Range.prototype);
		
		/**
		 * Creates and returns a new `Range` based on the row and column of the given parameters.
		 * @param {Range} start A starting point to use
		 * @param {Range} end An ending point to use
		 *
		 * @returns {Range}
		**/
		Range.fromPoints = function(start, end) {
		    return new Range(start.row, start.column, end.row, end.column);
		};
		Range.comparePoints = comparePoints;
		
		Range.comparePoints = function(p1, p2) {
		    return p1.row - p2.row || p1.column - p2.column;
		};
		
		
		exports.Range = Range;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/range_list.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var Range = require("./range").Range;
		var comparePoints = Range.comparePoints;
		
		var RangeList = function() {
		    this.ranges = [];
		};
		
		(function() {
		    this.comparePoints = comparePoints;
		
		    this.pointIndex = function(pos, excludeEdges, startIndex) {
		        var list = this.ranges;
		
		        for (var i = startIndex || 0; i < list.length; i++) {
		            var range = list[i];
		            var cmpEnd = comparePoints(pos, range.end);
		            if (cmpEnd > 0)
		                continue;
		            var cmpStart = comparePoints(pos, range.start);
		            if (cmpEnd === 0)
		                return excludeEdges && cmpStart !== 0 ? -i-2 : i;
		            if (cmpStart > 0 || (cmpStart === 0 && !excludeEdges))
		                return i;
		
		            return -i-1;
		        }
		        return -i - 1;
		    };
		
		    this.add = function(range) {
		        var excludeEdges = !range.isEmpty();
		        var startIndex = this.pointIndex(range.start, excludeEdges);
		        if (startIndex < 0)
		            startIndex = -startIndex - 1;
		
		        var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);
		
		        if (endIndex < 0)
		            endIndex = -endIndex - 1;
		        else
		            endIndex++;
		        return this.ranges.splice(startIndex, endIndex - startIndex, range);
		    };
		
		    this.addList = function(list) {
		        var removed = [];
		        for (var i = list.length; i--; ) {
		            removed.push.apply(removed, this.add(list[i]));
		        }
		        return removed;
		    };
		
		    this.substractPoint = function(pos) {
		        var i = this.pointIndex(pos);
		
		        if (i >= 0)
		            return this.ranges.splice(i, 1);
		    };
		
		    // merge overlapping ranges
		    this.merge = function() {
		        var removed = [];
		        var list = this.ranges;
		        
		        list = list.sort(function(a, b) {
		            return comparePoints(a.start, b.start);
		        });
		        
		        var next = list[0], range;
		        for (var i = 1; i < list.length; i++) {
		            range = next;
		            next = list[i];
		            var cmp = comparePoints(range.end, next.start);
		            if (cmp < 0)
		                continue;
		
		            if (cmp == 0 && !range.isEmpty() && !next.isEmpty())
		                continue;
		
		            if (comparePoints(range.end, next.end) < 0) {
		                range.end.row = next.end.row;
		                range.end.column = next.end.column;
		            }
		
		            list.splice(i, 1);
		            removed.push(next);
		            next = range;
		            i--;
		        }
		        
		        this.ranges = list;
		
		        return removed;
		    };
		
		    this.contains = function(row, column) {
		        return this.pointIndex({row: row, column: column}) >= 0;
		    };
		
		    this.containsPoint = function(pos) {
		        return this.pointIndex(pos) >= 0;
		    };
		
		    this.rangeAtPoint = function(pos) {
		        var i = this.pointIndex(pos);
		        if (i >= 0)
		            return this.ranges[i];
		    };
		
		
		    this.clipRows = function(startRow, endRow) {
		        var list = this.ranges;
		        if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow)
		            return [];
		
		        var startIndex = this.pointIndex({row: startRow, column: 0});
		        if (startIndex < 0)
		            startIndex = -startIndex - 1;
		        var endIndex = this.pointIndex({row: endRow, column: 0}, startIndex);
		        if (endIndex < 0)
		            endIndex = -endIndex - 1;
		
		        var clipped = [];
		        for (var i = startIndex; i < endIndex; i++) {
		            clipped.push(list[i]);
		        }
		        return clipped;
		    };
		
		    this.removeAll = function() {
		        return this.ranges.splice(0, this.ranges.length);
		    };
		
		    this.attach = function(session) {
		        if (this.session)
		            this.detach();
		
		        this.session = session;
		        this.onChange = this.$onChange.bind(this);
		
		        this.session.on('change', this.onChange);
		    };
		
		    this.detach = function() {
		        if (!this.session)
		            return;
		        this.session.removeListener('change', this.onChange);
		        this.session = null;
		    };
		
		    this.$onChange = function(delta) {
		        if (delta.action == "insert"){
		            var start = delta.start;
		            var end = delta.end;
		        } else {
		            var end = delta.start;
		            var start = delta.end;
		        }
		        var startRow = start.row;
		        var endRow = end.row;
		        var lineDif = endRow - startRow;
		
		        var colDiff = -start.column + end.column;
		        var ranges = this.ranges;
		
		        for (var i = 0, n = ranges.length; i < n; i++) {
		            var r = ranges[i];
		            if (r.end.row < startRow)
		                continue;
		            if (r.start.row > startRow)
		                break;
		
		            if (r.start.row == startRow && r.start.column >= start.column ) {
		                if (r.start.column == start.column && this.$insertRight) {
		                    // do nothing
		                } else {
		                    r.start.column += colDiff;
		                    r.start.row += lineDif;
		                }
		            }
		            if (r.end.row == startRow && r.end.column >= start.column) {
		                if (r.end.column == start.column && this.$insertRight) {
		                    continue;
		                }
		                // special handling for the case when two ranges share an edge
		                if (r.end.column == start.column && colDiff > 0 && i < n - 1) {                
		                    if (r.end.column > r.start.column && r.end.column == ranges[i+1].start.column)
		                        r.end.column -= colDiff;
		                }
		                r.end.column += colDiff;
		                r.end.row += lineDif;
		            }
		        }
		
		        if (lineDif != 0 && i < n) {
		            for (; i < n; i++) {
		                var r = ranges[i];
		                r.start.row += lineDif;
		                r.end.row += lineDif;
		            }
		        }
		    };
		
		}).call(RangeList.prototype);
		
		exports.RangeList = RangeList;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/renderloop.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var event = require("./lib/event");
		
		/** 
		 *
		 *
		 * Batches changes (that force something to be redrawn) in the background.
		 * @class RenderLoop
		 **/
		
		
		var RenderLoop = function(onRender, win) {
		    this.onRender = onRender;
		    this.pending = false;
		    this.changes = 0;
		    this.window = win || window;
		};
		
		(function() {
		
		
		    this.schedule = function(change) {
		        //this.onRender(change);
		        //return;
		        this.changes = this.changes | change;
		        if (!this.pending && this.changes) {
		            this.pending = true;
		            var _self = this;
		            event.nextFrame(function() {
		                _self.pending = false;
		                var changes;
		                while (changes = _self.changes) {
		                    _self.changes = 0;
		                    _self.onRender(changes);
		                }
		            }, this.window);
		        }
		    };
		
		}).call(RenderLoop.prototype);
		
		exports.RenderLoop = RenderLoop;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/scrollbar.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var oop = require("./lib/oop");
		var dom = require("./lib/dom");
		var event = require("./lib/event");
		var EventEmitter = require("./lib/event_emitter").EventEmitter;
		var MAX_SCROLL_H = 0x8000;
		
		/**
		 * An abstract class representing a native scrollbar control.
		 * @class ScrollBar
		 **/
		
		/**
		 * Creates a new `ScrollBar`. `parent` is the owner of the scroll bar.
		 * @param {DOMElement} parent A DOM element 
		 *
		 * @constructor
		 **/
		var ScrollBar = function(parent) {
		    this.element = dom.createElement("div");
		    this.element.className = "ace_scrollbar ace_scrollbar" + this.classSuffix;
		
		    this.inner = dom.createElement("div");
		    this.inner.className = "ace_scrollbar-inner";
		    this.element.appendChild(this.inner);
		
		    parent.appendChild(this.element);
		
		    this.setVisible(false);
		    this.skipEvent = false;
		
		    event.addListener(this.element, "scroll", this.onScroll.bind(this));
		    event.addListener(this.element, "mousedown", event.preventDefault);
		};
		
		(function() {
		    oop.implement(this, EventEmitter);
		
		    this.setVisible = function(isVisible) {
		        this.element.style.display = isVisible ? "" : "none";
		        this.isVisible = isVisible;
		        this.coeff = 1;
		    };
		}).call(ScrollBar.prototype);
		
		/**
		 * Represents a vertical scroll bar.
		 * @class VScrollBar
		 **/
		
		/**
		 * Creates a new `VScrollBar`. `parent` is the owner of the scroll bar.
		 * @param {DOMElement} parent A DOM element
		 * @param {Object} renderer An editor renderer
		 *
		 * @constructor
		 **/
		var VScrollBar = function(parent, renderer) {
		    ScrollBar.call(this, parent);
		    this.scrollTop = 0;
		
		    // in OSX lion the scrollbars appear to have no width. In this case resize the
		    // element to show the scrollbar but still pretend that the scrollbar has a width
		    // of 0px
		    // in Firefox 6+ scrollbar is hidden if element has the same width as scrollbar
		    // make element a little bit wider to retain scrollbar when page is zoomed 
		    renderer.$scrollbarWidth = 
		    this.width = dom.scrollbarWidth(parent.ownerDocument);
		    this.inner.style.width =
		    this.element.style.width = (this.width || 15) + 5 + "px";
		};
		
		oop.inherits(VScrollBar, ScrollBar);
		
		(function() {
		
		    this.classSuffix = '-v';
		
		    /**
		     * Emitted when the scroll bar, well, scrolls.
		     * @event scroll
		     * @param {Object} e Contains one property, `"data"`, which indicates the current scroll top position
		     **/
		    this.onScroll = function() {
		        if (!this.skipEvent) {
		            this.scrollTop = this.element.scrollTop / this.coeff;
		            this._emit("scroll", {data: this.scrollTop});
		        }
		        this.skipEvent = false;
		    };
		
		    /**
		     * Returns the width of the scroll bar.
		     * @returns {Number}
		     **/
		    this.getWidth = function() {
		        return this.isVisible ? this.width : 0;
		    };
		
		    /**
		     * Sets the height of the scroll bar, in pixels.
		     * @param {Number} height The new height
		     **/
		    this.setHeight = function(height) {
		        this.element.style.height = height + "px";
		    };
		
		    /**
		     * Sets the inner height of the scroll bar, in pixels.
		     * @param {Number} height The new inner height
		     * @deprecated Use setScrollHeight instead
		     **/
		    this.setInnerHeight = 
		    /**
		     * Sets the scroll height of the scroll bar, in pixels.
		     * @param {Number} height The new scroll height
		     **/
		    this.setScrollHeight = function(height) {
		        if (height > MAX_SCROLL_H) {
		            this.coeff = MAX_SCROLL_H / height;
		            height = MAX_SCROLL_H;
		        } else if (this.coeff != 1) {
		            this.coeff = 1
		        }
		        this.inner.style.height = height + "px";
		    };
		
		    /**
		     * Sets the scroll top of the scroll bar.
		     * @param {Number} scrollTop The new scroll top
		     **/
		    this.setScrollTop = function(scrollTop) {
		        // on chrome 17+ for small zoom levels after calling this function
		        // this.element.scrollTop != scrollTop which makes page to scroll up.
		        if (this.scrollTop != scrollTop) {
		            this.skipEvent = true;
		            this.scrollTop = scrollTop;
		            this.element.scrollTop = scrollTop * this.coeff;
		        }
		    };
		
		}).call(VScrollBar.prototype);
		
		/**
		 * Represents a horisontal scroll bar.
		 * @class HScrollBar
		 **/
		
		/**
		 * Creates a new `HScrollBar`. `parent` is the owner of the scroll bar.
		 * @param {DOMElement} parent A DOM element
		 * @param {Object} renderer An editor renderer
		 *
		 * @constructor
		 **/
		var HScrollBar = function(parent, renderer) {
		    ScrollBar.call(this, parent);
		    this.scrollLeft = 0;
		
		    // in OSX lion the scrollbars appear to have no width. In this case resize the
		    // element to show the scrollbar but still pretend that the scrollbar has a width
		    // of 0px
		    // in Firefox 6+ scrollbar is hidden if element has the same width as scrollbar
		    // make element a little bit wider to retain scrollbar when page is zoomed 
		    this.height = renderer.$scrollbarWidth;
		    this.inner.style.height =
		    this.element.style.height = (this.height || 15) + 5 + "px";
		};
		
		oop.inherits(HScrollBar, ScrollBar);
		
		(function() {
		
		    this.classSuffix = '-h';
		
		    /**
		     * Emitted when the scroll bar, well, scrolls.
		     * @event scroll
		     * @param {Object} e Contains one property, `"data"`, which indicates the current scroll left position
		     **/
		    this.onScroll = function() {
		        if (!this.skipEvent) {
		            this.scrollLeft = this.element.scrollLeft;
		            this._emit("scroll", {data: this.scrollLeft});
		        }
		        this.skipEvent = false;
		    };
		
		    /**
		     * Returns the height of the scroll bar.
		     * @returns {Number}
		     **/
		    this.getHeight = function() {
		        return this.isVisible ? this.height : 0;
		    };
		
		    /**
		     * Sets the width of the scroll bar, in pixels.
		     * @param {Number} width The new width
		     **/
		    this.setWidth = function(width) {
		        this.element.style.width = width + "px";
		    };
		
		    /**
		     * Sets the inner width of the scroll bar, in pixels.
		     * @param {Number} width The new inner width
		     * @deprecated Use setScrollWidth instead
		     **/
		    this.setInnerWidth = function(width) {
		        this.inner.style.width = width + "px";
		    };
		
		    /**
		     * Sets the scroll width of the scroll bar, in pixels.
		     * @param {Number} width The new scroll width
		     **/
		    this.setScrollWidth = function(width) {
		        this.inner.style.width = width + "px";
		    };
		
		    /**
		     * Sets the scroll left of the scroll bar.
		     * @param {Number} scrollTop The new scroll left
		     **/
		    this.setScrollLeft = function(scrollLeft) {
		        // on chrome 17+ for small zoom levels after calling this function
		        // this.element.scrollTop != scrollTop which makes page to scroll up.
		        if (this.scrollLeft != scrollLeft) {
		            this.skipEvent = true;
		            this.scrollLeft = this.element.scrollLeft = scrollLeft;
		        }
		    };
		
		}).call(HScrollBar.prototype);
		
		
		exports.ScrollBar = VScrollBar; // backward compatibility
		exports.ScrollBarV = VScrollBar; // backward compatibility
		exports.ScrollBarH = HScrollBar; // backward compatibility
		
		exports.VScrollBar = VScrollBar;
		exports.HScrollBar = HScrollBar;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/search.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var lang = require("./lib/lang");
		var oop = require("./lib/oop");
		var Range = require("./range").Range;
		
		/**
		 * @class Search
		 *
		 * A class designed to handle all sorts of text searches within a [[Document `Document`]].
		 *
		 **/
		
		/**
		 * 
		 *
		 * Creates a new `Search` object. The following search options are avaliable:
		 *
		 * - `needle`: The string or regular expression you're looking for
		 * - `backwards`: Whether to search backwards from where cursor currently is. Defaults to `false`.
		 * - `wrap`: Whether to wrap the search back to the beginning when it hits the end. Defaults to `false`.
		 * - `caseSensitive`: Whether the search ought to be case-sensitive. Defaults to `false`.
		 * - `wholeWord`: Whether the search matches only on whole words. Defaults to `false`.
		 * - `range`: The [[Range]] to search within. Set this to `null` for the whole document
		 * - `regExp`: Whether the search is a regular expression or not. Defaults to `false`.
		 * - `start`: The starting [[Range]] or cursor position to begin the search
		 * - `skipCurrent`: Whether or not to include the current line in the search. Default to `false`.
		 * 
		 * @constructor
		 **/
		
		var Search = function() {
		    this.$options = {};
		};
		
		(function() {
		    /**
		     * Sets the search options via the `options` parameter.
		     * @param {Object} options An object containing all the new search properties
		     *
		     * 
		     * @returns {Search}
		     * @chainable
		    **/
		    this.set = function(options) {
		        oop.mixin(this.$options, options);
		        return this;
		    };
		
		    /**
		     * [Returns an object containing all the search options.]{: #Search.getOptions}
		     * @returns {Object}
		    **/
		    this.getOptions = function() {
		        return lang.copyObject(this.$options);
		    };
		    
		    /**
		     * Sets the search options via the `options` parameter.
		     * @param {Object} An object containing all the search propertie
		     * @related Search.set
		    **/
		    this.setOptions = function(options) {
		        this.$options = options;
		    };
		    /**
		     * Searches for `options.needle`. If found, this method returns the [[Range `Range`]] where the text first occurs. If `options.backwards` is `true`, the search goes backwards in the session.
		     * @param {EditSession} session The session to search with
		     *
		     * 
		     * @returns {Range}
		    **/
		    this.find = function(session) {
		        var options = this.$options;
		        var iterator = this.$matchIterator(session, options);
		        if (!iterator)
		            return false;
		
		        var firstRange = null;
		        iterator.forEach(function(range, row, offset) {
		            if (!range.start) {
		                var column = range.offset + (offset || 0);
		                firstRange = new Range(row, column, row, column + range.length);
		                if (!range.length && options.start && options.start.start
		                    && options.skipCurrent != false && firstRange.isEqual(options.start)
		                ) {
		                    firstRange = null;
		                    return false;
		                }
		            } else
		                firstRange = range;
		            return true;
		        });
		
		        return firstRange;
		    };
		
		    /**
		     * Searches for all occurances `options.needle`. If found, this method returns an array of [[Range `Range`s]] where the text first occurs. If `options.backwards` is `true`, the search goes backwards in the session.
		     * @param {EditSession} session The session to search with
		     *
		     * 
		     * @returns {[Range]}
		    **/
		    this.findAll = function(session) {
		        var options = this.$options;
		        if (!options.needle)
		            return [];
		        this.$assembleRegExp(options);
		
		        var range = options.range;
		        var lines = range
		            ? session.getLines(range.start.row, range.end.row)
		            : session.doc.getAllLines();
		
		        var ranges = [];
		        var re = options.re;
		        if (options.$isMultiLine) {
		            var len = re.length;
		            var maxRow = lines.length - len;
		            var prevRange;
		            outer: for (var row = re.offset || 0; row <= maxRow; row++) {
		                for (var j = 0; j < len; j++)
		                    if (lines[row + j].search(re[j]) == -1)
		                        continue outer;
		                
		                var startLine = lines[row];
		                var line = lines[row + len - 1];
		                var startIndex = startLine.length - startLine.match(re[0])[0].length;
		                var endIndex = line.match(re[len - 1])[0].length;
		                
		                if (prevRange && prevRange.end.row === row &&
		                    prevRange.end.column > startIndex
		                ) {
		                    continue;
		                }
		                ranges.push(prevRange = new Range(
		                    row, startIndex, row + len - 1, endIndex
		                ));
		                if (len > 2)
		                    row = row + len - 2;
		            }
		        } else {
		            for (var i = 0; i < lines.length; i++) {
		                var matches = lang.getMatchOffsets(lines[i], re);
		                for (var j = 0; j < matches.length; j++) {
		                    var match = matches[j];
		                    ranges.push(new Range(i, match.offset, i, match.offset + match.length));
		                }
		            }
		        }
		
		        if (range) {
		            var startColumn = range.start.column;
		            var endColumn = range.start.column;
		            var i = 0, j = ranges.length - 1;
		            while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == range.start.row)
		                i++;
		
		            while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == range.end.row)
		                j--;
		            
		            ranges = ranges.slice(i, j + 1);
		            for (i = 0, j = ranges.length; i < j; i++) {
		                ranges[i].start.row += range.start.row;
		                ranges[i].end.row += range.start.row;
		            }
		        }
		
		        return ranges;
		    };
		
		    /**
		     * Searches for `options.needle` in `input`, and, if found, replaces it with `replacement`.
		     * @param {String} input The text to search in
		     * @param {String} replacement The replacing text
		     * + (String): If `options.regExp` is `true`, this function returns `input` with the replacement already made. Otherwise, this function just returns `replacement`.<br/>
		     * If `options.needle` was not found, this function returns `null`.
		     *
		     * 
		     * @returns {String}
		    **/
		    this.replace = function(input, replacement) {
		        var options = this.$options;
		
		        var re = this.$assembleRegExp(options);
		        if (options.$isMultiLine)
		            return replacement;
		
		        if (!re)
		            return;
		
		        var match = re.exec(input);
		        if (!match || match[0].length != input.length)
		            return null;
		        
		        replacement = input.replace(re, replacement);
		        if (options.preserveCase) {
		            replacement = replacement.split("");
		            for (var i = Math.min(input.length, input.length); i--; ) {
		                var ch = input[i];
		                if (ch && ch.toLowerCase() != ch)
		                    replacement[i] = replacement[i].toUpperCase();
		                else
		                    replacement[i] = replacement[i].toLowerCase();
		            }
		            replacement = replacement.join("");
		        }
		        
		        return replacement;
		    };
		
		    this.$matchIterator = function(session, options) {
		        var re = this.$assembleRegExp(options);
		        if (!re)
		            return false;
		
		        var callback;
		        if (options.$isMultiLine) {
		            var len = re.length;
		            var matchIterator = function(line, row, offset) {
		                var startIndex = line.search(re[0]);
		                if (startIndex == -1)
		                    return;
		                for (var i = 1; i < len; i++) {
		                    line = session.getLine(row + i);
		                    if (line.search(re[i]) == -1)
		                        return;
		                }
		
		                var endIndex = line.match(re[len - 1])[0].length;
		
		                var range = new Range(row, startIndex, row + len - 1, endIndex);
		                if (re.offset == 1) {
		                    range.start.row--;
		                    range.start.column = Number.MAX_VALUE;
		                } else if (offset)
		                    range.start.column += offset;
		
		                if (callback(range))
		                    return true;
		            };
		        } else if (options.backwards) {
		            var matchIterator = function(line, row, startIndex) {
		                var matches = lang.getMatchOffsets(line, re);
		                for (var i = matches.length-1; i >= 0; i--)
		                    if (callback(matches[i], row, startIndex))
		                        return true;
		            };
		        } else {
		            var matchIterator = function(line, row, startIndex) {
		                var matches = lang.getMatchOffsets(line, re);
		                for (var i = 0; i < matches.length; i++)
		                    if (callback(matches[i], row, startIndex))
		                        return true;
		            };
		        }
		        
		        var lineIterator = this.$lineIterator(session, options);
		
		        return {
		            forEach: function(_callback) {
		                callback = _callback;
		                lineIterator.forEach(matchIterator);
		            }
		        };
		    };
		
		    this.$assembleRegExp = function(options, $disableFakeMultiline) {
		        if (options.needle instanceof RegExp)
		            return options.re = options.needle;
		
		        var needle = options.needle;
		
		        if (!options.needle)
		            return options.re = false;
		
		        if (!options.regExp)
		            needle = lang.escapeRegExp(needle);
		
		        if (options.wholeWord)
		            needle = "\\b" + needle + "\\b";
		
		        var modifier = options.caseSensitive ? "gm" : "gmi";
		
		        options.$isMultiLine = !$disableFakeMultiline && /[\n\r]/.test(needle);
		        if (options.$isMultiLine)
		            return options.re = this.$assembleMultilineRegExp(needle, modifier);
		
		        try {
		            var re = new RegExp(needle, modifier);
		        } catch(e) {
		            re = false;
		        }
		        return options.re = re;
		    };
		
		    this.$assembleMultilineRegExp = function(needle, modifier) {
		        var parts = needle.replace(/\r\n|\r|\n/g, "$\n^").split("\n");
		        var re = [];
		        for (var i = 0; i < parts.length; i++) try {
		            re.push(new RegExp(parts[i], modifier));
		        } catch(e) {
		            return false;
		        }
		        if (parts[0] == "") {
		            re.shift();
		            re.offset = 1;
		        } else {
		            re.offset = 0;
		        }
		        return re;
		    };
		
		    this.$lineIterator = function(session, options) {
		        var backwards = options.backwards == true;
		        var skipCurrent = options.skipCurrent != false;
		
		        var range = options.range;
		        var start = options.start;
		        if (!start)
		            start = range ? range[backwards ? "end" : "start"] : session.selection.getRange();
		         
		        if (start.start)
		            start = start[skipCurrent != backwards ? "end" : "start"];
		
		        var firstRow = range ? range.start.row : 0;
		        var lastRow = range ? range.end.row : session.getLength() - 1;
		
		        var forEach = backwards ? function(callback) {
		                var row = start.row;
		
		                var line = session.getLine(row).substring(0, start.column);
		                if (callback(line, row))
		                    return;
		
		                for (row--; row >= firstRow; row--)
		                    if (callback(session.getLine(row), row))
		                        return;
		
		                if (options.wrap == false)
		                    return;
		
		                for (row = lastRow, firstRow = start.row; row >= firstRow; row--)
		                    if (callback(session.getLine(row), row))
		                        return;
		            } : function(callback) {
		                var row = start.row;
		
		                var line = session.getLine(row).substr(start.column);
		                if (callback(line, row, start.column))
		                    return;
		
		                for (row = row+1; row <= lastRow; row++)
		                    if (callback(session.getLine(row), row))
		                        return;
		
		                if (options.wrap == false)
		                    return;
		
		                for (row = firstRow, lastRow = start.row; row <= lastRow; row++)
		                    if (callback(session.getLine(row), row))
		                        return;
		            };
		        
		        return {forEach: forEach};
		    };
		
		}).call(Search.prototype);
		
		exports.Search = Search;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/search_highlight.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var lang = require("./lib/lang");
		var oop = require("./lib/oop");
		var Range = require("./range").Range;
		
		var SearchHighlight = function(regExp, clazz, type) {
		    this.setRegexp(regExp);
		    this.clazz = clazz;
		    this.type = type || "text";
		};
		
		(function() {
		    // needed to prevent long lines from freezing the browser
		    this.MAX_RANGES = 500;
		    
		    this.setRegexp = function(regExp) {
		        if (this.regExp+"" == regExp+"")
		            return;
		        this.regExp = regExp;
		        this.cache = [];
		    };
		
		    this.update = function(html, markerLayer, session, config) {
		        if (!this.regExp)
		            return;
		        var start = config.firstRow, end = config.lastRow;
		
		        for (var i = start; i <= end; i++) {
		            var ranges = this.cache[i];
		            if (ranges == null) {
		                ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);
		                if (ranges.length > this.MAX_RANGES)
		                    ranges = ranges.slice(0, this.MAX_RANGES);
		                ranges = ranges.map(function(match) {
		                    return new Range(i, match.offset, i, match.offset + match.length);
		                });
		                this.cache[i] = ranges.length ? ranges : "";
		            }
		
		            for (var j = ranges.length; j --; ) {
		                markerLayer.drawSingleLineMarker(
		                    html, ranges[j].toScreenRange(session), this.clazz, config);
		            }
		        }
		    };
		
		}).call(SearchHighlight.prototype);
		
		exports.SearchHighlight = SearchHighlight;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/selection.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var oop = require("./lib/oop");
		var lang = require("./lib/lang");
		var EventEmitter = require("./lib/event_emitter").EventEmitter;
		var Range = require("./range").Range;
		
		/**
		 * Contains the cursor position and the text selection of an edit session.
		 *
		 * The row/columns used in the selection are in document coordinates representing the coordinates as they appear in the document before applying soft wrap and folding.
		 * @class Selection
		 **/
		
		
		/**
		 * Emitted when the cursor position changes.
		 * @event changeCursor
		 *
		**/
		/**
		 * Emitted when the cursor selection changes.
		 * 
		 *  @event changeSelection
		**/
		/**
		 * Creates a new `Selection` object.
		 * @param {EditSession} session The session to use
		 * 
		 * @constructor
		 **/
		var Selection = function(session) {
		    this.session = session;
		    this.doc = session.getDocument();
		
		    this.clearSelection();
		    this.lead = this.selectionLead = this.doc.createAnchor(0, 0);
		    this.anchor = this.selectionAnchor = this.doc.createAnchor(0, 0);
		
		    var self = this;
		    this.lead.on("change", function(e) {
		        self._emit("changeCursor");
		        if (!self.$isEmpty)
		            self._emit("changeSelection");
		        if (!self.$keepDesiredColumnOnChange && e.old.column != e.value.column)
		            self.$desiredColumn = null;
		    });
		
		    this.selectionAnchor.on("change", function() {
		        if (!self.$isEmpty)
		            self._emit("changeSelection");
		    });
		};
		
		(function() {
		
		    oop.implement(this, EventEmitter);
		
		    /**
		    *
		    * Returns `true` if the selection is empty.
		    * @returns {Boolean}
		    **/
		    this.isEmpty = function() {
		        return (this.$isEmpty || (
		            this.anchor.row == this.lead.row &&
		            this.anchor.column == this.lead.column
		        ));
		    };
		
		    /**
		    * Returns `true` if the selection is a multi-line.
		    * @returns {Boolean}
		    **/
		    this.isMultiLine = function() {
		        if (this.isEmpty()) {
		            return false;
		        }
		
		        return this.getRange().isMultiLine();
		    };
		
		    /**
		    * Returns an object containing the `row` and `column` current position of the cursor.
		    * @returns {Object}
		    **/
		    this.getCursor = function() {
		        return this.lead.getPosition();
		    };
		
		    /**
		    * Sets the row and column position of the anchor. This function also emits the `'changeSelection'` event.
		    * @param {Number} row The new row
		    * @param {Number} column The new column
		    *
		    *
		    **/
		    this.setSelectionAnchor = function(row, column) {
		        this.anchor.setPosition(row, column);
		
		        if (this.$isEmpty) {
		            this.$isEmpty = false;
		            this._emit("changeSelection");
		        }
		    };
		
		    /**
		    * Returns an object containing the `row` and `column` of the calling selection anchor.
		    *
		    * @returns {Object}
		    * @related Anchor.getPosition
		    **/
		    this.getSelectionAnchor = function() {
		        if (this.$isEmpty)
		            return this.getSelectionLead();
		        else
		            return this.anchor.getPosition();
		    };
		
		    /**
		    *
		    * Returns an object containing the `row` and `column` of the calling selection lead.
		    * @returns {Object}
		    **/
		    this.getSelectionLead = function() {
		        return this.lead.getPosition();
		    };
		
		    /**
		    * Shifts the selection up (or down, if [[Selection.isBackwards `isBackwards()`]] is true) the given number of columns.
		    * @param {Number} columns The number of columns to shift by
		    *
		    *
		    *
		    **/
		    this.shiftSelection = function(columns) {
		        if (this.$isEmpty) {
		            this.moveCursorTo(this.lead.row, this.lead.column + columns);
		            return;
		        }
		
		        var anchor = this.getSelectionAnchor();
		        var lead = this.getSelectionLead();
		
		        var isBackwards = this.isBackwards();
		
		        if (!isBackwards || anchor.column !== 0)
		            this.setSelectionAnchor(anchor.row, anchor.column + columns);
		
		        if (isBackwards || lead.column !== 0) {
		            this.$moveSelection(function() {
		                this.moveCursorTo(lead.row, lead.column + columns);
		            });
		        }
		    };
		
		    /**
		    * Returns `true` if the selection is going backwards in the document.
		    * @returns {Boolean}
		    **/
		    this.isBackwards = function() {
		        var anchor = this.anchor;
		        var lead = this.lead;
		        return (anchor.row > lead.row || (anchor.row == lead.row && anchor.column > lead.column));
		    };
		
		    /**
		    * [Returns the [[Range]] for the selected text.]{: #Selection.getRange}
		    * @returns {Range}
		    **/
		    this.getRange = function() {
		        var anchor = this.anchor;
		        var lead = this.lead;
		
		        if (this.isEmpty())
		            return Range.fromPoints(lead, lead);
		
		        if (this.isBackwards()) {
		            return Range.fromPoints(lead, anchor);
		        }
		        else {
		            return Range.fromPoints(anchor, lead);
		        }
		    };
		
		    /**
		    * [Empties the selection (by de-selecting it). This function also emits the `'changeSelection'` event.]{: #Selection.clearSelection}
		    **/
		    this.clearSelection = function() {
		        if (!this.$isEmpty) {
		            this.$isEmpty = true;
		            this._emit("changeSelection");
		        }
		    };
		
		    /**
		    * Selects all the text in the document.
		    **/
		    this.selectAll = function() {
		        var lastRow = this.doc.getLength() - 1;
		        this.setSelectionAnchor(0, 0);
		        this.moveCursorTo(lastRow, this.doc.getLine(lastRow).length);
		    };
		
		    /**
		    * Sets the selection to the provided range.
		    * @param {Range} range The range of text to select
		    * @param {Boolean} reverse Indicates if the range should go backwards (`true`) or not
		    *
		    *
		    * @method setSelectionRange
		    * @alias setRange
		    **/
		    this.setRange =
		    this.setSelectionRange = function(range, reverse) {
		        if (reverse) {
		            this.setSelectionAnchor(range.end.row, range.end.column);
		            this.selectTo(range.start.row, range.start.column);
		        } else {
		            this.setSelectionAnchor(range.start.row, range.start.column);
		            this.selectTo(range.end.row, range.end.column);
		        }
		        if (this.getRange().isEmpty())
		            this.$isEmpty = true;
		        this.$desiredColumn = null;
		    };
		
		    this.$moveSelection = function(mover) {
		        var lead = this.lead;
		        if (this.$isEmpty)
		            this.setSelectionAnchor(lead.row, lead.column);
		
		        mover.call(this);
		    };
		
		    /**
		    * Moves the selection cursor to the indicated row and column.
		    * @param {Number} row The row to select to
		    * @param {Number} column The column to select to
		    *
		    *
		    *
		    **/
		    this.selectTo = function(row, column) {
		        this.$moveSelection(function() {
		            this.moveCursorTo(row, column);
		        });
		    };
		
		    /**
		    * Moves the selection cursor to the row and column indicated by `pos`.
		    * @param {Object} pos An object containing the row and column
		    *
		    *
		    *
		    **/
		    this.selectToPosition = function(pos) {
		        this.$moveSelection(function() {
		            this.moveCursorToPosition(pos);
		        });
		    };
		
		    /**
		    * Moves the selection cursor to the indicated row and column.
		    * @param {Number} row The row to select to
		    * @param {Number} column The column to select to
		    *
		    **/
		    this.moveTo = function(row, column) {
		        this.clearSelection();
		        this.moveCursorTo(row, column);
		    };
		
		    /**
		    * Moves the selection cursor to the row and column indicated by `pos`.
		    * @param {Object} pos An object containing the row and column
		    **/
		    this.moveToPosition = function(pos) {
		        this.clearSelection();
		        this.moveCursorToPosition(pos);
		    };
		
		
		    /**
		    *
		    * Moves the selection up one row.
		    **/
		    this.selectUp = function() {
		        this.$moveSelection(this.moveCursorUp);
		    };
		
		    /**
		    *
		    * Moves the selection down one row.
		    **/
		    this.selectDown = function() {
		        this.$moveSelection(this.moveCursorDown);
		    };
		
		    /**
		    *
		    *
		    * Moves the selection right one column.
		    **/
		    this.selectRight = function() {
		        this.$moveSelection(this.moveCursorRight);
		    };
		
		    /**
		    *
		    * Moves the selection left one column.
		    **/
		    this.selectLeft = function() {
		        this.$moveSelection(this.moveCursorLeft);
		    };
		
		    /**
		    *
		    * Moves the selection to the beginning of the current line.
		    **/
		    this.selectLineStart = function() {
		        this.$moveSelection(this.moveCursorLineStart);
		    };
		
		    /**
		    *
		    * Moves the selection to the end of the current line.
		    **/
		    this.selectLineEnd = function() {
		        this.$moveSelection(this.moveCursorLineEnd);
		    };
		
		    /**
		    *
		    * Moves the selection to the end of the file.
		    **/
		    this.selectFileEnd = function() {
		        this.$moveSelection(this.moveCursorFileEnd);
		    };
		
		    /**
		    *
		    * Moves the selection to the start of the file.
		    **/
		    this.selectFileStart = function() {
		        this.$moveSelection(this.moveCursorFileStart);
		    };
		
		    /**
		    *
		    * Moves the selection to the first word on the right.
		    **/
		    this.selectWordRight = function() {
		        this.$moveSelection(this.moveCursorWordRight);
		    };
		
		    /**
		    *
		    * Moves the selection to the first word on the left.
		    **/
		    this.selectWordLeft = function() {
		        this.$moveSelection(this.moveCursorWordLeft);
		    };
		
		    /**
		    * Moves the selection to highlight the entire word.
		    * @related EditSession.getWordRange
		    **/
		    this.getWordRange = function(row, column) {
		        if (typeof column == "undefined") {
		            var cursor = row || this.lead;
		            row = cursor.row;
		            column = cursor.column;
		        }
		        return this.session.getWordRange(row, column);
		    };
		
		    /**
		    *
		    * Selects an entire word boundary.
		    **/
		    this.selectWord = function() {
		        this.setSelectionRange(this.getWordRange());
		    };
		
		    /**
		    * Selects a word, including its right whitespace.
		    * @related EditSession.getAWordRange
		    **/
		    this.selectAWord = function() {
		        var cursor = this.getCursor();
		        var range = this.session.getAWordRange(cursor.row, cursor.column);
		        this.setSelectionRange(range);
		    };
		
		    this.getLineRange = function(row, excludeLastChar) {
		        var rowStart = typeof row == "number" ? row : this.lead.row;
		        var rowEnd;
		
		        var foldLine = this.session.getFoldLine(rowStart);
		        if (foldLine) {
		            rowStart = foldLine.start.row;
		            rowEnd = foldLine.end.row;
		        } else {
		            rowEnd = rowStart;
		        }
		        if (excludeLastChar === true)
		            return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);
		        else
		            return new Range(rowStart, 0, rowEnd + 1, 0);
		    };
		
		    /**
		    * Selects the entire line.
		    **/
		    this.selectLine = function() {
		        this.setSelectionRange(this.getLineRange());
		    };
		
		    /**
		    *
		    * Moves the cursor up one row.
		    **/
		    this.moveCursorUp = function() {
		        this.moveCursorBy(-1, 0);
		    };
		
		    /**
		    *
		    * Moves the cursor down one row.
		    **/
		    this.moveCursorDown = function() {
		        this.moveCursorBy(1, 0);
		    };
		
		    /**
		    *
		    * Moves the cursor left one column.
		    **/
		    this.moveCursorLeft = function() {
		        var cursor = this.lead.getPosition(),
		            fold;
		
		        if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
		            this.moveCursorTo(fold.start.row, fold.start.column);
		        } else if (cursor.column === 0) {
		            // cursor is a line (start
		            if (cursor.row > 0) {
		                this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
		            }
		        }
		        else {
		            var tabSize = this.session.getTabSize();
		            if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column-tabSize, cursor.column).split(" ").length-1 == tabSize)
		                this.moveCursorBy(0, -tabSize);
		            else
		                this.moveCursorBy(0, -1);
		        }
		    };
		
		    /**
		    *
		    * Moves the cursor right one column.
		    **/
		    this.moveCursorRight = function() {
		        var cursor = this.lead.getPosition(),
		            fold;
		        if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {
		            this.moveCursorTo(fold.end.row, fold.end.column);
		        }
		        else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
		            if (this.lead.row < this.doc.getLength() - 1) {
		                this.moveCursorTo(this.lead.row + 1, 0);
		            }
		        }
		        else {
		            var tabSize = this.session.getTabSize();
		            var cursor = this.lead;
		            if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column, cursor.column+tabSize).split(" ").length-1 == tabSize)
		                this.moveCursorBy(0, tabSize);
		            else
		                this.moveCursorBy(0, 1);
		        }
		    };
		
		    /**
		    *
		    * Moves the cursor to the start of the line.
		    **/
		    this.moveCursorLineStart = function() {
		        var row = this.lead.row;
		        var column = this.lead.column;
		        var screenRow = this.session.documentToScreenRow(row, column);
		
		        // Determ the doc-position of the first character at the screen line.
		        var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);
		
		        // Determ the line
		        var beforeCursor = this.session.getDisplayLine(
		            row, null, firstColumnPosition.row,
		            firstColumnPosition.column
		        );
		
		        var leadingSpace = beforeCursor.match(/^\s*/);
		        // TODO find better way for emacs mode to override selection behaviors
		        if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart)
		            firstColumnPosition.column += leadingSpace[0].length;
		        this.moveCursorToPosition(firstColumnPosition);
		    };
		
		    /**
		    *
		    * Moves the cursor to the end of the line.
		    **/
		    this.moveCursorLineEnd = function() {
		        var lead = this.lead;
		        var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
		        if (this.lead.column == lineEnd.column) {
		            var line = this.session.getLine(lineEnd.row);
		            if (lineEnd.column == line.length) {
		                var textEnd = line.search(/\s+$/);
		                if (textEnd > 0)
		                    lineEnd.column = textEnd;
		            }
		        }
		
		        this.moveCursorTo(lineEnd.row, lineEnd.column);
		    };
		
		    /**
		    *
		    * Moves the cursor to the end of the file.
		    **/
		    this.moveCursorFileEnd = function() {
		        var row = this.doc.getLength() - 1;
		        var column = this.doc.getLine(row).length;
		        this.moveCursorTo(row, column);
		    };
		
		    /**
		    *
		    * Moves the cursor to the start of the file.
		    **/
		    this.moveCursorFileStart = function() {
		        this.moveCursorTo(0, 0);
		    };
		
		    /**
		    *
		    * Moves the cursor to the word on the right.
		    **/
		    this.moveCursorLongWordRight = function() {
		        var row = this.lead.row;
		        var column = this.lead.column;
		        var line = this.doc.getLine(row);
		        var rightOfCursor = line.substring(column);
		
		        var match;
		        this.session.nonTokenRe.lastIndex = 0;
		        this.session.tokenRe.lastIndex = 0;
		
		        // skip folds
		        var fold = this.session.getFoldAt(row, column, 1);
		        if (fold) {
		            this.moveCursorTo(fold.end.row, fold.end.column);
		            return;
		        }
		
		        // first skip space
		        if (match = this.session.nonTokenRe.exec(rightOfCursor)) {
		            column += this.session.nonTokenRe.lastIndex;
		            this.session.nonTokenRe.lastIndex = 0;
		            rightOfCursor = line.substring(column);
		        }
		
		        // if at line end proceed with next line
		        if (column >= line.length) {
		            this.moveCursorTo(row, line.length);
		            this.moveCursorRight();
		            if (row < this.doc.getLength() - 1)
		                this.moveCursorWordRight();
		            return;
		        }
		
		        // advance to the end of the next token
		        if (match = this.session.tokenRe.exec(rightOfCursor)) {
		            column += this.session.tokenRe.lastIndex;
		            this.session.tokenRe.lastIndex = 0;
		        }
		
		        this.moveCursorTo(row, column);
		    };
		
		    /**
		    *
		    * Moves the cursor to the word on the left.
		    **/
		    this.moveCursorLongWordLeft = function() {
		        var row = this.lead.row;
		        var column = this.lead.column;
		
		        // skip folds
		        var fold;
		        if (fold = this.session.getFoldAt(row, column, -1)) {
		            this.moveCursorTo(fold.start.row, fold.start.column);
		            return;
		        }
		
		        var str = this.session.getFoldStringAt(row, column, -1);
		        if (str == null) {
		            str = this.doc.getLine(row).substring(0, column);
		        }
		
		        var leftOfCursor = lang.stringReverse(str);
		        var match;
		        this.session.nonTokenRe.lastIndex = 0;
		        this.session.tokenRe.lastIndex = 0;
		
		        // skip whitespace
		        if (match = this.session.nonTokenRe.exec(leftOfCursor)) {
		            column -= this.session.nonTokenRe.lastIndex;
		            leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
		            this.session.nonTokenRe.lastIndex = 0;
		        }
		
		        // if at begin of the line proceed in line above
		        if (column <= 0) {
		            this.moveCursorTo(row, 0);
		            this.moveCursorLeft();
		            if (row > 0)
		                this.moveCursorWordLeft();
		            return;
		        }
		
		        // move to the begin of the word
		        if (match = this.session.tokenRe.exec(leftOfCursor)) {
		            column -= this.session.tokenRe.lastIndex;
		            this.session.tokenRe.lastIndex = 0;
		        }
		
		        this.moveCursorTo(row, column);
		    };
		
		    this.$shortWordEndIndex = function(rightOfCursor) {
		        var match, index = 0, ch;
		        var whitespaceRe = /\s/;
		        var tokenRe = this.session.tokenRe;
		
		        tokenRe.lastIndex = 0;
		        if (match = this.session.tokenRe.exec(rightOfCursor)) {
		            index = this.session.tokenRe.lastIndex;
		        } else {
		            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
		                index ++;
		
		            if (index < 1) {
		                tokenRe.lastIndex = 0;
		                 while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {
		                    tokenRe.lastIndex = 0;
		                    index ++;
		                    if (whitespaceRe.test(ch)) {
		                        if (index > 2) {
		                            index--;
		                            break;
		                        } else {
		                            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
		                                index ++;
		                            if (index > 2)
		                                break;
		                        }
		                    }
		                }
		            }
		        }
		        tokenRe.lastIndex = 0;
		
		        return index;
		    };
		
		    this.moveCursorShortWordRight = function() {
		        var row = this.lead.row;
		        var column = this.lead.column;
		        var line = this.doc.getLine(row);
		        var rightOfCursor = line.substring(column);
		
		        var fold = this.session.getFoldAt(row, column, 1);
		        if (fold)
		            return this.moveCursorTo(fold.end.row, fold.end.column);
		
		        if (column == line.length) {
		            var l = this.doc.getLength();
		            do {
		                row++;
		                rightOfCursor = this.doc.getLine(row);
		            } while (row < l && /^\s*$/.test(rightOfCursor));
		
		            if (!/^\s+/.test(rightOfCursor))
		                rightOfCursor = "";
		            column = 0;
		        }
		
		        var index = this.$shortWordEndIndex(rightOfCursor);
		
		        this.moveCursorTo(row, column + index);
		    };
		
		    this.moveCursorShortWordLeft = function() {
		        var row = this.lead.row;
		        var column = this.lead.column;
		
		        var fold;
		        if (fold = this.session.getFoldAt(row, column, -1))
		            return this.moveCursorTo(fold.start.row, fold.start.column);
		
		        var line = this.session.getLine(row).substring(0, column);
		        if (column === 0) {
		            do {
		                row--;
		                line = this.doc.getLine(row);
		            } while (row > 0 && /^\s*$/.test(line));
		
		            column = line.length;
		            if (!/\s+$/.test(line))
		                line = "";
		        }
		
		        var leftOfCursor = lang.stringReverse(line);
		        var index = this.$shortWordEndIndex(leftOfCursor);
		
		        return this.moveCursorTo(row, column - index);
		    };
		
		    this.moveCursorWordRight = function() {
		        if (this.session.$selectLongWords)
		            this.moveCursorLongWordRight();
		        else
		            this.moveCursorShortWordRight();
		    };
		
		    this.moveCursorWordLeft = function() {
		        if (this.session.$selectLongWords)
		            this.moveCursorLongWordLeft();
		        else
		            this.moveCursorShortWordLeft();
		    };
		
		    /**
		    * Moves the cursor to position indicated by the parameters. Negative numbers move the cursor backwards in the document.
		    * @param {Number} rows The number of rows to move by
		    * @param {Number} chars The number of characters to move by
		    *
		    *
		    * @related EditSession.documentToScreenPosition
		    **/
		    this.moveCursorBy = function(rows, chars) {
		        var screenPos = this.session.documentToScreenPosition(
		            this.lead.row,
		            this.lead.column
		        );
		
		        if (chars === 0) {
		            if (this.$desiredColumn)
		                screenPos.column = this.$desiredColumn;
		            else
		                this.$desiredColumn = screenPos.column;
		        }
		
		        var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column);
		        
		        if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) {
		            if (this.session.lineWidgets && this.session.lineWidgets[docPos.row]) {
		                if (docPos.row > 0 || rows > 0)
		                    docPos.row++;
		            }
		        }
		
		        // move the cursor and update the desired column
		        this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
		    };
		
		    /**
		    * Moves the selection to the position indicated by its `row` and `column`.
		    * @param {Object} position The position to move to
		    *
		    *
		    **/
		    this.moveCursorToPosition = function(position) {
		        this.moveCursorTo(position.row, position.column);
		    };
		
		    /**
		     * Moves the cursor to the row and column provided. [If `preventUpdateDesiredColumn` is `true`, then the cursor stays in the same column position as its original point.]{: #preventUpdateBoolDesc}
		     * @param {Number} row The row to move to
		     * @param {Number} column The column to move to
		     * @param {Boolean} keepDesiredColumn [If `true`, the cursor move does not respect the previous column]{: #preventUpdateBool}
		     *
		     **/
		    this.moveCursorTo = function(row, column, keepDesiredColumn) {
		        // Ensure the row/column is not inside of a fold.
		        var fold = this.session.getFoldAt(row, column, 1);
		        if (fold) {
		            row = fold.start.row;
		            column = fold.start.column;
		        }
		
		        this.$keepDesiredColumnOnChange = true;
		        this.lead.setPosition(row, column);
		        this.$keepDesiredColumnOnChange = false;
		
		        if (!keepDesiredColumn)
		            this.$desiredColumn = null;
		    };
		
		    /**
		     * Moves the cursor to the screen position indicated by row and column. {:preventUpdateBoolDesc}
		     * @param {Number} row The row to move to
		     * @param {Number} column The column to move to
		     * @param {Boolean} keepDesiredColumn {:preventUpdateBool}
		     *
		     **/
		    this.moveCursorToScreen = function(row, column, keepDesiredColumn) {
		        var pos = this.session.screenToDocumentPosition(row, column);
		        this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
		    };
		
		    // remove listeners from document
		    this.detach = function() {
		        this.lead.detach();
		        this.anchor.detach();
		        this.session = this.doc = null;
		    };
		
		    this.fromOrientedRange = function(range) {
		        this.setSelectionRange(range, range.cursor == range.start);
		        this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
		    };
		
		    this.toOrientedRange = function(range) {
		        var r = this.getRange();
		        if (range) {
		            range.start.column = r.start.column;
		            range.start.row = r.start.row;
		            range.end.column = r.end.column;
		            range.end.row = r.end.row;
		        } else {
		            range = r;
		        }
		
		        range.cursor = this.isBackwards() ? range.start : range.end;
		        range.desiredColumn = this.$desiredColumn;
		        return range;
		    };
		
		    /**
		     * Saves the current cursor position and calls `func` that can change the cursor
		     * postion. The result is the range of the starting and eventual cursor position.
		     * Will reset the cursor position.
		     * @param {Function} The callback that should change the cursor position
		     * @returns {Range}
		     *
		     **/
		    this.getRangeOfMovements = function(func) {
		        var start = this.getCursor();
		        try {
		            func(this);
		            var end = this.getCursor();
		            return Range.fromPoints(start,end);
		        } catch(e) {
		            return Range.fromPoints(start,start);
		        } finally {
		            this.moveCursorToPosition(start);
		        }
		    };
		
		    this.toJSON = function() {
		        if (this.rangeCount) {
		            var data = this.ranges.map(function(r) {
		                var r1 = r.clone();
		                r1.isBackwards = r.cursor == r.start;
		                return r1;
		            });
		        } else {
		            var data = this.getRange();
		            data.isBackwards = this.isBackwards();
		        }
		        return data;
		    };
		
		    this.fromJSON = function(data) {
		        if (data.start == undefined) {
		            if (this.rangeList) {
		                this.toSingleRange(data[0]);
		                for (var i = data.length; i--; ) {
		                    var r = Range.fromPoints(data[i].start, data[i].end);
		                    if (data[i].isBackwards)
		                        r.cursor = r.start;
		                    this.addRange(r, true);
		                }
		                return;
		            } else
		                data = data[0];
		        }
		        if (this.rangeList)
		            this.toSingleRange(data);
		        this.setSelectionRange(data, data.isBackwards);
		    };
		
		    this.isEqual = function(data) {
		        if ((data.length || this.rangeCount) && data.length != this.rangeCount)
		            return false;
		        if (!data.length || !this.ranges)
		            return this.getRange().isEqual(data);
		
		        for (var i = this.ranges.length; i--; ) {
		            if (!this.ranges[i].isEqual(data[i]))
		                return false;
		        }
		        return true;
		    };
		
		}).call(Selection.prototype);
		
		exports.Selection = Selection;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/theme/textmate/index.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		exports.isDark = false;
		exports.cssClass = "ace-tm";
		exports.cssText = require("./textmate.css");
		
		var dom = require("../../lib/dom");
		dom.importCssString(exports.cssText, exports.cssClass);
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/theme/textmate/textmate.css", ["require", "exports", "module", "window","__filename", "__dirname"],
 	function(require, exports, module, window, __filename, __dirname) {
 		module.exports = '.ace-tm .ace_gutter {  background: #f0f0f0;  color: #333;}.ace-tm .ace_print-margin {  width: 1px;  background: #e8e8e8;}.ace-tm .ace_fold {    background-color: #6B72E6;}.ace-tm {  background-color: #FFFFFF;  color: black;}.ace-tm .ace_cursor {  color: black;}        .ace-tm .ace_invisible {  color: rgb(191, 191, 191);}.ace-tm .ace_storage,.ace-tm .ace_keyword {  color: blue;}.ace-tm .ace_constant {  color: rgb(197, 6, 11);}.ace-tm .ace_constant.ace_buildin {  color: rgb(88, 72, 246);}.ace-tm .ace_constant.ace_language {  color: rgb(88, 92, 246);}.ace-tm .ace_constant.ace_library {  color: rgb(6, 150, 14);}.ace-tm .ace_invalid {  background-color: rgba(255, 0, 0, 0.1);  color: red;}.ace-tm .ace_support.ace_function {  color: rgb(60, 76, 114);}.ace-tm .ace_support.ace_constant {  color: rgb(6, 150, 14);}.ace-tm .ace_support.ace_type,.ace-tm .ace_support.ace_class {  color: rgb(109, 121, 222);}.ace-tm .ace_keyword.ace_operator {  color: rgb(104, 118, 135);}.ace-tm .ace_string {  color: rgb(3, 106, 7);}.ace-tm .ace_comment {  color: rgb(76, 136, 107);}.ace-tm .ace_comment.ace_doc {  color: rgb(0, 102, 255);}.ace-tm .ace_comment.ace_doc.ace_tag {  color: rgb(128, 159, 191);}.ace-tm .ace_constant.ace_numeric {  color: rgb(0, 0, 205);}.ace-tm .ace_variable {  color: rgb(49, 132, 149);}.ace-tm .ace_xml-pe {  color: rgb(104, 104, 91);}.ace-tm .ace_entity.ace_name.ace_function {  color: #0000A2;}.ace-tm .ace_heading {  color: rgb(12, 7, 255);}.ace-tm .ace_list {  color:rgb(185, 6, 144);}.ace-tm .ace_meta.ace_tag {  color:rgb(0, 22, 142);}.ace-tm .ace_string.ace_regex {  color: rgb(255, 0, 0)}.ace-tm .ace_marker-layer .ace_selection {  background: rgb(181, 213, 255);}.ace-tm.ace_multiselect .ace_selection.ace_start {  box-shadow: 0 0 3px 0px white;}.ace-tm .ace_marker-layer .ace_step {  background: rgb(252, 255, 0);}.ace-tm .ace_marker-layer .ace_stack {  background: rgb(164, 229, 101);}.ace-tm .ace_marker-layer .ace_bracket {  margin: -1px 0 0 -1px;  border: 1px solid rgb(192, 192, 192);}.ace-tm .ace_marker-layer .ace_active-line {  background: rgba(0, 0, 0, 0.07);}.ace-tm .ace_gutter-active-line {    background-color : #dcdcdc;}.ace-tm .ace_marker-layer .ace_selected-word {  background: rgb(250, 250, 255);  border: 1px solid rgb(200, 200, 250);}.ace-tm .ace_indent-guide {  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;}';
 	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });

(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/token_iterator.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		/**
		 * 
		 *
		 * This class provides an essay way to treat the document as a stream of tokens, and provides methods to iterate over these tokens.
		 * @class TokenIterator
		 **/
		
		/**
		 * Creates a new token iterator object. The inital token index is set to the provided row and column coordinates.
		 * @param {EditSession} session The session to associate with
		 * @param {Number} initialRow The row to start the tokenizing at
		 * @param {Number} initialColumn The column to start the tokenizing at
		 *
		 * @constructor
		 **/
		var TokenIterator = function(session, initialRow, initialColumn) {
		    this.$session = session;
		    this.$row = initialRow;
		    this.$rowTokens = session.getTokens(initialRow);
		
		    var token = session.getTokenAt(initialRow, initialColumn);
		    this.$tokenIndex = token ? token.index : -1;
		};
		
		(function() {
		   
		    /**
		     * Tokenizes all the items from the current point to the row prior in the document. 
		     * @returns {[String]} If the current point is not at the top of the file, this function returns `null`. Otherwise, it returns an array of the tokenized strings.
		     **/ 
		    this.stepBackward = function() {
		        this.$tokenIndex -= 1;
		        
		        while (this.$tokenIndex < 0) {
		            this.$row -= 1;
		            if (this.$row < 0) {
		                this.$row = 0;
		                return null;
		            }
		                
		            this.$rowTokens = this.$session.getTokens(this.$row);
		            this.$tokenIndex = this.$rowTokens.length - 1;
		        }
		            
		        return this.$rowTokens[this.$tokenIndex];
		    };
		  
		    /**
		     * Tokenizes all the items from the current point until the next row in the document. If the current point is at the end of the file, this function returns `null`. Otherwise, it returns the tokenized string.
		     * @returns {String}
		     **/   
		    this.stepForward = function() {
		        this.$tokenIndex += 1;
		        var rowCount;
		        while (this.$tokenIndex >= this.$rowTokens.length) {
		            this.$row += 1;
		            if (!rowCount)
		                rowCount = this.$session.getLength();
		            if (this.$row >= rowCount) {
		                this.$row = rowCount - 1;
		                return null;
		            }
		
		            this.$rowTokens = this.$session.getTokens(this.$row);
		            this.$tokenIndex = 0;
		        }
		            
		        return this.$rowTokens[this.$tokenIndex];
		    };
		 
		    /**
		     * 
		     * Returns the current tokenized string.
		     * @returns {String}
		     **/      
		    this.getCurrentToken = function () {
		        return this.$rowTokens[this.$tokenIndex];
		    };
		
		    /**
		     * 
		     * Returns the current row.
		     * @returns {Number}
		     **/      
		    this.getCurrentTokenRow = function () {
		        return this.$row;
		    };
		
		    /**
		     * 
		     * Returns the current column.
		     * @returns {Number}
		     **/     
		    this.getCurrentTokenColumn = function() {
		        var rowTokens = this.$rowTokens;
		        var tokenIndex = this.$tokenIndex;
		        
		        // If a column was cached by EditSession.getTokenAt, then use it
		        var column = rowTokens[tokenIndex].start;
		        if (column !== undefined)
		            return column;
		            
		        column = 0;
		        while (tokenIndex > 0) {
		            tokenIndex -= 1;
		            column += rowTokens[tokenIndex].value.length;
		        }
		        
		        return column;  
		    };
		
		    /**
		     * Return the current token position.
		     * @returns {Position}
		     */
		    this.getCurrentTokenPosition = function() {
		        return {row: this.$row, column: this.getCurrentTokenColumn()};
		    };
		            
		}).call(TokenIterator.prototype);
		
		exports.TokenIterator = TokenIterator;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/tokenizer.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var config = require("./config");
		// tokenizing lines longer than this makes editor very slow
		var MAX_TOKEN_COUNT = 2000;
		/**
		 * This class takes a set of highlighting rules, and creates a tokenizer out of them. For more information, see [the wiki on extending highlighters](https://github.com/ajaxorg/ace/wiki/Creating-or-Extending-an-Edit-Mode#wiki-extendingTheHighlighter).
		 * @class Tokenizer
		 **/
		
		/**
		 * Constructs a new tokenizer based on the given rules and flags.
		 * @param {Object} rules The highlighting rules
		 *
		 * @constructor
		 **/
		var Tokenizer = function(rules) {
		    this.states = rules;
		
		    this.regExps = {};
		    this.matchMappings = {};
		    for (var key in this.states) {
		        var state = this.states[key];
		        var ruleRegExps = [];
		        var matchTotal = 0;
		        var mapping = this.matchMappings[key] = {defaultToken: "text"};
		        var flag = "g";
		
		        var splitterRurles = [];
		        for (var i = 0; i < state.length; i++) {
		            var rule = state[i];
		            if (rule.defaultToken)
		                mapping.defaultToken = rule.defaultToken;
		            if (rule.caseInsensitive)
		                flag = "gi";
		            if (rule.regex == null)
		                continue;
		
		            if (rule.regex instanceof RegExp)
		                rule.regex = rule.regex.toString().slice(1, -1);
		
		            // Count number of matching groups. 2 extra groups from the full match
		            // And the catch-all on the end (used to force a match);
		            var adjustedregex = rule.regex;
		            var matchcount = new RegExp("(?:(" + adjustedregex + ")|(.))").exec("a").length - 2;
		            if (Array.isArray(rule.token)) {
		                if (rule.token.length == 1 || matchcount == 1) {
		                    rule.token = rule.token[0];
		                } else if (matchcount - 1 != rule.token.length) {
		                    this.reportError("number of classes and regexp groups doesn't match", { 
		                        rule: rule,
		                        groupCount: matchcount - 1
		                    });
		                    rule.token = rule.token[0];
		                } else {
		                    rule.tokenArray = rule.token;
		                    rule.token = null;
		                    rule.onMatch = this.$arrayTokens;
		                }
		            } else if (typeof rule.token == "function" && !rule.onMatch) {
		                if (matchcount > 1)
		                    rule.onMatch = this.$applyToken;
		                else
		                    rule.onMatch = rule.token;
		            }
		
		            if (matchcount > 1) {
		                if (/\\\d/.test(rule.regex)) {
		                    // Replace any backreferences and offset appropriately.
		                    adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function(match, digit) {
		                        return "\\" + (parseInt(digit, 10) + matchTotal + 1);
		                    });
		                } else {
		                    matchcount = 1;
		                    adjustedregex = this.removeCapturingGroups(rule.regex);
		                }
		                if (!rule.splitRegex && typeof rule.token != "string")
		                    splitterRurles.push(rule); // flag will be known only at the very end
		            }
		
		            mapping[matchTotal] = i;
		            matchTotal += matchcount;
		
		            ruleRegExps.push(adjustedregex);
		
		            // makes property access faster
		            if (!rule.onMatch)
		                rule.onMatch = null;
		        }
		        
		        if (!ruleRegExps.length) {
		            mapping[0] = 0;
		            ruleRegExps.push("$");
		        }
		        
		        splitterRurles.forEach(function(rule) {
		            rule.splitRegex = this.createSplitterRegexp(rule.regex, flag);
		        }, this);
		
		        this.regExps[key] = new RegExp("(" + ruleRegExps.join(")|(") + ")|($)", flag);
		    }
		};
		
		(function() {
		    this.$setMaxTokenCount = function(m) {
		        MAX_TOKEN_COUNT = m | 0;
		    };
		    
		    this.$applyToken = function(str) {
		        var values = this.splitRegex.exec(str).slice(1);
		        var types = this.token.apply(this, values);
		
		        // required for compatibility with old modes
		        if (typeof types === "string")
		            return [{type: types, value: str}];
		
		        var tokens = [];
		        for (var i = 0, l = types.length; i < l; i++) {
		            if (values[i])
		                tokens[tokens.length] = {
		                    type: types[i],
		                    value: values[i]
		                };
		        }
		        return tokens;
		    };
		
		    this.$arrayTokens = function(str) {
		        if (!str)
		            return [];
		        var values = this.splitRegex.exec(str);
		        if (!values)
		            return "text";
		        var tokens = [];
		        var types = this.tokenArray;
		        for (var i = 0, l = types.length; i < l; i++) {
		            if (values[i + 1])
		                tokens[tokens.length] = {
		                    type: types[i],
		                    value: values[i + 1]
		                };
		        }
		        return tokens;
		    };
		
		    this.removeCapturingGroups = function(src) {
		        var r = src.replace(
		            /\[(?:\\.|[^\]])*?\]|\\.|\(\?[:=!]|(\()/g,
		            function(x, y) {return y ? "(?:" : x;}
		        );
		        return r;
		    };
		
		    this.createSplitterRegexp = function(src, flag) {
		        if (src.indexOf("(?=") != -1) {
		            var stack = 0;
		            var inChClass = false;
		            var lastCapture = {};
		            src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function(
		                m, esc, parenOpen, parenClose, square, index
		            ) {
		                if (inChClass) {
		                    inChClass = square != "]";
		                } else if (square) {
		                    inChClass = true;
		                } else if (parenClose) {
		                    if (stack == lastCapture.stack) {
		                        lastCapture.end = index+1;
		                        lastCapture.stack = -1;
		                    }
		                    stack--;
		                } else if (parenOpen) {
		                    stack++;
		                    if (parenOpen.length != 1) {
		                        lastCapture.stack = stack
		                        lastCapture.start = index;
		                    }
		                }
		                return m;
		            });
		
		            if (lastCapture.end != null && /^\)*$/.test(src.substr(lastCapture.end)))
		                src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
		        }
		        
		        // this is needed for regexps that can match in multiple ways
		        if (src.charAt(0) != "^") src = "^" + src;
		        if (src.charAt(src.length - 1) != "$") src += "$";
		        
		        return new RegExp(src, (flag||"").replace("g", ""));
		    };
		
		    /**
		     * Returns an object containing two properties: `tokens`, which contains all the tokens; and `state`, the current state.
		     * @returns {Object}
		     **/
		    this.getLineTokens = function(line, startState) {
		        if (startState && typeof startState != "string") {
		            var stack = startState.slice(0);
		            startState = stack[0];
		            if (startState === "#tmp") {
		                stack.shift()
		                startState = stack.shift()
		            }
		        } else
		            var stack = [];
		
		        var currentState = startState || "start";
		        var state = this.states[currentState];
		        if (!state) {
		            currentState = "start";
		            state = this.states[currentState];
		        }
		        var mapping = this.matchMappings[currentState];
		        var re = this.regExps[currentState];
		        re.lastIndex = 0;
		
		        var match, tokens = [];
		        var lastIndex = 0;
		        var matchAttempts = 0;
		
		        var token = {type: null, value: ""};
		
		        while (match = re.exec(line)) {
		            var type = mapping.defaultToken;
		            var rule = null;
		            var value = match[0];
		            var index = re.lastIndex;
		
		            if (index - value.length > lastIndex) {
		                var skipped = line.substring(lastIndex, index - value.length);
		                if (token.type == type) {
		                    token.value += skipped;
		                } else {
		                    if (token.type)
		                        tokens.push(token);
		                    token = {type: type, value: skipped};
		                }
		            }
		
		            for (var i = 0; i < match.length-2; i++) {
		                if (match[i + 1] === undefined)
		                    continue;
		
		                rule = state[mapping[i]];
		
		                if (rule.onMatch)
		                    type = rule.onMatch(value, currentState, stack);
		                else
		                    type = rule.token;
		
		                if (rule.next) {
		                    if (typeof rule.next == "string") {
		                        currentState = rule.next;
		                    } else {
		                        currentState = rule.next(currentState, stack);
		                    }
		                    
		                    state = this.states[currentState];
		                    if (!state) {
		                        this.reportError("state doesn't exist", currentState);
		                        currentState = "start";
		                        state = this.states[currentState];
		                    }
		                    mapping = this.matchMappings[currentState];
		                    lastIndex = index;
		                    re = this.regExps[currentState];
		                    re.lastIndex = index;
		                }
		                break;
		            }
		
		            if (value) {
		                if (typeof type === "string") {
		                    if ((!rule || rule.merge !== false) && token.type === type) {
		                        token.value += value;
		                    } else {
		                        if (token.type)
		                            tokens.push(token);
		                        token = {type: type, value: value};
		                    }
		                } else if (type) {
		                    if (token.type)
		                        tokens.push(token);
		                    token = {type: null, value: ""};
		                    for (var i = 0; i < type.length; i++)
		                        tokens.push(type[i]);
		                }
		            }
		
		            if (lastIndex == line.length)
		                break;
		
		            lastIndex = index;
		
		            if (matchAttempts++ > MAX_TOKEN_COUNT) {
		                if (matchAttempts > 2 * line.length) {
		                    this.reportError("infinite loop with in ace tokenizer", {
		                        startState: startState,
		                        line: line
		                    });
		                }
		                // chrome doens't show contents of text nodes with very long text
		                while (lastIndex < line.length) {
		                    if (token.type)
		                        tokens.push(token);
		                    token = {
		                        value: line.substring(lastIndex, lastIndex += 2000),
		                        type: "overflow"
		                    };
		                }
		                currentState = "start";
		                stack = [];
		                break;
		            }
		        }
		
		        if (token.type)
		            tokens.push(token);
		        
		        if (stack.length > 1) {
		            if (stack[0] !== currentState)
		                stack.unshift("#tmp", currentState);
		        }
		        return {
		            tokens : tokens,
		            state : stack.length ? stack : currentState
		        };
		    };
		    
		    this.reportError = config.reportError;
		    
		}).call(Tokenizer.prototype);
		
		exports.Tokenizer = Tokenizer;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/tooltip.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var oop = require("./lib/oop");
		var dom = require("./lib/dom");
		
		/**
		 * @class Tooltip
		 **/
		
		/**
		 * @param {Element} parentNode
		 *
		 * @constructor
		 **/
		function Tooltip (parentNode) {
		    this.isOpen = false;
		    this.$element = null;
		    this.$parentNode = parentNode;
		}
		
		(function() {
		    this.$init = function() {
		        this.$element = dom.createElement("div");
		        this.$element.className = "ace_tooltip";
		        this.$element.style.display = "none";
		        this.$parentNode.appendChild(this.$element);
		        return this.$element;
		    };
		
		    /**
		     * @returns {Element}
		     **/
		    this.getElement = function() {
		        return this.$element || this.$init();
		    };
		
		    /**
		     * @param {String} text
		     **/
		    this.setText = function(text) {
		        dom.setInnerText(this.getElement(), text);
		    };
		
		    /**
		     * @param {String} html
		     **/
		    this.setHtml = function(html) {
		        this.getElement().innerHTML = html;
		    };
		
		    /**
		     * @param {Number} x
		     * @param {Number} y
		     **/
		    this.setPosition = function(x, y) {
		        this.getElement().style.left = x + "px";
		        this.getElement().style.top = y + "px";
		    };
		
		    /**
		     * @param {String} className
		     **/
		    this.setClassName = function(className) {
		        dom.addCssClass(this.getElement(), className);
		    };
		
		    /**
		     * @param {String} text
		     * @param {Number} x
		     * @param {Number} y
		     **/
		    this.show = function(text, x, y) {
		        if (text != null)
		            this.setText(text);
		        if (x != null && y != null)
		            this.setPosition(x, y);
		        if (!this.isOpen) {
		            this.getElement().style.display = "block";
		            this.isOpen = true;
		        }
		    };
		
		    this.hide = function() {
		        if (this.isOpen) {
		            this.getElement().style.display = "none";
		            this.isOpen = false;
		        }
		    };
		
		    /**
		     * @returns {Number}
		     **/
		    this.getHeight = function() {
		        return this.getElement().offsetHeight;
		    };
		
		    /**
		     * @returns {Number}
		     **/
		    this.getWidth = function() {
		        return this.getElement().offsetWidth;
		    };
		
		}).call(Tooltip.prototype);
		
		exports.Tooltip = Tooltip;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/undomanager.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		/**
		 * This object maintains the undo stack for an [[EditSession `EditSession`]].
		 * @class UndoManager
		 **/
		
		/**
		 * Resets the current undo state and creates a new `UndoManager`.
		 * 
		 * @constructor
		 **/
		var UndoManager = function() {
		    this.$maxRev = 0;
		    this.$fromUndo = false;
		    this.reset();
		};
		
		(function() {
		    
		    this.addSession = function(session) {
		        this.$session = session;
		    };
		    /**
		     * Provides a means for implementing your own undo manager. `options` has one property, `args`, an [[Array `Array`]], with two elements:
		     *
		     * - `args[0]` is an array of deltas
		     * - `args[1]` is the document to associate with
		     *
		     * @param {Object} options Contains additional properties
		     *
		     **/
		    this.add = function(delta, allowMerge, session) {
		        if (this.$fromUndo) return;
		        if (delta == this.$lastDelta) return;
		        if (allowMerge === false || !this.lastDeltas) {
		            this.lastDeltas = [];
		            this.$undoStack.push(this.lastDeltas);
		            delta.id = this.$rev = ++this.$maxRev;
		        }
		        if (delta.action == "remove" || delta.action == "insert")
		            this.$lastDelta = delta;
		        this.lastDeltas.push(delta);
		    };
		    
		    this.addSelection = function(selection, rev) {
		        this.selections.push({
		            value: selection,
		            rev: rev || this.$rev
		        });
		    };
		    
		    this.startNewGroup = function() {
		        this.lastDeltas = null;
		        return this.$rev;
		    };
		    
		    this.markIgnored = function(from, to) {
		        if (to == null) to = this.$rev + 1;
		        var stack = this.$undoStack;
		        for (var i = stack.length; i--;) {
		            var delta = stack[i][0];
		            if (delta.id <= from)
		                break;
		            if (delta.id < to)
		                delta.ignore = true;
		        }
		        this.lastDeltas = null;
		    };
		    
		    this.getSelection = function(rev, after) {
		        var stack = this.selections;
		        for (var i = stack.length; i--;) {
		            var selection = stack[i];
		            if (selection.rev < rev) {
		                if (after)
		                    selection = stack[i + 1];
		                return selection;
		            }
		        }
		    };
		    
		    this.getRevision = function() {
		        return this.$rev;
		    };
		    
		    this.getDeltas = function(from, to) {
		        if (to == null) to = this.$rev + 1;
		        var stack = this.$undoStack;
		        var end = null, start = 0;
		        for (var i = stack.length; i--;) {
		            var delta = stack[i][0];
		            if (delta.id < to && !end)
		                end = i+1;
		            if (delta.id <= from) {
		                start = i + 1;
		                break;
		            }
		        }
		        return stack.slice(start, end);
		    };
		    
		    this.getChangedRanges = function(from, to) {
		        if (to == null) to = this.$rev + 1;
		        
		    };
		    
		    this.getChangedLines = function(from, to) {
		        if (to == null) to = this.$rev + 1;
		        
		    };
		    
		    /**
		     * [Perform an undo operation on the document, reverting the last change.]{: #UndoManager.undo}
		     * @param {Boolean} dontSelect {:dontSelect}
		     *
		     * @returns {Range} The range of the undo.
		     **/
		    this.undo = function(session, dontSelect) {
		        this.lastDeltas = null;
		        var stack = this.$undoStack;
		        
		        if (!rearrangeUndoStack(stack, stack.length))
		            return;
		        
		        if (!session)
		            session = this.$session;
		        
		        if (this.$redoStackBaseRev !== this.$rev && this.$redoStack.length)
		            this.$redoStack = [];
		        
		        this.$fromUndo = true;
		        
		        var deltaSet = stack.pop();
		        var undoSelectionRange = null;
		        if (deltaSet && deltaSet.length) {
		            undoSelectionRange = session.undoChanges(deltaSet, dontSelect);
		            this.$redoStack.push(deltaSet);
		            this.$syncRev();
		        }
		        
		        this.$fromUndo = false;
		
		        return undoSelectionRange;
		    };
		    
		    /**
		     * [Perform a redo operation on the document, reimplementing the last change.]{: #UndoManager.redo}
		     * @param {Boolean} dontSelect {:dontSelect}
		     *
		     **/
		    this.redo = function(session, dontSelect) {
		        this.lastDeltas = null;
		        
		        if (!session)
		            session = this.$session;
		        
		        this.$fromUndo = true;
		        if (this.$redoStackBaseRev != this.$rev) {
		            var diff = this.getDeltas(this.$redoStackBaseRev, this.$rev + 1);
		            rebaseRedoStack(this.$redoStack, diff);
		            this.$redoStackBaseRev = this.$rev;
		            this.$redoStack.forEach(function(x) {
		                x[0].id = ++this.$maxRev;
		            }, this);
		        }
		        var deltaSet = this.$redoStack.pop();
		        var redoSelectionRange = null;
		        
		        if (deltaSet) {
		            redoSelectionRange = session.redoChanges(deltaSet, dontSelect);
		            this.$undoStack.push(deltaSet);
		            this.$syncRev();
		        }
		        this.$fromUndo = false;
		        
		        return redoSelectionRange;
		    };
		    
		    this.$syncRev = function() {
		        var stack = this.$undoStack;
		        var nextDelta = stack[stack.length - 1];
		        var id = nextDelta && nextDelta[0].id || 0;
		        this.$redoStackBaseRev = id;
		        this.$rev = id;
		    };
		
		    /**
		     * Destroys the stack of undo and redo redo operations.
		     **/
		    this.reset = function() {
		        this.lastDeltas = null;
		        this.$lastDelta = null;
		        this.$undoStack = [];
		        this.$redoStack = [];
		        this.$rev = 0;
		        this.mark = 0;
		        this.$redoStackBaseRev = this.$rev;
		        this.selections = [];
		    };
		
		    
		    /**
		     * Returns `true` if there are undo operations left to perform.
		     * @returns {Boolean}
		     **/
		    this.canUndo = function() {
		        return this.$undoStack.length > 0;
		    };
		
		    /**
		     * Returns `true` if there are redo operations left to perform.
		     * @returns {Boolean}
		     **/
		    this.canRedo = function() {
		        return this.$redoStack.length > 0;
		    };
		    
		    /**
		     * Marks the current status clean
		     **/
		    this.bookmark = function(rev) {
		        if (rev == undefined)
		            rev = this.$rev;
		        this.mark = rev;
		    };
		
		    /**
		     * Returns if the current status is clean
		     * @returns {Boolean}
		     **/
		    this.isAtBookmark = function() {
		        return this.$rev === this.mark;
		    };
		    
		    this.toJSON = function() {
		        
		    };
		    
		    this.fromJSON = function() {
		        
		    };
		    
		    this.hasUndo = this.canUndo;
		    this.hasRedo = this.canRedo;
		    this.isClean = this.isAtBookmark;
		    this.markClean = this.bookmark;
		    
		}).call(UndoManager.prototype);
		
		function rearrangeUndoStack(stack, pos) {
		    for (var i = pos; i--; ) {
		        var deltaSet = stack[i];
		        if (deltaSet && !deltaSet[0].ignore) {
		            while(i < pos - 1) {
		                var swapped = swapGroups(stack[i], stack[i + 1]);
		                stack[i] = swapped[0];
		                stack[i + 1] = swapped[1];
		                i++;
		            }
		            return true;
		        }
		    }
		}
		
		var Range = require("./range").Range;
		var cmp = Range.comparePoints;
		var comparePoints = Range.comparePoints;
		
		function $updateMarkers(delta) {
		    var isInsert = delta.action == "insert";
		    var start = delta.start;
		    var end = delta.end;
		    var rowShift = (end.row - start.row) * (isInsert ? 1 : -1);
		    var colShift = (end.column - start.column) * (isInsert ? 1 : -1);
		    if (isInsert) end = start;
		
		    for (var i in this.marks) {
		        var point = this.marks[i];
		        var cmp = comparePoints(point, start);
		        if (cmp < 0) {
		            continue; // delta starts after the range
		        }
		        if (cmp === 0) {
		            if (isInsert) {
		                if (point.bias == 1) {
		                    cmp = 1;
		                }
		                else {
		                    point.bias == -1;
		                    continue;
		                }
		            }
		        }
		        var cmp2 = isInsert ? cmp : comparePoints(point, end);
		        if (cmp2 > 0) {
		            point.row += rowShift;
		            point.column += point.row == end.row ? colShift : 0;
		            continue;
		        }
		        if (!isInsert && cmp2 <= 0) {
		            point.row = start.row;
		            point.column = start.column;
		            if (cmp2 === 0)
		                point.bias = 1;
		        }
		    }
		}
		
		
		
		function clonePos(pos) {
		    return {row: pos.row,column: pos.column};
		}
		function cloneDelta(d) {
		    return {
		        start: clonePos(d.start),
		        end: clonePos(d.end),
		        action: d.action,
		        lines: d.lines.slice()
		    };
		}
		function stringifyDelta(d) {
		    d = d || this;
		    if (Array.isArray(d)) {
		        return d.map(stringifyDelta).join("\n");
		    }
		    var type = "";
		    if (d.action) {
		        type = d.action == "insert" ? "+" : "-";
		        type += "[" + d.lines + "]";
		    } else if (d.value) {
		        if (Array.isArray(d.value)) {
		            type = d.value.map(stringifyRange).join("\n");
		        } else {
		            type = stringifyRange(d.value);
		        }
		    }
		    if (d.start) {
		        type += stringifyRange(d);
		    }
		    if (d.id || d.rev) {
		        type += "\t(" + (d.id || d.rev) + ")";
		    }
		    return type;
		}
		function stringifyRange(r) {
		    return r.start.row + ":" + r.start.column 
		        + "=>" + r.end.row + ":" + r.end.column;
		}
		/*
		 * i i  d1  d2
		 *      |/  |/  d2.s >= d1.e shift(d2, d1, -1)
		 *              d2.s <= d1.s shift(d1, d2, +1)
		 *       d1.s < d2.s < d1.e // can split
		 * 
		 * i r  d1  d2
		 *      |/  |\  d2.s >= d1.e shift(d2, d1, -1)
		 *              d2.e <= d1.s shift(d1, d2, -1)
		 *       else // can't swap
		 * 
		 * r i  d1  d2
		 *      |\  |/  d2.s >= d1.s shift(d2, d1, +1)
		 *              d2.s <= d1.s shift(d1, d2, +1)
		 *       // no else
		 * 
		 * r r  d1  d2
		 *      |\  |\  d2.s >= d1.s shift(d2, d1, +1)
		 *              d2.e <= d1.s shift(d1, d2, -1)
		 *       d2.s < d1.s < d2.e // can split
		 */
		
		function swap(d1, d2) {
		    var i1 = d1.action == "insert";
		    var i2 = d2.action == "insert";
		    
		    if (i1 && i2) {
		        if (cmp(d2.start, d1.end) >= 0) {
		            shift(d2, d1, -1);
		        } else if (cmp(d2.start, d1.start) <= 0) {
		            shift(d1, d2, +1);
		        } else {
		            return null;
		        }
		    } else if (i1 && !i2) {
		        if (cmp(d2.start, d1.end) >= 0) {
		            shift(d2, d1, -1);
		        } else if (cmp(d2.end, d1.start) <= 0) {
		            shift(d1, d2, -1);
		        } else {
		            return null;
		        }
		    } else if (!i1 && i2) {
		        if (cmp(d2.start, d1.start) >= 0) {
		            shift(d2, d1, +1);
		        } else if (cmp(d2.start, d1.start) <= 0) {
		            shift(d1, d2, +1);
		        } else {
		            return null;
		        }
		    } else if (!i1 && !i2) {
		        if (cmp(d2.start, d1.start) >= 0) {
		            shift(d2, d1, +1);
		        } else if (cmp(d2.end, d1.start) <= 0) {
		            shift(d1, d2, -1);
		        } else {
		            return null;
		        }
		    }
		    return [d2, d1];
		}
		function swapGroups(ds1, ds2) {
		    for (var i = ds1.length; i--; ) {
		        for (var j = 0; j < ds2.length; j++) {
		            if (!swap(ds1[i], ds2[j])) {
		                // rollback, we have to undo ds2 first
		                while (i < ds1.length) {
		                    while (j--) {
		                        swap(ds2[j], ds1[i]);
		                    }
		                    j = ds2.length;
		                    i++;
		                }                
		                return [ds1, ds2];
		            }
		        }
		    }
		    ds1.selectionBefore = ds2.selectionBefore = 
		    ds1.selectionAfter = ds2.selectionAfter = null;
		    return [ds2, ds1];
		}
		
		/*
		      d2          xform(d1, c1) = [d2, c2]
		    o<---o        xform(c1, d1) = [c2, d2]
		 c2 |    | d1     
		    o<---o
		      c1
		*/
		function xform(d1, c1) {
		    var i1 = d1.action == "insert";
		    var i2 = c1.action == "insert";
		    
		    if (i1 && i2) {
		        if (cmp(d1.start, c1.start) < 0) {
		            shift(c1, d1, 1);
		        } else {
		            shift(d1, c1, 1);
		        }
		    } else if (i1 && !i2) {
		        if (cmp(d1.start, c1.end) >= 0) {
		            shift(d1, c1, -1);
		        } else if (cmp(d1.start, c1.start) <= 0) {
		            shift(c1, d1, +1);
		        } else {
		            shift(d1, Range.fromPoints(c1.start, d1.start), -1);
		            shift(c1, d1, +1);
		        }
		    } else if (!i1 && i2) {
		        if (cmp(c1.start, d1.end) >= 0) {
		            shift(c1, d1, -1);
		        } else if (cmp(c1.start, d1.start) <= 0) {
		            shift(d1, c1, +1);
		        } else {
		            shift(c1, Range.fromPoints(d1.start, c1.start), -1);
		            shift(d1, c1, +1);
		        }
		    } else if (!i1 && !i2) {
		        if (cmp(c1.start, d1.end) >= 0) {
		            shift(c1, d1, -1);
		        } else if (cmp(c1.end, d1.start) <= 0) {
		            shift(d1, c1, -1);
		        } else {
		            var before, after;
		            if (cmp(d1.start, c1.start) < 0) {
		                before = d1;
		                d1 = splitDelta(d1, c1.start);
		            }
		            if (cmp(d1.end, c1.end) > 0) {
		                after = splitDelta(d1, c1.end);
		            }
		
		            shiftPos(c1.end, d1.start, d1.end, -1);
		            if (after && !before) {
		                d1.lines = after.lines;
		                d1.start = after.start;
		                d1.end = after.end;
		                after = d1;
		            }
		
		            return [c1, before, after].filter(Boolean);
		        }
		    }
		    return [c1, d1];
		}
		    
		function shift(d1, d2, dir) {
		    shiftPos(d1.start, d2.start, d2.end, dir);
		    shiftPos(d1.end, d2.start, d2.end, dir);
		}
		function shiftPos(pos, start, end, dir) {
		    if (pos.row == (dir == 1 ? start : end).row) {
		        pos.column += dir * (end.column - start.column);
		    }
		    pos.row += dir * (end.row - start.row);
		}
		function splitDelta(c, pos) {
		    var lines = c.lines;
		    var end = c.end;
		    c.end = clonePos(pos);    
		    var rowsBefore = c.end.row - c.start.row;
		    var otherLines = lines.splice(rowsBefore, lines.length);
		    
		    var col = rowsBefore ? pos.column : pos.column - c.start.column;
		    lines.push(otherLines[0].substring(0, col));
		    otherLines[0] = otherLines[0].substr(col)   ; 
		    var rest = {
		        start: clonePos(pos),
		        end: end,
		        lines: otherLines,
		        action: c.action
		    };
		    return rest;
		}
		
		function moveDeltasByOne(redoStack, d) {
		    d = cloneDelta(d);
		    for (var j = redoStack.length; j--;) {
		        var deltaSet = redoStack[j];
		        for (var i = deltaSet.length; i--> 0;) {
		            var x = deltaSet[i];
		            var xformed = xform(x, d);
		            d = xformed[0];
		            if (xformed.length != 2) {
		                if (xformed[2]) {
		                    redoStack.splice(i + 1, 1, xformed[1], xformed[2]);
		                    i++;
		                } else if (!xformed[1]) {
		                    redoStack.splice(i, 1);
		                    i--;
		                }
		            }
		        }
		    }
		    return redoStack;
		}
		function rebaseRedoStack(redoStack, deltaSets) {
		    for (var i = 0; i < deltaSets.length; i++) {
		        var deltas = deltaSets[i];
		        for (var j = 0; j < deltas.length; j++) {
		            moveDeltasByOne(redoStack, deltas[j]);
		        }
		    }
		}
		
		exports.UndoManager = UndoManager;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/unicode.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		/*
		XRegExp Unicode plugin pack: Categories 1.0
		(c) 2010 Steven Levithan
		MIT License
		<http://xregexp.com>
		Uses the Unicode 5.2 character database
		
		This package for the XRegExp Unicode plugin enables the following Unicode categories (aka properties):
		
		L - Letter (the top-level Letter category is included in the Unicode plugin base script)
		    Ll - Lowercase letter
		    Lu - Uppercase letter
		    Lt - Titlecase letter
		    Lm - Modifier letter
		    Lo - Letter without case
		M - Mark
		    Mn - Non-spacing mark
		    Mc - Spacing combining mark
		    Me - Enclosing mark
		N - Number
		    Nd - Decimal digit
		    Nl - Letter number
		    No -  Other number
		P - Punctuation
		    Pd - Dash punctuation
		    Ps - Open punctuation
		    Pe - Close punctuation
		    Pi - Initial punctuation
		    Pf - Final punctuation
		    Pc - Connector punctuation
		    Po - Other punctuation
		S - Symbol
		    Sm - Math symbol
		    Sc - Currency symbol
		    Sk - Modifier symbol
		    So - Other symbol
		Z - Separator
		    Zs - Space separator
		    Zl - Line separator
		    Zp - Paragraph separator
		C - Other
		    Cc - Control
		    Cf - Format
		    Co - Private use
		    Cs - Surrogate
		    Cn - Unassigned
		
		Example usage:
		
		    \p{N}
		    \p{Cn}
		*/
		
		
		// will be populated by addUnicodePackage
		exports.packages = {};
		
		addUnicodePackage({
		    L:  "0041-005A0061-007A00AA00B500BA00C0-00D600D8-00F600F8-02C102C6-02D102E0-02E402EC02EE0370-037403760377037A-037D03860388-038A038C038E-03A103A3-03F503F7-0481048A-05250531-055605590561-058705D0-05EA05F0-05F20621-064A066E066F0671-06D306D506E506E606EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA07F407F507FA0800-0815081A082408280904-0939093D09500958-0961097109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E460E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EC60EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10A0-10C510D0-10FA10FC1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317D717DC1820-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541AA71B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C7D1CE9-1CEC1CEE-1CF11D00-1DBF1E00-1F151F18-1F1D1F20-1F451F48-1F4D1F50-1F571F591F5B1F5D1F5F-1F7D1F80-1FB41FB6-1FBC1FBE1FC2-1FC41FC6-1FCC1FD0-1FD31FD6-1FDB1FE0-1FEC1FF2-1FF41FF6-1FFC2071207F2090-209421022107210A-211321152119-211D212421262128212A-212D212F-2139213C-213F2145-2149214E218321842C00-2C2E2C30-2C5E2C60-2CE42CEB-2CEE2D00-2D252D30-2D652D6F2D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE2E2F300530063031-3035303B303C3041-3096309D-309F30A1-30FA30FC-30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A48CA4D0-A4FDA500-A60CA610-A61FA62AA62BA640-A65FA662-A66EA67F-A697A6A0-A6E5A717-A71FA722-A788A78BA78CA7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2A9CFAA00-AA28AA40-AA42AA44-AA4BAA60-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADB-AADDABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB00-FB06FB13-FB17FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF21-FF3AFF41-FF5AFF66-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
		    Ll: "0061-007A00AA00B500BA00DF-00F600F8-00FF01010103010501070109010B010D010F01110113011501170119011B011D011F01210123012501270129012B012D012F01310133013501370138013A013C013E014001420144014601480149014B014D014F01510153015501570159015B015D015F01610163016501670169016B016D016F0171017301750177017A017C017E-0180018301850188018C018D019201950199-019B019E01A101A301A501A801AA01AB01AD01B001B401B601B901BA01BD-01BF01C601C901CC01CE01D001D201D401D601D801DA01DC01DD01DF01E101E301E501E701E901EB01ED01EF01F001F301F501F901FB01FD01FF02010203020502070209020B020D020F02110213021502170219021B021D021F02210223022502270229022B022D022F02310233-0239023C023F0240024202470249024B024D024F-02930295-02AF037103730377037B-037D039003AC-03CE03D003D103D5-03D703D903DB03DD03DF03E103E303E503E703E903EB03ED03EF-03F303F503F803FB03FC0430-045F04610463046504670469046B046D046F04710473047504770479047B047D047F0481048B048D048F04910493049504970499049B049D049F04A104A304A504A704A904AB04AD04AF04B104B304B504B704B904BB04BD04BF04C204C404C604C804CA04CC04CE04CF04D104D304D504D704D904DB04DD04DF04E104E304E504E704E904EB04ED04EF04F104F304F504F704F904FB04FD04FF05010503050505070509050B050D050F05110513051505170519051B051D051F0521052305250561-05871D00-1D2B1D62-1D771D79-1D9A1E011E031E051E071E091E0B1E0D1E0F1E111E131E151E171E191E1B1E1D1E1F1E211E231E251E271E291E2B1E2D1E2F1E311E331E351E371E391E3B1E3D1E3F1E411E431E451E471E491E4B1E4D1E4F1E511E531E551E571E591E5B1E5D1E5F1E611E631E651E671E691E6B1E6D1E6F1E711E731E751E771E791E7B1E7D1E7F1E811E831E851E871E891E8B1E8D1E8F1E911E931E95-1E9D1E9F1EA11EA31EA51EA71EA91EAB1EAD1EAF1EB11EB31EB51EB71EB91EBB1EBD1EBF1EC11EC31EC51EC71EC91ECB1ECD1ECF1ED11ED31ED51ED71ED91EDB1EDD1EDF1EE11EE31EE51EE71EE91EEB1EED1EEF1EF11EF31EF51EF71EF91EFB1EFD1EFF-1F071F10-1F151F20-1F271F30-1F371F40-1F451F50-1F571F60-1F671F70-1F7D1F80-1F871F90-1F971FA0-1FA71FB0-1FB41FB61FB71FBE1FC2-1FC41FC61FC71FD0-1FD31FD61FD71FE0-1FE71FF2-1FF41FF61FF7210A210E210F2113212F21342139213C213D2146-2149214E21842C30-2C5E2C612C652C662C682C6A2C6C2C712C732C742C76-2C7C2C812C832C852C872C892C8B2C8D2C8F2C912C932C952C972C992C9B2C9D2C9F2CA12CA32CA52CA72CA92CAB2CAD2CAF2CB12CB32CB52CB72CB92CBB2CBD2CBF2CC12CC32CC52CC72CC92CCB2CCD2CCF2CD12CD32CD52CD72CD92CDB2CDD2CDF2CE12CE32CE42CEC2CEE2D00-2D25A641A643A645A647A649A64BA64DA64FA651A653A655A657A659A65BA65DA65FA663A665A667A669A66BA66DA681A683A685A687A689A68BA68DA68FA691A693A695A697A723A725A727A729A72BA72DA72F-A731A733A735A737A739A73BA73DA73FA741A743A745A747A749A74BA74DA74FA751A753A755A757A759A75BA75DA75FA761A763A765A767A769A76BA76DA76FA771-A778A77AA77CA77FA781A783A785A787A78CFB00-FB06FB13-FB17FF41-FF5A",
		    Lu: "0041-005A00C0-00D600D8-00DE01000102010401060108010A010C010E01100112011401160118011A011C011E01200122012401260128012A012C012E01300132013401360139013B013D013F0141014301450147014A014C014E01500152015401560158015A015C015E01600162016401660168016A016C016E017001720174017601780179017B017D018101820184018601870189-018B018E-0191019301940196-0198019C019D019F01A001A201A401A601A701A901AC01AE01AF01B1-01B301B501B701B801BC01C401C701CA01CD01CF01D101D301D501D701D901DB01DE01E001E201E401E601E801EA01EC01EE01F101F401F6-01F801FA01FC01FE02000202020402060208020A020C020E02100212021402160218021A021C021E02200222022402260228022A022C022E02300232023A023B023D023E02410243-02460248024A024C024E03700372037603860388-038A038C038E038F0391-03A103A3-03AB03CF03D2-03D403D803DA03DC03DE03E003E203E403E603E803EA03EC03EE03F403F703F903FA03FD-042F04600462046404660468046A046C046E04700472047404760478047A047C047E0480048A048C048E04900492049404960498049A049C049E04A004A204A404A604A804AA04AC04AE04B004B204B404B604B804BA04BC04BE04C004C104C304C504C704C904CB04CD04D004D204D404D604D804DA04DC04DE04E004E204E404E604E804EA04EC04EE04F004F204F404F604F804FA04FC04FE05000502050405060508050A050C050E05100512051405160518051A051C051E0520052205240531-055610A0-10C51E001E021E041E061E081E0A1E0C1E0E1E101E121E141E161E181E1A1E1C1E1E1E201E221E241E261E281E2A1E2C1E2E1E301E321E341E361E381E3A1E3C1E3E1E401E421E441E461E481E4A1E4C1E4E1E501E521E541E561E581E5A1E5C1E5E1E601E621E641E661E681E6A1E6C1E6E1E701E721E741E761E781E7A1E7C1E7E1E801E821E841E861E881E8A1E8C1E8E1E901E921E941E9E1EA01EA21EA41EA61EA81EAA1EAC1EAE1EB01EB21EB41EB61EB81EBA1EBC1EBE1EC01EC21EC41EC61EC81ECA1ECC1ECE1ED01ED21ED41ED61ED81EDA1EDC1EDE1EE01EE21EE41EE61EE81EEA1EEC1EEE1EF01EF21EF41EF61EF81EFA1EFC1EFE1F08-1F0F1F18-1F1D1F28-1F2F1F38-1F3F1F48-1F4D1F591F5B1F5D1F5F1F68-1F6F1FB8-1FBB1FC8-1FCB1FD8-1FDB1FE8-1FEC1FF8-1FFB21022107210B-210D2110-211221152119-211D212421262128212A-212D2130-2133213E213F214521832C00-2C2E2C602C62-2C642C672C692C6B2C6D-2C702C722C752C7E-2C802C822C842C862C882C8A2C8C2C8E2C902C922C942C962C982C9A2C9C2C9E2CA02CA22CA42CA62CA82CAA2CAC2CAE2CB02CB22CB42CB62CB82CBA2CBC2CBE2CC02CC22CC42CC62CC82CCA2CCC2CCE2CD02CD22CD42CD62CD82CDA2CDC2CDE2CE02CE22CEB2CEDA640A642A644A646A648A64AA64CA64EA650A652A654A656A658A65AA65CA65EA662A664A666A668A66AA66CA680A682A684A686A688A68AA68CA68EA690A692A694A696A722A724A726A728A72AA72CA72EA732A734A736A738A73AA73CA73EA740A742A744A746A748A74AA74CA74EA750A752A754A756A758A75AA75CA75EA760A762A764A766A768A76AA76CA76EA779A77BA77DA77EA780A782A784A786A78BFF21-FF3A",
		    Lt: "01C501C801CB01F21F88-1F8F1F98-1F9F1FA8-1FAF1FBC1FCC1FFC",
		    Lm: "02B0-02C102C6-02D102E0-02E402EC02EE0374037A0559064006E506E607F407F507FA081A0824082809710E460EC610FC17D718431AA71C78-1C7D1D2C-1D611D781D9B-1DBF2071207F2090-20942C7D2D6F2E2F30053031-3035303B309D309E30FC-30FEA015A4F8-A4FDA60CA67FA717-A71FA770A788A9CFAA70AADDFF70FF9EFF9F",
		    Lo: "01BB01C0-01C3029405D0-05EA05F0-05F20621-063F0641-064A066E066F0671-06D306D506EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA0800-08150904-0939093D09500958-096109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E450E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10D0-10FA1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317DC1820-18421844-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C771CE9-1CEC1CEE-1CF12135-21382D30-2D652D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE3006303C3041-3096309F30A1-30FA30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A014A016-A48CA4D0-A4F7A500-A60BA610-A61FA62AA62BA66EA6A0-A6E5A7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2AA00-AA28AA40-AA42AA44-AA4BAA60-AA6FAA71-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADBAADCABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF66-FF6FFF71-FF9DFFA0-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
		    M:  "0300-036F0483-04890591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DE-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0903093C093E-094E0951-0955096209630981-098309BC09BE-09C409C709C809CB-09CD09D709E209E30A01-0A030A3C0A3E-0A420A470A480A4B-0A4D0A510A700A710A750A81-0A830ABC0ABE-0AC50AC7-0AC90ACB-0ACD0AE20AE30B01-0B030B3C0B3E-0B440B470B480B4B-0B4D0B560B570B620B630B820BBE-0BC20BC6-0BC80BCA-0BCD0BD70C01-0C030C3E-0C440C46-0C480C4A-0C4D0C550C560C620C630C820C830CBC0CBE-0CC40CC6-0CC80CCA-0CCD0CD50CD60CE20CE30D020D030D3E-0D440D46-0D480D4A-0D4D0D570D620D630D820D830DCA0DCF-0DD40DD60DD8-0DDF0DF20DF30E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F3E0F3F0F71-0F840F860F870F90-0F970F99-0FBC0FC6102B-103E1056-1059105E-10601062-10641067-106D1071-10741082-108D108F109A-109D135F1712-17141732-1734175217531772177317B6-17D317DD180B-180D18A91920-192B1930-193B19B0-19C019C819C91A17-1A1B1A55-1A5E1A60-1A7C1A7F1B00-1B041B34-1B441B6B-1B731B80-1B821BA1-1BAA1C24-1C371CD0-1CD21CD4-1CE81CED1CF21DC0-1DE61DFD-1DFF20D0-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66F-A672A67CA67DA6F0A6F1A802A806A80BA823-A827A880A881A8B4-A8C4A8E0-A8F1A926-A92DA947-A953A980-A983A9B3-A9C0AA29-AA36AA43AA4CAA4DAA7BAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE3-ABEAABECABEDFB1EFE00-FE0FFE20-FE26",
		    Mn: "0300-036F0483-04870591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DF-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0902093C0941-0948094D0951-095509620963098109BC09C1-09C409CD09E209E30A010A020A3C0A410A420A470A480A4B-0A4D0A510A700A710A750A810A820ABC0AC1-0AC50AC70AC80ACD0AE20AE30B010B3C0B3F0B41-0B440B4D0B560B620B630B820BC00BCD0C3E-0C400C46-0C480C4A-0C4D0C550C560C620C630CBC0CBF0CC60CCC0CCD0CE20CE30D41-0D440D4D0D620D630DCA0DD2-0DD40DD60E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F71-0F7E0F80-0F840F860F870F90-0F970F99-0FBC0FC6102D-10301032-10371039103A103D103E10581059105E-10601071-1074108210851086108D109D135F1712-17141732-1734175217531772177317B7-17BD17C617C9-17D317DD180B-180D18A91920-19221927192819321939-193B1A171A181A561A58-1A5E1A601A621A65-1A6C1A73-1A7C1A7F1B00-1B031B341B36-1B3A1B3C1B421B6B-1B731B801B811BA2-1BA51BA81BA91C2C-1C331C361C371CD0-1CD21CD4-1CE01CE2-1CE81CED1DC0-1DE61DFD-1DFF20D0-20DC20E120E5-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66FA67CA67DA6F0A6F1A802A806A80BA825A826A8C4A8E0-A8F1A926-A92DA947-A951A980-A982A9B3A9B6-A9B9A9BCAA29-AA2EAA31AA32AA35AA36AA43AA4CAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE5ABE8ABEDFB1EFE00-FE0FFE20-FE26",
		    Mc: "0903093E-09400949-094C094E0982098309BE-09C009C709C809CB09CC09D70A030A3E-0A400A830ABE-0AC00AC90ACB0ACC0B020B030B3E0B400B470B480B4B0B4C0B570BBE0BBF0BC10BC20BC6-0BC80BCA-0BCC0BD70C01-0C030C41-0C440C820C830CBE0CC0-0CC40CC70CC80CCA0CCB0CD50CD60D020D030D3E-0D400D46-0D480D4A-0D4C0D570D820D830DCF-0DD10DD8-0DDF0DF20DF30F3E0F3F0F7F102B102C10311038103B103C105610571062-10641067-106D108310841087-108C108F109A-109C17B617BE-17C517C717C81923-19261929-192B193019311933-193819B0-19C019C819C91A19-1A1B1A551A571A611A631A641A6D-1A721B041B351B3B1B3D-1B411B431B441B821BA11BA61BA71BAA1C24-1C2B1C341C351CE11CF2A823A824A827A880A881A8B4-A8C3A952A953A983A9B4A9B5A9BAA9BBA9BD-A9C0AA2FAA30AA33AA34AA4DAA7BABE3ABE4ABE6ABE7ABE9ABEAABEC",
		    Me: "0488048906DE20DD-20E020E2-20E4A670-A672",
		    N:  "0030-003900B200B300B900BC-00BE0660-066906F0-06F907C0-07C90966-096F09E6-09EF09F4-09F90A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BF20C66-0C6F0C78-0C7E0CE6-0CEF0D66-0D750E50-0E590ED0-0ED90F20-0F331040-10491090-10991369-137C16EE-16F017E0-17E917F0-17F91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C5920702074-20792080-20892150-21822185-21892460-249B24EA-24FF2776-27932CFD30073021-30293038-303A3192-31953220-32293251-325F3280-328932B1-32BFA620-A629A6E6-A6EFA830-A835A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
		    Nd: "0030-00390660-066906F0-06F907C0-07C90966-096F09E6-09EF0A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BEF0C66-0C6F0CE6-0CEF0D66-0D6F0E50-0E590ED0-0ED90F20-0F291040-10491090-109917E0-17E91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C59A620-A629A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
		    Nl: "16EE-16F02160-21822185-218830073021-30293038-303AA6E6-A6EF",
		    No: "00B200B300B900BC-00BE09F4-09F90BF0-0BF20C78-0C7E0D70-0D750F2A-0F331369-137C17F0-17F920702074-20792080-20892150-215F21892460-249B24EA-24FF2776-27932CFD3192-31953220-32293251-325F3280-328932B1-32BFA830-A835",
		    P:  "0021-00230025-002A002C-002F003A003B003F0040005B-005D005F007B007D00A100AB00B700BB00BF037E0387055A-055F0589058A05BE05C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F3A-0F3D0F850FD0-0FD4104A-104F10FB1361-13681400166D166E169B169C16EB-16ED1735173617D4-17D617D8-17DA1800-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD32010-20272030-20432045-20512053-205E207D207E208D208E2329232A2768-277527C527C627E6-27EF2983-299829D8-29DB29FC29FD2CF9-2CFC2CFE2CFF2E00-2E2E2E302E313001-30033008-30113014-301F3030303D30A030FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFD3EFD3FFE10-FE19FE30-FE52FE54-FE61FE63FE68FE6AFE6BFF01-FF03FF05-FF0AFF0C-FF0FFF1AFF1BFF1FFF20FF3B-FF3DFF3FFF5BFF5DFF5F-FF65",
		    Pd: "002D058A05BE140018062010-20152E172E1A301C303030A0FE31FE32FE58FE63FF0D",
		    Ps: "0028005B007B0F3A0F3C169B201A201E2045207D208D23292768276A276C276E27702772277427C527E627E827EA27EC27EE2983298529872989298B298D298F299129932995299729D829DA29FC2E222E242E262E283008300A300C300E3010301430163018301A301DFD3EFE17FE35FE37FE39FE3BFE3DFE3FFE41FE43FE47FE59FE5BFE5DFF08FF3BFF5BFF5FFF62",
		    Pe: "0029005D007D0F3B0F3D169C2046207E208E232A2769276B276D276F27712773277527C627E727E927EB27ED27EF298429862988298A298C298E2990299229942996299829D929DB29FD2E232E252E272E293009300B300D300F3011301530173019301B301E301FFD3FFE18FE36FE38FE3AFE3CFE3EFE40FE42FE44FE48FE5AFE5CFE5EFF09FF3DFF5DFF60FF63",
		    Pi: "00AB2018201B201C201F20392E022E042E092E0C2E1C2E20",
		    Pf: "00BB2019201D203A2E032E052E0A2E0D2E1D2E21",
		    Pc: "005F203F20402054FE33FE34FE4D-FE4FFF3F",
		    Po: "0021-00230025-0027002A002C002E002F003A003B003F0040005C00A100B700BF037E0387055A-055F058905C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F850FD0-0FD4104A-104F10FB1361-1368166D166E16EB-16ED1735173617D4-17D617D8-17DA1800-18051807-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD3201620172020-20272030-2038203B-203E2041-20432047-205120532055-205E2CF9-2CFC2CFE2CFF2E002E012E06-2E082E0B2E0E-2E162E182E192E1B2E1E2E1F2E2A-2E2E2E302E313001-3003303D30FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFE10-FE16FE19FE30FE45FE46FE49-FE4CFE50-FE52FE54-FE57FE5F-FE61FE68FE6AFE6BFF01-FF03FF05-FF07FF0AFF0CFF0EFF0FFF1AFF1BFF1FFF20FF3CFF61FF64FF65",
		    S:  "0024002B003C-003E005E0060007C007E00A2-00A900AC00AE-00B100B400B600B800D700F702C2-02C502D2-02DF02E5-02EB02ED02EF-02FF03750384038503F604820606-0608060B060E060F06E906FD06FE07F609F209F309FA09FB0AF10B700BF3-0BFA0C7F0CF10CF20D790E3F0F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-139917DB194019E0-19FF1B61-1B6A1B74-1B7C1FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE20442052207A-207C208A-208C20A0-20B8210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B2140-2144214A-214D214F2190-2328232B-23E82400-24262440-244A249C-24E92500-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE27C0-27C427C7-27CA27CC27D0-27E527F0-29822999-29D729DC-29FB29FE-2B4C2B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F309B309C319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A700-A716A720A721A789A78AA828-A82BA836-A839AA77-AA79FB29FDFCFDFDFE62FE64-FE66FE69FF04FF0BFF1C-FF1EFF3EFF40FF5CFF5EFFE0-FFE6FFE8-FFEEFFFCFFFD",
		    Sm: "002B003C-003E007C007E00AC00B100D700F703F60606-060820442052207A-207C208A-208C2140-2144214B2190-2194219A219B21A021A321A621AE21CE21CF21D221D421F4-22FF2308-230B23202321237C239B-23B323DC-23E125B725C125F8-25FF266F27C0-27C427C7-27CA27CC27D0-27E527F0-27FF2900-29822999-29D729DC-29FB29FE-2AFF2B30-2B442B47-2B4CFB29FE62FE64-FE66FF0BFF1C-FF1EFF5CFF5EFFE2FFE9-FFEC",
		    Sc: "002400A2-00A5060B09F209F309FB0AF10BF90E3F17DB20A0-20B8A838FDFCFE69FF04FFE0FFE1FFE5FFE6",
		    Sk: "005E006000A800AF00B400B802C2-02C502D2-02DF02E5-02EB02ED02EF-02FF0375038403851FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE309B309CA700-A716A720A721A789A78AFF3EFF40FFE3",
		    So: "00A600A700A900AE00B000B60482060E060F06E906FD06FE07F609FA0B700BF3-0BF80BFA0C7F0CF10CF20D790F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-1399194019E0-19FF1B61-1B6A1B74-1B7C210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B214A214C214D214F2195-2199219C-219F21A121A221A421A521A7-21AD21AF-21CD21D021D121D321D5-21F32300-2307230C-231F2322-2328232B-237B237D-239A23B4-23DB23E2-23E82400-24262440-244A249C-24E92500-25B625B8-25C025C2-25F72600-266E2670-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE2800-28FF2B00-2B2F2B452B462B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A828-A82BA836A837A839AA77-AA79FDFDFFE4FFE8FFEDFFEEFFFCFFFD",
		    Z:  "002000A01680180E2000-200A20282029202F205F3000",
		    Zs: "002000A01680180E2000-200A202F205F3000",
		    Zl: "2028",
		    Zp: "2029",
		    C:  "0000-001F007F-009F00AD03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-0605061C061D0620065F06DD070E070F074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17B417B517DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF200B-200F202A-202E2060-206F20722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-F8FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFD-FF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFFBFFFEFFFF",
		    Cc: "0000-001F007F-009F",
		    Cf: "00AD0600-060306DD070F17B417B5200B-200F202A-202E2060-2064206A-206FFEFFFFF9-FFFB",
		    Co: "E000-F8FF",
		    Cs: "D800-DFFF",
		    Cn: "03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-05FF06040605061C061D0620065F070E074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF2065-206920722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-D7FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFDFEFEFF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFF8FFFEFFFF"
		});
		
		function addUnicodePackage (pack) {
		    var codePoint = /\w{4}/g;
		    for (var name in pack)
		        exports.packages[name] = pack[name].replace(codePoint, "\\u$&");
		}
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/virtual_renderer.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var oop = require("./lib/oop");
		var dom = require("./lib/dom");
		var config = require("./config");
		var useragent = require("./lib/useragent");
		var GutterLayer = require("./layer/gutter").Gutter;
		var MarkerLayer = require("./layer/marker").Marker;
		var TextLayer = require("./layer/text").Text;
		var CursorLayer = require("./layer/cursor").Cursor;
		var HScrollBar = require("./scrollbar").HScrollBar;
		var VScrollBar = require("./scrollbar").VScrollBar;
		var RenderLoop = require("./renderloop").RenderLoop;
		var FontMetrics = require("./layer/font_metrics").FontMetrics;
		var EventEmitter = require("./lib/event_emitter").EventEmitter;
		var editorCss = require("./css/editor.css");
		dom.importCssString(editorCss, "ace_editor.css");
		
		/**
		 * The class that is responsible for drawing everything you see on the screen!
		 * @related editor.renderer 
		 * @class VirtualRenderer
		 **/
		
		/**
		 * Constructs a new `VirtualRenderer` within the `container` specified, applying the given `theme`.
		 * @param {DOMElement} container The root element of the editor
		 * @param {String} theme The starting theme
		 *
		 * @constructor
		 **/
		
		var VirtualRenderer = function(container, theme) {
		    var _self = this;
		
		    this.container = container || dom.createElement("div");
		
		    // TODO: this breaks rendering in Cloud9 with multiple ace instances
		    // // Imports CSS once per DOM document ('ace_editor' serves as an identifier).
		    // dom.importCssString(editorCss, "ace_editor", container.ownerDocument);
		
		    // in IE <= 9 the native cursor always shines through
		    this.$keepTextAreaAtCursor = !useragent.isOldIE;
		
		    dom.addCssClass(this.container, "ace_editor");
		
		    this.setTheme(theme);
		
		    this.$gutter = dom.createElement("div");
		    this.$gutter.className = "ace_gutter";
		    this.container.appendChild(this.$gutter);
		
		    this.scroller = dom.createElement("div");
		    this.scroller.className = "ace_scroller";
		    this.container.appendChild(this.scroller);
		
		    this.content = dom.createElement("div");
		    this.content.className = "ace_content";
		    this.scroller.appendChild(this.content);
		
		    this.$gutterLayer = new GutterLayer(this.$gutter);
		    this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this));
		
		    this.$markerBack = new MarkerLayer(this.content);
		
		    var textLayer = this.$textLayer = new TextLayer(this.content);
		    this.canvas = textLayer.element;
		
		    this.$markerFront = new MarkerLayer(this.content);
		
		    this.$cursorLayer = new CursorLayer(this.content);
		
		    // Indicates whether the horizontal scrollbar is visible
		    this.$horizScroll = false;
		    this.$vScroll = false;
		
		    this.scrollBar = 
		    this.scrollBarV = new VScrollBar(this.container, this);
		    this.scrollBarH = new HScrollBar(this.container, this);
		    this.scrollBarV.addEventListener("scroll", function(e) {
		        if (!_self.$scrollAnimation)
		            _self.session.setScrollTop(e.data - _self.scrollMargin.top);
		    });
		    this.scrollBarH.addEventListener("scroll", function(e) {
		        if (!_self.$scrollAnimation)
		            _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
		    });
		
		    this.scrollTop = 0;
		    this.scrollLeft = 0;
		
		    this.cursorPos = {
		        row : 0,
		        column : 0
		    };
		
		    this.$fontMetrics = new FontMetrics(this.container);
		    this.$textLayer.$setFontMetrics(this.$fontMetrics);
		    this.$textLayer.addEventListener("changeCharacterSize", function(e) {
		        _self.updateCharacterSize();
		        _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);
		        _self._signal("changeCharacterSize", e);
		    });
		
		    this.$size = {
		        width: 0,
		        height: 0,
		        scrollerHeight: 0,
		        scrollerWidth: 0,
		        $dirty: true
		    };
		
		    this.layerConfig = {
		        width : 1,
		        padding : 0,
		        firstRow : 0,
		        firstRowScreen: 0,
		        lastRow : 0,
		        lineHeight : 0,
		        characterWidth : 0,
		        minHeight : 1,
		        maxHeight : 1,
		        offset : 0,
		        height : 1,
		        gutterOffset: 1
		    };
		    
		    this.scrollMargin = {
		        left: 0,
		        right: 0,
		        top: 0,
		        bottom: 0,
		        v: 0,
		        h: 0
		    };
		
		    this.$loop = new RenderLoop(
		        this.$renderChanges.bind(this),
		        this.container.ownerDocument.defaultView
		    );
		    this.$loop.schedule(this.CHANGE_FULL);
		
		    this.updateCharacterSize();
		    this.setPadding(4);
		    config.resetOptions(this);
		    config._emit("renderer", this);
		};
		
		(function() {
		
		    this.CHANGE_CURSOR = 1;
		    this.CHANGE_MARKER = 2;
		    this.CHANGE_GUTTER = 4;
		    this.CHANGE_SCROLL = 8;
		    this.CHANGE_LINES = 16;
		    this.CHANGE_TEXT = 32;
		    this.CHANGE_SIZE = 64;
		    this.CHANGE_MARKER_BACK = 128;
		    this.CHANGE_MARKER_FRONT = 256;
		    this.CHANGE_FULL = 512;
		    this.CHANGE_H_SCROLL = 1024;
		
		    // this.$logChanges = function(changes) {
		    //     var a = ""
		    //     if (changes & this.CHANGE_CURSOR) a += " cursor";
		    //     if (changes & this.CHANGE_MARKER) a += " marker";
		    //     if (changes & this.CHANGE_GUTTER) a += " gutter";
		    //     if (changes & this.CHANGE_SCROLL) a += " scroll";
		    //     if (changes & this.CHANGE_LINES) a += " lines";
		    //     if (changes & this.CHANGE_TEXT) a += " text";
		    //     if (changes & this.CHANGE_SIZE) a += " size";
		    //     if (changes & this.CHANGE_MARKER_BACK) a += " marker_back";
		    //     if (changes & this.CHANGE_MARKER_FRONT) a += " marker_front";
		    //     if (changes & this.CHANGE_FULL) a += " full";
		    //     if (changes & this.CHANGE_H_SCROLL) a += " h_scroll";
		    //     console.log(a.trim())
		    // };
		
		    oop.implement(this, EventEmitter);
		
		    this.updateCharacterSize = function() {
		        if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {
		            this.$allowBoldFonts = this.$textLayer.allowBoldFonts;
		            this.setStyle("ace_nobold", !this.$allowBoldFonts);
		        }
		
		        this.layerConfig.characterWidth =
		        this.characterWidth = this.$textLayer.getCharacterWidth();
		        this.layerConfig.lineHeight =
		        this.lineHeight = this.$textLayer.getLineHeight();
		        this.$updatePrintMargin();
		    };
		
		    /**
		     *
		     * Associates the renderer with an [[EditSession `EditSession`]].
		     **/
		    this.setSession = function(session) {
		        if (this.session)
		            this.session.doc.off("changeNewLineMode", this.onChangeNewLineMode);
		            
		        this.session = session;
		        if (session && this.scrollMargin.top && session.getScrollTop() <= 0)
		            session.setScrollTop(-this.scrollMargin.top);
		
		        this.$cursorLayer.setSession(session);
		        this.$markerBack.setSession(session);
		        this.$markerFront.setSession(session);
		        this.$gutterLayer.setSession(session);
		        this.$textLayer.setSession(session);
		        if (!session)
		            return;
		        
		        this.$loop.schedule(this.CHANGE_FULL);
		        this.session.$setFontMetrics(this.$fontMetrics);
		        
		        this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
		        this.onChangeNewLineMode()
		        this.session.doc.on("changeNewLineMode", this.onChangeNewLineMode);
		    };
		
		    /**
		     * Triggers a partial update of the text, from the range given by the two parameters.
		     * @param {Number} firstRow The first row to update
		     * @param {Number} lastRow The last row to update
		     *
		     **/
		    this.updateLines = function(firstRow, lastRow, force) {
		        if (lastRow === undefined)
		            lastRow = Infinity;
		
		        if (!this.$changedLines) {
		            this.$changedLines = {
		                firstRow: firstRow,
		                lastRow: lastRow
		            };
		        }
		        else {
		            if (this.$changedLines.firstRow > firstRow)
		                this.$changedLines.firstRow = firstRow;
		
		            if (this.$changedLines.lastRow < lastRow)
		                this.$changedLines.lastRow = lastRow;
		        }
		
		        // If the change happened offscreen above us then it's possible
		        // that a new line wrap will affect the position of the lines on our
		        // screen so they need redrawn.
		        // TODO: better solution is to not change scroll position when text is changed outside of visible area
		        if (this.$changedLines.lastRow < this.layerConfig.firstRow) {
		            if (force)
		                this.$changedLines.lastRow = this.layerConfig.lastRow;
		            else
		                return;
		        }
		        if (this.$changedLines.firstRow > this.layerConfig.lastRow)
		            return;
		        this.$loop.schedule(this.CHANGE_LINES);
		    };
		
		    this.onChangeNewLineMode = function() {
		        this.$loop.schedule(this.CHANGE_TEXT);
		        this.$textLayer.$updateEolChar();
		    };
		    
		    this.onChangeTabSize = function() {
		        this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);
		        this.$textLayer.onChangeTabSize();
		    };
		
		    /**
		     * Triggers a full update of the text, for all the rows.
		     **/
		    this.updateText = function() {
		        this.$loop.schedule(this.CHANGE_TEXT);
		    };
		
		    /**
		     * Triggers a full update of all the layers, for all the rows.
		     * @param {Boolean} force If `true`, forces the changes through
		     *
		     **/
		    this.updateFull = function(force) {
		        if (force)
		            this.$renderChanges(this.CHANGE_FULL, true);
		        else
		            this.$loop.schedule(this.CHANGE_FULL);
		    };
		
		    /**
		     * Updates the font size.
		     **/
		    this.updateFontSize = function() {
		        this.$textLayer.checkForSizeChanges();
		    };
		
		    this.$changes = 0;
		    this.$updateSizeAsync = function() {
		        if (this.$loop.pending)
		            this.$size.$dirty = true;
		        else
		            this.onResize();
		    };
		    /**
		     * [Triggers a resize of the editor.]{: #VirtualRenderer.onResize}
		     * @param {Boolean} force If `true`, recomputes the size, even if the height and width haven't changed
		     * @param {Number} gutterWidth The width of the gutter in pixels
		     * @param {Number} width The width of the editor in pixels
		     * @param {Number} height The hiehgt of the editor, in pixels
		     *
		     **/
		    this.onResize = function(force, gutterWidth, width, height) {
		        if (this.resizing > 2)
		            return;
		        else if (this.resizing > 0)
		            this.resizing++;
		        else
		            this.resizing = force ? 1 : 0;
		        // `|| el.scrollHeight` is required for outosizing editors on ie
		        // where elements with clientHeight = 0 alsoe have clientWidth = 0
		        var el = this.container;
		        if (!height)
		            height = el.clientHeight || el.scrollHeight;
		        if (!width)
		            width = el.clientWidth || el.scrollWidth;
		        var changes = this.$updateCachedSize(force, gutterWidth, width, height);
		
		        
		        if (!this.$size.scrollerHeight || (!width && !height))
		            return this.resizing = 0;
		
		        if (force)
		            this.$gutterLayer.$padding = null;
		
		        if (force)
		            this.$renderChanges(changes | this.$changes, true);
		        else
		            this.$loop.schedule(changes | this.$changes);
		
		        if (this.resizing)
		            this.resizing = 0;
		        // reset cached values on scrollbars, needs to be removed when switching to non-native scrollbars
		        // see https://github.com/ajaxorg/ace/issues/2195
		        this.scrollBarV.scrollLeft = this.scrollBarV.scrollTop = null;
		    };
		    
		    this.$updateCachedSize = function(force, gutterWidth, width, height) {
		        height -= (this.$extraHeight || 0);
		        var changes = 0;
		        var size = this.$size;
		        var oldSize = {
		            width: size.width,
		            height: size.height,
		            scrollerHeight: size.scrollerHeight,
		            scrollerWidth: size.scrollerWidth
		        };
		        if (height && (force || size.height != height)) {
		            size.height = height;
		            changes |= this.CHANGE_SIZE;
		
		            size.scrollerHeight = size.height;
		            if (this.$horizScroll)
		                size.scrollerHeight -= this.scrollBarH.getHeight();
		                
		            // this.scrollBarV.setHeight(size.scrollerHeight);
		            this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px";
		
		            changes = changes | this.CHANGE_SCROLL;
		        }
		
		        if (width && (force || size.width != width)) {
		            changes |= this.CHANGE_SIZE;
		            size.width = width;
		            
		            if (gutterWidth == null)
		                gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
		            
		            this.gutterWidth = gutterWidth;
		            
		            this.scrollBarH.element.style.left = 
		            this.scroller.style.left = gutterWidth + "px";
		            size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth());           
		            
		            this.scrollBarH.element.style.right = 
		            this.scroller.style.right = this.scrollBarV.getWidth() + "px";
		            this.scroller.style.bottom = this.scrollBarH.getHeight() + "px";
		                
		            // this.scrollBarH.element.style.setWidth(size.scrollerWidth);
		
		            if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force)
		                changes |= this.CHANGE_FULL;
		        }
		        
		        size.$dirty = !width || !height;
		
		        if (changes)
		            this._signal("resize", oldSize);
		
		        return changes;
		    };
		
		    this.onGutterResize = function() {
		        var gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
		        if (gutterWidth != this.gutterWidth)
		            this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);
		
		        if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {
		            this.$loop.schedule(this.CHANGE_FULL);
		        } else if (this.$size.$dirty) {
		            this.$loop.schedule(this.CHANGE_FULL);
		        } else {
		            this.$computeLayerConfig();
		            this.$loop.schedule(this.CHANGE_MARKER);
		        }
		    };
		
		    /**
		     * Adjusts the wrap limit, which is the number of characters that can fit within the width of the edit area on screen.
		     **/
		    this.adjustWrapLimit = function() {
		        var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
		        var limit = Math.floor(availableWidth / this.characterWidth);
		        return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);
		    };
		
		    /**
		     * Identifies whether you want to have an animated scroll or not.
		     * @param {Boolean} shouldAnimate Set to `true` to show animated scrolls
		     *
		     **/
		    this.setAnimatedScroll = function(shouldAnimate){
		        this.setOption("animatedScroll", shouldAnimate);
		    };
		
		    /**
		     * Returns whether an animated scroll happens or not.
		     * @returns {Boolean}
		     **/
		    this.getAnimatedScroll = function() {
		        return this.$animatedScroll;
		    };
		
		    /**
		     * Identifies whether you want to show invisible characters or not.
		     * @param {Boolean} showInvisibles Set to `true` to show invisibles
		     *
		     **/
		    this.setShowInvisibles = function(showInvisibles) {
		        this.setOption("showInvisibles", showInvisibles);
		    };
		
		    /**
		     * Returns whether invisible characters are being shown or not.
		     * @returns {Boolean}
		     **/
		    this.getShowInvisibles = function() {
		        return this.getOption("showInvisibles");
		    };
		    this.getDisplayIndentGuides = function() {
		        return this.getOption("displayIndentGuides");
		    };
		
		    this.setDisplayIndentGuides = function(display) {
		        this.setOption("displayIndentGuides", display);
		    };
		
		    /**
		     * Identifies whether you want to show the print margin or not.
		     * @param {Boolean} showPrintMargin Set to `true` to show the print margin
		     *
		     **/
		    this.setShowPrintMargin = function(showPrintMargin) {
		        this.setOption("showPrintMargin", showPrintMargin);
		    };
		
		    /**
		     * Returns whether the print margin is being shown or not.
		     * @returns {Boolean}
		     **/
		    this.getShowPrintMargin = function() {
		        return this.getOption("showPrintMargin");
		    };
		    /**
		     * Identifies whether you want to show the print margin column or not.
		     * @param {Boolean} showPrintMargin Set to `true` to show the print margin column
		     *
		     **/
		    this.setPrintMarginColumn = function(showPrintMargin) {
		        this.setOption("printMarginColumn", showPrintMargin);
		    };
		
		    /**
		     * Returns whether the print margin column is being shown or not.
		     * @returns {Boolean}
		     **/
		    this.getPrintMarginColumn = function() {
		        return this.getOption("printMarginColumn");
		    };
		
		    /**
		     * Returns `true` if the gutter is being shown.
		     * @returns {Boolean}
		     **/
		    this.getShowGutter = function(){
		        return this.getOption("showGutter");
		    };
		
		    /**
		     * Identifies whether you want to show the gutter or not.
		     * @param {Boolean} show Set to `true` to show the gutter
		     *
		     **/
		    this.setShowGutter = function(show){
		        return this.setOption("showGutter", show);
		    };
		
		    this.getFadeFoldWidgets = function(){
		        return this.getOption("fadeFoldWidgets")
		    };
		
		    this.setFadeFoldWidgets = function(show) {
		        this.setOption("fadeFoldWidgets", show);
		    };
		
		    this.setHighlightGutterLine = function(shouldHighlight) {
		        this.setOption("highlightGutterLine", shouldHighlight);
		    };
		
		    this.getHighlightGutterLine = function() {
		        return this.getOption("highlightGutterLine");
		    };
		
		    this.$updateGutterLineHighlight = function() {
		        var pos = this.$cursorLayer.$pixelPos;
		        var height = this.layerConfig.lineHeight;
		        if (this.session.getUseWrapMode()) {
		            var cursor = this.session.selection.getCursor();
		            cursor.column = 0;
		            pos = this.$cursorLayer.getPixelPosition(cursor, true);
		            height *= this.session.getRowLength(cursor.row);
		        }
		        this.$gutterLineHighlight.style.top = pos.top - this.layerConfig.offset + "px";
		        this.$gutterLineHighlight.style.height = height + "px";
		    };
		
		    this.$updatePrintMargin = function() {
		        if (!this.$showPrintMargin && !this.$printMarginEl)
		            return;
		
		        if (!this.$printMarginEl) {
		            var containerEl = dom.createElement("div");
		            containerEl.className = "ace_layer ace_print-margin-layer";
		            this.$printMarginEl = dom.createElement("div");
		            this.$printMarginEl.className = "ace_print-margin";
		            containerEl.appendChild(this.$printMarginEl);
		            this.content.insertBefore(containerEl, this.content.firstChild);
		        }
		
		        var style = this.$printMarginEl.style;
		        style.left = ((this.characterWidth * this.$printMarginColumn) + this.$padding) + "px";
		        style.visibility = this.$showPrintMargin ? "visible" : "hidden";
		        
		        if (this.session && this.session.$wrap == -1)
		            this.adjustWrapLimit();
		    };
		
		    /**
		     *
		     * Returns the root element containing this renderer.
		     * @returns {DOMElement}
		     **/
		    this.getContainerElement = function() {
		        return this.container;
		    };
		
		    /**
		     *
		     * Returns the element that the mouse events are attached to
		     * @returns {DOMElement}
		     **/
		    this.getMouseEventTarget = function() {
		        return this.scroller;
		    };
		
		    /**
		     *
		     * Returns the element to which the hidden text area is added.
		     * @returns {DOMElement}
		     **/
		    this.getTextAreaContainer = function() {
		        return this.container;
		    };
		
		    // move text input over the cursor
		    // this is required for iOS and IME
		    this.$moveTextAreaToCursor = function() {
		        if (!this.$keepTextAreaAtCursor)
		            return;
		        var config = this.layerConfig;
		        var posTop = this.$cursorLayer.$pixelPos.top;
		        var posLeft = this.$cursorLayer.$pixelPos.left;
		        posTop -= config.offset;
		
		        var style = this.textarea.style;
		        var h = this.lineHeight;
		        if (posTop < 0 || posTop > config.height - h) {
		            style.top = style.left = "0";
		            return;
		        }
		
		        var w = this.characterWidth;
		        if (this.$composition) {
		            var val = this.textarea.value.replace(/^\x01+/, "");
		            w *= (this.session.$getStringScreenWidth(val)[0]+2);
		            h += 2;
		        }
		        posLeft -= this.scrollLeft;
		        if (posLeft > this.$size.scrollerWidth - w)
		            posLeft = this.$size.scrollerWidth - w;
		
		        posLeft += this.gutterWidth;
		        style.height = h + "px";
		        style.width = w + "px";
		        style.left = Math.min(posLeft, this.$size.scrollerWidth - w) + "px";
		        style.top = Math.min(posTop, this.$size.height - h) + "px";
		    };
		
		    /**
		     * [Returns the index of the first visible row.]{: #VirtualRenderer.getFirstVisibleRow}
		     * @returns {Number}
		     **/
		    this.getFirstVisibleRow = function() {
		        return this.layerConfig.firstRow;
		    };
		
		    /**
		     *
		     * Returns the index of the first fully visible row. "Fully" here means that the characters in the row are not truncated; that the top and the bottom of the row are on the screen.
		     * @returns {Number}
		     **/
		    this.getFirstFullyVisibleRow = function() {
		        return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
		    };
		
		    /**
		     *
		     * Returns the index of the last fully visible row. "Fully" here means that the characters in the row are not truncated; that the top and the bottom of the row are on the screen.
		     * @returns {Number}
		     **/
		    this.getLastFullyVisibleRow = function() {
		        var config = this.layerConfig;
		        var lastRow = config.lastRow
		        var top = this.session.documentToScreenRow(lastRow, 0) * config.lineHeight;
		        if (top - this.session.getScrollTop() > config.height - config.lineHeight)
		            return lastRow - 1;
		        return lastRow;
		    };
		
		    /**
		     *
		     * [Returns the index of the last visible row.]{: #VirtualRenderer.getLastVisibleRow}
		     * @returns {Number}
		     **/
		    this.getLastVisibleRow = function() {
		        return this.layerConfig.lastRow;
		    };
		
		    this.$padding = null;
		
		    /**
		     * Sets the padding for all the layers.
		     * @param {Number} padding A new padding value (in pixels)
		     *
		     **/
		    this.setPadding = function(padding) {
		        this.$padding = padding;
		        this.$textLayer.setPadding(padding);
		        this.$cursorLayer.setPadding(padding);
		        this.$markerFront.setPadding(padding);
		        this.$markerBack.setPadding(padding);
		        this.$loop.schedule(this.CHANGE_FULL);
		        this.$updatePrintMargin();
		    };
		    
		    this.setScrollMargin = function(top, bottom, left, right) {
		        var sm = this.scrollMargin;
		        sm.top = top|0;
		        sm.bottom = bottom|0;
		        sm.right = right|0;
		        sm.left = left|0;
		        sm.v = sm.top + sm.bottom;
		        sm.h = sm.left + sm.right;
		        if (sm.top && this.scrollTop <= 0 && this.session)
		            this.session.setScrollTop(-sm.top);
		        this.updateFull();
		    };
		
		    /**
		     * Returns whether the horizontal scrollbar is set to be always visible.
		     * @returns {Boolean}
		     **/
		    this.getHScrollBarAlwaysVisible = function() {
		        return this.$hScrollBarAlwaysVisible;
		    };
		
		    /**
		     * Identifies whether you want to show the horizontal scrollbar or not.
		     * @param {Boolean} alwaysVisible Set to `true` to make the horizontal scroll bar visible
		     **/
		    this.setHScrollBarAlwaysVisible = function(alwaysVisible) {
		        this.setOption("hScrollBarAlwaysVisible", alwaysVisible);
		    };
		    /**
		     * Returns whether the horizontal scrollbar is set to be always visible.
		     * @returns {Boolean}
		     **/
		    this.getVScrollBarAlwaysVisible = function() {
		        return this.$vScrollBarAlwaysVisible;
		    };
		
		    /**
		     * Identifies whether you want to show the horizontal scrollbar or not.
		     * @param {Boolean} alwaysVisible Set to `true` to make the horizontal scroll bar visible
		     **/
		    this.setVScrollBarAlwaysVisible = function(alwaysVisible) {
		        this.setOption("vScrollBarAlwaysVisible", alwaysVisible);
		    };
		
		    this.$updateScrollBarV = function() {
		        var scrollHeight = this.layerConfig.maxHeight;
		        var scrollerHeight = this.$size.scrollerHeight;
		        if (!this.$maxLines && this.$scrollPastEnd) {
		            scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
		            if (this.scrollTop > scrollHeight - scrollerHeight) {
		                scrollHeight = this.scrollTop + scrollerHeight;
		                this.scrollBarV.scrollTop = null;
		            }
		        }
		        this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);
		        this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
		    };
		    this.$updateScrollBarH = function() {
		        this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
		        this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
		    };
		    
		    this.$frozen = false;
		    this.freeze = function() {
		        this.$frozen = true;
		    };
		    
		    this.unfreeze = function() {
		        this.$frozen = false;
		    };
		
		    this.$renderChanges = function(changes, force) {
		        if (this.$changes) {
		            changes |= this.$changes;
		            this.$changes = 0;
		        }
		        if ((!this.session || !this.container.offsetWidth || this.$frozen) || (!changes && !force)) {
		            this.$changes |= changes;
		            return; 
		        } 
		        if (this.$size.$dirty) {
		            this.$changes |= changes;
		            return this.onResize(true);
		        }
		        if (!this.lineHeight) {
		            this.$textLayer.checkForSizeChanges();
		        }
		        // this.$logChanges(changes);
		        
		        this._signal("beforeRender");
		        var config = this.layerConfig;
		        // text, scrolling and resize changes can cause the view port size to change
		        if (changes & this.CHANGE_FULL ||
		            changes & this.CHANGE_SIZE ||
		            changes & this.CHANGE_TEXT ||
		            changes & this.CHANGE_LINES ||
		            changes & this.CHANGE_SCROLL ||
		            changes & this.CHANGE_H_SCROLL
		        ) {
		            changes |= this.$computeLayerConfig();
		            // If a change is made offscreen and wrapMode is on, then the onscreen
		            // lines may have been pushed down. If so, the first screen row will not
		            // have changed, but the first actual row will. In that case, adjust 
		            // scrollTop so that the cursor and onscreen content stays in the same place.
		            // TODO: find a better way to handle this, that works non wrapped case and doesn't compute layerConfig twice
		            if (config.firstRow != this.layerConfig.firstRow && config.firstRowScreen == this.layerConfig.firstRowScreen) {
		                var st = this.scrollTop + (config.firstRow - this.layerConfig.firstRow) * this.lineHeight;
		                if (st > 0) {
		                    // this check is needed as a workaround for the documentToScreenRow returning -1 if document.length == 0
		                    this.scrollTop = st;
		                    changes = changes | this.CHANGE_SCROLL;
		                    changes |= this.$computeLayerConfig();
		                }
		            }
		            config = this.layerConfig;
		            // update scrollbar first to not lose scroll position when gutter calls resize
		            this.$updateScrollBarV();
		            if (changes & this.CHANGE_H_SCROLL)
		                this.$updateScrollBarH();
		            this.$gutterLayer.element.style.marginTop = (-config.offset) + "px";
		            this.content.style.marginTop = (-config.offset) + "px";
		            this.content.style.width = config.width + 2 * this.$padding + "px";
		            this.content.style.height = config.minHeight + "px";
		        }
		        
		        // horizontal scrolling
		        if (changes & this.CHANGE_H_SCROLL) {
		            this.content.style.marginLeft = -this.scrollLeft + "px";
		            this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller" : "ace_scroller ace_scroll-left";
		        }
		
		        // full
		        if (changes & this.CHANGE_FULL) {
		            this.$textLayer.update(config);
		            if (this.$showGutter)
		                this.$gutterLayer.update(config);
		            this.$markerBack.update(config);
		            this.$markerFront.update(config);
		            this.$cursorLayer.update(config);
		            this.$moveTextAreaToCursor();
		            this.$highlightGutterLine && this.$updateGutterLineHighlight();
		            this._signal("afterRender");
		            return;
		        }
		
		        // scrolling
		        if (changes & this.CHANGE_SCROLL) {
		            if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES)
		                this.$textLayer.update(config);
		            else
		                this.$textLayer.scrollLines(config);
		
		            if (this.$showGutter)
		                this.$gutterLayer.update(config);
		            this.$markerBack.update(config);
		            this.$markerFront.update(config);
		            this.$cursorLayer.update(config);
		            this.$highlightGutterLine && this.$updateGutterLineHighlight();
		            this.$moveTextAreaToCursor();
		            this._signal("afterRender");
		            return;
		        }
		
		        if (changes & this.CHANGE_TEXT) {
		            this.$textLayer.update(config);
		            if (this.$showGutter)
		                this.$gutterLayer.update(config);
		        }
		        else if (changes & this.CHANGE_LINES) {
		            if (this.$updateLines() || (changes & this.CHANGE_GUTTER) && this.$showGutter)
		                this.$gutterLayer.update(config);
		        }
		        else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {
		            if (this.$showGutter)
		                this.$gutterLayer.update(config);
		        }
		
		        if (changes & this.CHANGE_CURSOR) {
		            this.$cursorLayer.update(config);
		            this.$moveTextAreaToCursor();
		            this.$highlightGutterLine && this.$updateGutterLineHighlight();
		        }
		
		        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {
		            this.$markerFront.update(config);
		        }
		
		        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {
		            this.$markerBack.update(config);
		        }
		
		        this._signal("afterRender");
		    };
		
		    
		    this.$autosize = function() {
		        var height = this.session.getScreenLength() * this.lineHeight;
		        var maxHeight = this.$maxLines * this.lineHeight;
		        var desiredHeight = Math.min(maxHeight, 
		            Math.max((this.$minLines || 1) * this.lineHeight, height)
		        ) + this.scrollMargin.v + (this.$extraHeight || 0);
		        if (this.$horizScroll)
		            desiredHeight += this.scrollBarH.getHeight();
		        if (this.$maxPixelHeight && desiredHeight > this.$maxPixelHeight)
		            desiredHeight = this.$maxPixelHeight;
		        var vScroll = height > maxHeight;
		        
		        if (desiredHeight != this.desiredHeight ||
		            this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
		            if (vScroll != this.$vScroll) {
		                this.$vScroll = vScroll;
		                this.scrollBarV.setVisible(vScroll);
		            }
		            
		            var w = this.container.clientWidth;
		            this.container.style.height = desiredHeight + "px";
		            this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);
		            // this.$loop.changes = 0;
		            this.desiredHeight = desiredHeight;
		            
		            this._signal("autosize");
		        }
		    };
		    
		    this.$computeLayerConfig = function() {
		        var session = this.session;
		        var size = this.$size;
		        
		        var hideScrollbars = size.height <= 2 * this.lineHeight;
		        var screenLines = this.session.getScreenLength();
		        var maxHeight = screenLines * this.lineHeight;
		
		        var longestLine = this.$getLongestLine();
		        
		        var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible ||
		            size.scrollerWidth - longestLine - 2 * this.$padding < 0);
		
		        var hScrollChanged = this.$horizScroll !== horizScroll;
		        if (hScrollChanged) {
		            this.$horizScroll = horizScroll;
		            this.scrollBarH.setVisible(horizScroll);
		        }
		        var vScrollBefore = this.$vScroll; // autosize can change vscroll value in which case we need to update longestLine
		        // autoresize only after updating hscroll to include scrollbar height in desired height
		        if (this.$maxLines && this.lineHeight > 1)
		            this.$autosize();
		
		        var offset = this.scrollTop % this.lineHeight;
		        var minHeight = size.scrollerHeight + this.lineHeight;
		        
		        var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd
		            ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd
		            : 0;
		        maxHeight += scrollPastEnd;
		        
		        var sm = this.scrollMargin;
		        this.session.setScrollTop(Math.max(-sm.top,
		            Math.min(this.scrollTop, maxHeight - size.scrollerHeight + sm.bottom)));
		
		        this.session.setScrollLeft(Math.max(-sm.left, Math.min(this.scrollLeft, 
		            longestLine + 2 * this.$padding - size.scrollerWidth + sm.right)));
		        
		        var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible ||
		            size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop > sm.top);
		        var vScrollChanged = vScrollBefore !== vScroll;
		        if (vScrollChanged) {
		            this.$vScroll = vScroll;
		            this.scrollBarV.setVisible(vScroll);
		        }
		
		        var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
		        var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
		        var lastRow = firstRow + lineCount;
		
		        // Map lines on the screen to lines in the document.
		        var firstRowScreen, firstRowHeight;
		        var lineHeight = this.lineHeight;
		        firstRow = session.screenToDocumentRow(firstRow, 0);
		
		        // Check if firstRow is inside of a foldLine. If true, then use the first
		        // row of the foldLine.
		        var foldLine = session.getFoldLine(firstRow);
		        if (foldLine) {
		            firstRow = foldLine.start.row;
		        }
		
		        firstRowScreen = session.documentToScreenRow(firstRow, 0);
		        firstRowHeight = session.getRowLength(firstRow) * lineHeight;
		
		        lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
		        minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight +
		                                                firstRowHeight;
		
		        offset = this.scrollTop - firstRowScreen * lineHeight;
		
		        var changes = 0;
		        if (this.layerConfig.width != longestLine) 
		            changes = this.CHANGE_H_SCROLL;
		        // Horizontal scrollbar visibility may have changed, which changes
		        // the client height of the scroller
		        if (hScrollChanged || vScrollChanged) {
		            changes = this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
		            this._signal("scrollbarVisibilityChanged");
		            if (vScrollChanged)
		                longestLine = this.$getLongestLine();
		        }
		        
		        this.layerConfig = {
		            width : longestLine,
		            padding : this.$padding,
		            firstRow : firstRow,
		            firstRowScreen: firstRowScreen,
		            lastRow : lastRow,
		            lineHeight : lineHeight,
		            characterWidth : this.characterWidth,
		            minHeight : minHeight,
		            maxHeight : maxHeight,
		            offset : offset,
		            gutterOffset : lineHeight ? Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)) : 0,
		            height : this.$size.scrollerHeight
		        };
		
		        // For debugging.
		        // console.log(JSON.stringify(this.layerConfig));
		
		        return changes;
		    };
		
		    this.$updateLines = function() {
		        var firstRow = this.$changedLines.firstRow;
		        var lastRow = this.$changedLines.lastRow;
		        this.$changedLines = null;
		
		        var layerConfig = this.layerConfig;
		
		        if (firstRow > layerConfig.lastRow + 1) { return; }
		        if (lastRow < layerConfig.firstRow) { return; }
		
		        // if the last row is unknown -> redraw everything
		        if (lastRow === Infinity) {
		            if (this.$showGutter)
		                this.$gutterLayer.update(layerConfig);
		            this.$textLayer.update(layerConfig);
		            return;
		        }
		
		        // else update only the changed rows
		        this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
		        return true;
		    };
		
		    this.$getLongestLine = function() {
		        var charCount = this.session.getScreenWidth();
		        if (this.showInvisibles && !this.session.$useWrapMode)
		            charCount += 1;
		
		        return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
		    };
		
		    /**
		     * Schedules an update to all the front markers in the document.
		     **/
		    this.updateFrontMarkers = function() {
		        this.$markerFront.setMarkers(this.session.getMarkers(true));
		        this.$loop.schedule(this.CHANGE_MARKER_FRONT);
		    };
		
		    /**
		     *
		     * Schedules an update to all the back markers in the document.
		     **/
		    this.updateBackMarkers = function() {
		        this.$markerBack.setMarkers(this.session.getMarkers());
		        this.$loop.schedule(this.CHANGE_MARKER_BACK);
		    };
		
		    /**
		     *
		     * Deprecated; (moved to [[EditSession]])
		     * @deprecated
		     **/
		    this.addGutterDecoration = function(row, className){
		        this.$gutterLayer.addGutterDecoration(row, className);
		    };
		
		    /**
		     * Deprecated; (moved to [[EditSession]])
		     * @deprecated
		     **/
		    this.removeGutterDecoration = function(row, className){
		        this.$gutterLayer.removeGutterDecoration(row, className);
		    };
		
		    /**
		     *
		     * Redraw breakpoints.
		     **/
		    this.updateBreakpoints = function(rows) {
		        this.$loop.schedule(this.CHANGE_GUTTER);
		    };
		
		    /**
		     * Sets annotations for the gutter.
		     * @param {Array} annotations An array containing annotations
		     *
		     **/
		    this.setAnnotations = function(annotations) {
		        this.$gutterLayer.setAnnotations(annotations);
		        this.$loop.schedule(this.CHANGE_GUTTER);
		    };
		
		    /**
		     *
		     * Updates the cursor icon.
		     **/
		    this.updateCursor = function() {
		        this.$loop.schedule(this.CHANGE_CURSOR);
		    };
		
		    /**
		     *
		     * Hides the cursor icon.
		     **/
		    this.hideCursor = function() {
		        this.$cursorLayer.hideCursor();
		    };
		
		    /**
		     *
		     * Shows the cursor icon.
		     **/
		    this.showCursor = function() {
		        this.$cursorLayer.showCursor();
		    };
		
		    this.scrollSelectionIntoView = function(anchor, lead, offset) {
		        // first scroll anchor into view then scroll lead into view
		        this.scrollCursorIntoView(anchor, offset);
		        this.scrollCursorIntoView(lead, offset);
		    };
		
		    /**
		     *
		     * Scrolls the cursor into the first visibile area of the editor
		     **/
		    this.scrollCursorIntoView = function(cursor, offset, $viewMargin) {
		        // the editor is not visible
		        if (this.$size.scrollerHeight === 0)
		            return;
		
		        var pos = this.$cursorLayer.getPixelPosition(cursor);
		
		        var left = pos.left;
		        var top = pos.top;
		        
		        var topMargin = $viewMargin && $viewMargin.top || 0;
		        var bottomMargin = $viewMargin && $viewMargin.bottom || 0;
		        
		        var scrollTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;
		        
		        if (scrollTop + topMargin > top) {
		            if (offset && scrollTop + topMargin > top + this.lineHeight)
		                top -= offset * this.$size.scrollerHeight;
		            if (top === 0)
		                top = -this.scrollMargin.top;
		            this.session.setScrollTop(top);
		        } else if (scrollTop + this.$size.scrollerHeight - bottomMargin < top + this.lineHeight) {
		            if (offset && scrollTop + this.$size.scrollerHeight - bottomMargin < top -  this.lineHeight)
		                top += offset * this.$size.scrollerHeight;
		            this.session.setScrollTop(top + this.lineHeight - this.$size.scrollerHeight);
		        }
		
		        var scrollLeft = this.scrollLeft;
		
		        if (scrollLeft > left) {
		            if (left < this.$padding + 2 * this.layerConfig.characterWidth)
		                left = -this.scrollMargin.left;
		            this.session.setScrollLeft(left);
		        } else if (scrollLeft + this.$size.scrollerWidth < left + this.characterWidth) {
		            this.session.setScrollLeft(Math.round(left + this.characterWidth - this.$size.scrollerWidth));
		        } else if (scrollLeft <= this.$padding && left - scrollLeft < this.characterWidth) {
		            this.session.setScrollLeft(0);
		        }
		    };
		
		    /**
		     * {:EditSession.getScrollTop}
		     * @related EditSession.getScrollTop
		     * @returns {Number}
		     **/
		    this.getScrollTop = function() {
		        return this.session.getScrollTop();
		    };
		
		    /**
		     * {:EditSession.getScrollLeft}
		     * @related EditSession.getScrollLeft
		     * @returns {Number}
		     **/
		    this.getScrollLeft = function() {
		        return this.session.getScrollLeft();
		    };
		
		    /**
		     * Returns the first visible row, regardless of whether it's fully visible or not.
		     * @returns {Number}
		     **/
		    this.getScrollTopRow = function() {
		        return this.scrollTop / this.lineHeight;
		    };
		
		    /**
		     * Returns the last visible row, regardless of whether it's fully visible or not.
		     * @returns {Number}
		     **/
		    this.getScrollBottomRow = function() {
		        return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
		    };
		
		    /**
		     * Gracefully scrolls from the top of the editor to the row indicated.
		     * @param {Number} row A row id
		     *
		     * @related EditSession.setScrollTop
		     **/
		    this.scrollToRow = function(row) {
		        this.session.setScrollTop(row * this.lineHeight);
		    };
		
		    this.alignCursor = function(cursor, alignment) {
		        if (typeof cursor == "number")
		            cursor = {row: cursor, column: 0};
		
		        var pos = this.$cursorLayer.getPixelPosition(cursor);
		        var h = this.$size.scrollerHeight - this.lineHeight;
		        var offset = pos.top - h * (alignment || 0);
		
		        this.session.setScrollTop(offset);
		        return offset;
		    };
		
		    this.STEPS = 8;
		    this.$calcSteps = function(fromValue, toValue){
		        var i = 0;
		        var l = this.STEPS;
		        var steps = [];
		
		        var func  = function(t, x_min, dx) {
		            return dx * (Math.pow(t - 1, 3) + 1) + x_min;
		        };
		
		        for (i = 0; i < l; ++i)
		            steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));
		
		        return steps;
		    };
		
		    /**
		     * Gracefully scrolls the editor to the row indicated.
		     * @param {Number} line A line number
		     * @param {Boolean} center If `true`, centers the editor the to indicated line
		     * @param {Boolean} animate If `true` animates scrolling
		     * @param {Function} callback Function to be called after the animation has finished
		     *
		     **/
		    this.scrollToLine = function(line, center, animate, callback) {
		        var pos = this.$cursorLayer.getPixelPosition({row: line, column: 0});
		        var offset = pos.top;
		        if (center)
		            offset -= this.$size.scrollerHeight / 2;
		
		        var initialScroll = this.scrollTop;
		        this.session.setScrollTop(offset);
		        if (animate !== false)
		            this.animateScrolling(initialScroll, callback);
		    };
		
		    this.animateScrolling = function(fromValue, callback) {
		        var toValue = this.scrollTop;
		        if (!this.$animatedScroll)
		            return;
		        var _self = this;
		        
		        if (fromValue == toValue)
		            return;
		        
		        if (this.$scrollAnimation) {
		            var oldSteps = this.$scrollAnimation.steps;
		            if (oldSteps.length) {
		                fromValue = oldSteps[0];
		                if (fromValue == toValue)
		                    return;
		            }
		        }
		        
		        var steps = _self.$calcSteps(fromValue, toValue);
		        this.$scrollAnimation = {from: fromValue, to: toValue, steps: steps};
		
		        clearInterval(this.$timer);
		
		        _self.session.setScrollTop(steps.shift());
		        // trick session to think it's already scrolled to not loose toValue
		        _self.session.$scrollTop = toValue;
		        this.$timer = setInterval(function() {
		            if (steps.length) {
		                _self.session.setScrollTop(steps.shift());
		                _self.session.$scrollTop = toValue;
		            } else if (toValue != null) {
		                _self.session.$scrollTop = -1;
		                _self.session.setScrollTop(toValue);
		                toValue = null;
		            } else {
		                // do this on separate step to not get spurious scroll event from scrollbar
		                _self.$timer = clearInterval(_self.$timer);
		                _self.$scrollAnimation = null;
		                callback && callback();
		            }
		        }, 10);
		    };
		
		    /**
		     * Scrolls the editor to the y pixel indicated.
		     * @param {Number} scrollTop The position to scroll to
		     *
		     * @returns {Number}
		     **/
		    this.scrollToY = function(scrollTop) {
		        // after calling scrollBar.setScrollTop
		        // scrollbar sends us event with same scrollTop. ignore it
		        if (this.scrollTop !== scrollTop) {
		            this.$loop.schedule(this.CHANGE_SCROLL);
		            this.scrollTop = scrollTop;
		        }
		    };
		
		    /**
		     * Scrolls the editor across the x-axis to the pixel indicated.
		     * @param {Number} scrollLeft The position to scroll to
		     *
		     * @returns {Number}
		     **/
		    this.scrollToX = function(scrollLeft) {
		        if (this.scrollLeft !== scrollLeft)
		            this.scrollLeft = scrollLeft;
		        this.$loop.schedule(this.CHANGE_H_SCROLL);
		    };
		
		    /**
		     * Scrolls the editor across both x- and y-axes.
		     * @param {Number} x The x value to scroll to
		     * @param {Number} y The y value to scroll to
		     **/
		    this.scrollTo = function(x, y) {
		        this.session.setScrollTop(y);
		        this.session.setScrollLeft(y);
		    };
		    
		    /**
		     * Scrolls the editor across both x- and y-axes.
		     * @param {Number} deltaX The x value to scroll by
		     * @param {Number} deltaY The y value to scroll by
		     **/
		    this.scrollBy = function(deltaX, deltaY) {
		        deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);
		        deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
		    };
		
		    /**
		     * Returns `true` if you can still scroll by either parameter; in other words, you haven't reached the end of the file or line.
		     * @param {Number} deltaX The x value to scroll by
		     * @param {Number} deltaY The y value to scroll by
		     *
		     * @returns {Boolean}
		     **/
		    this.isScrollableBy = function(deltaX, deltaY) {
		        if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top)
		           return true;
		        if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight
		            - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)
		           return true;
		        if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left)
		            return true;
		        if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth
		            - this.layerConfig.width < -1 + this.scrollMargin.right)
		           return true;
		    };
		
		    this.pixelToScreenCoordinates = function(x, y) {
		        var canvasPos = this.scroller.getBoundingClientRect();
		
		        var offset = (x + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth;
		        var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
		        var col = Math.round(offset);
		
		        return {row: row, column: col, side: offset - col > 0 ? 1 : -1};
		    };
		
		    this.screenToTextCoordinates = function(x, y) {
		        var canvasPos = this.scroller.getBoundingClientRect();
		
		        var col = Math.round(
		            (x + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth
		        );
		
		        var row = (y + this.scrollTop - canvasPos.top) / this.lineHeight;
		
		        return this.session.screenToDocumentPosition(row, Math.max(col, 0));
		    };
		
		    /**
		     * Returns an object containing the `pageX` and `pageY` coordinates of the document position.
		     * @param {Number} row The document row position
		     * @param {Number} column The document column position
		     *
		     * @returns {Object}
		     **/
		    this.textToScreenCoordinates = function(row, column) {
		        var canvasPos = this.scroller.getBoundingClientRect();
		        var pos = this.session.documentToScreenPosition(row, column);
		
		        var x = this.$padding + Math.round(pos.column * this.characterWidth);
		        var y = pos.row * this.lineHeight;
		
		        return {
		            pageX: canvasPos.left + x - this.scrollLeft,
		            pageY: canvasPos.top + y - this.scrollTop
		        };
		    };
		
		    /**
		     *
		     * Focuses the current container.
		     **/
		    this.visualizeFocus = function() {
		        dom.addCssClass(this.container, "ace_focus");
		    };
		
		    /**
		     *
		     * Blurs the current container.
		     **/
		    this.visualizeBlur = function() {
		        dom.removeCssClass(this.container, "ace_focus");
		    };
		
		    /**
		     * @param {Number} position
		     *
		     * @private
		     **/
		    this.showComposition = function(position) {
		        if (!this.$composition)
		            this.$composition = {
		                keepTextAreaAtCursor: this.$keepTextAreaAtCursor,
		                cssText: this.textarea.style.cssText
		            };
		
		        this.$keepTextAreaAtCursor = true;
		        dom.addCssClass(this.textarea, "ace_composition");
		        this.textarea.style.cssText = "";
		        this.$moveTextAreaToCursor();
		    };
		
		    /**
		     * @param {String} text A string of text to use
		     *
		     * Sets the inner text of the current composition to `text`.
		     **/
		    this.setCompositionText = function(text) {
		        this.$moveTextAreaToCursor();
		    };
		
		    /**
		     *
		     * Hides the current composition.
		     **/
		    this.hideComposition = function() {
		        if (!this.$composition)
		            return;
		
		        dom.removeCssClass(this.textarea, "ace_composition");
		        this.$keepTextAreaAtCursor = this.$composition.keepTextAreaAtCursor;
		        this.textarea.style.cssText = this.$composition.cssText;
		        this.$composition = null;
		    };
		
		    /**
		     * [Sets a new theme for the editor. `theme` should exist, and be a directory path, like `ace/theme/textmate`.]{: #VirtualRenderer.setTheme}
		     * @param {String} theme The path to a theme
		     * @param {Function} cb optional callback
		     *
		     **/
		    this.setTheme = function(theme, cb) {
		        var _self = this;
		        this.$themeId = theme;
		        _self._dispatchEvent('themeChange',{theme:theme});
		
		        if (!theme || typeof theme == "string") {
		            var moduleName = theme || this.$options.theme.initialValue;
		            config.loadModule(["theme", moduleName], afterLoad);
		        } else {
		            afterLoad(theme);
		        }
		
		        function afterLoad(module) {
		            if (_self.$themeId != theme)
		                return cb && cb();
		            if (!module.cssClass)
		                return;
		            dom.importCssString(
		                module.cssText,
		                module.cssClass,
		                _self.container.ownerDocument
		            );
		
		            if (_self.theme)
		                dom.removeCssClass(_self.container, _self.theme.cssClass);
		
		            var padding = "padding" in module ? module.padding 
		                : "padding" in (_self.theme || {}) ? 4 : _self.$padding;
		            if (_self.$padding && padding != _self.$padding)
		                _self.setPadding(padding);
		                
		            // this is kept only for backwards compatibility
		            _self.$theme = module.cssClass;
		
		            _self.theme = module;
		            dom.addCssClass(_self.container, module.cssClass);
		            dom.setCssClass(_self.container, "ace_dark", module.isDark);
		
		            // force re-measure of the gutter width
		            if (_self.$size) {
		                _self.$size.width = 0;
		                _self.$updateSizeAsync();
		            }
		
		            _self._dispatchEvent('themeLoaded', {theme:module});
		            cb && cb();
		        }
		    };
		
		    /**
		     * [Returns the path of the current theme.]{: #VirtualRenderer.getTheme}
		     * @returns {String}
		     **/
		    this.getTheme = function() {
		        return this.$themeId;
		    };
		
		    // Methods allows to add / remove CSS classnames to the editor element.
		    // This feature can be used by plug-ins to provide a visual indication of
		    // a certain mode that editor is in.
		
		    /**
		     * [Adds a new class, `style`, to the editor.]{: #VirtualRenderer.setStyle}
		     * @param {String} style A class name
		     *
		     **/
		    this.setStyle = function(style, include) {
		        dom.setCssClass(this.container, style, include !== false);
		    };
		
		    /**
		     * [Removes the class `style` from the editor.]{: #VirtualRenderer.unsetStyle}
		     * @param {String} style A class name
		     *
		     **/
		    this.unsetStyle = function(style) {
		        dom.removeCssClass(this.container, style);
		    };
		    
		    this.setCursorStyle = function(style) {
		        if (this.scroller.style.cursor != style)
		            this.scroller.style.cursor = style;
		    };
		
		    /**
		     * @param {String} cursorStyle A css cursor style
		     *
		     **/
		    this.setMouseCursor = function(cursorStyle) {
		        this.scroller.style.cursor = cursorStyle;
		    };
		
		    /**
		     * Destroys the text and cursor layers for this renderer.
		     **/
		    this.destroy = function() {
		        this.$textLayer.destroy();
		        this.$cursorLayer.destroy();
		    };
		
		}).call(VirtualRenderer.prototype);
		
		
		config.defineOptions(VirtualRenderer.prototype, "renderer", {
		    animatedScroll: {initialValue: false},
		    showInvisibles: {
		        set: function(value) {
		            if (this.$textLayer.setShowInvisibles(value))
		                this.$loop.schedule(this.CHANGE_TEXT);
		        },
		        initialValue: false
		    },
		    showPrintMargin: {
		        set: function() { this.$updatePrintMargin(); },
		        initialValue: true
		    },
		    printMarginColumn: {
		        set: function() { this.$updatePrintMargin(); },
		        initialValue: 80
		    },
		    printMargin: {
		        set: function(val) {
		            if (typeof val == "number")
		                this.$printMarginColumn = val;
		            this.$showPrintMargin = !!val;
		            this.$updatePrintMargin();
		        },
		        get: function() {
		            return this.$showPrintMargin && this.$printMarginColumn; 
		        }
		    },
		    showGutter: {
		        set: function(show){
		            this.$gutter.style.display = show ? "block" : "none";
		            this.$loop.schedule(this.CHANGE_FULL);
		            this.onGutterResize();
		        },
		        initialValue: true
		    },
		    fadeFoldWidgets: {
		        set: function(show) {
		            dom.setCssClass(this.$gutter, "ace_fade-fold-widgets", show);
		        },
		        initialValue: false
		    },
		    showFoldWidgets: {
		        set: function(show) {this.$gutterLayer.setShowFoldWidgets(show)},
		        initialValue: true
		    },
		    showLineNumbers: {
		        set: function(show) {
		            this.$gutterLayer.setShowLineNumbers(show);
		            this.$loop.schedule(this.CHANGE_GUTTER);
		        },
		        initialValue: true
		    },
		    displayIndentGuides: {
		        set: function(show) {
		            if (this.$textLayer.setDisplayIndentGuides(show))
		                this.$loop.schedule(this.CHANGE_TEXT);
		        },
		        initialValue: true
		    },
		    highlightGutterLine: {
		        set: function(shouldHighlight) {
		            if (!this.$gutterLineHighlight) {
		                this.$gutterLineHighlight = dom.createElement("div");
		                this.$gutterLineHighlight.className = "ace_gutter-active-line";
		                this.$gutter.appendChild(this.$gutterLineHighlight);
		                return;
		            }
		
		            this.$gutterLineHighlight.style.display = shouldHighlight ? "" : "none";
		            // if cursorlayer have never been updated there's nothing on screen to update
		            if (this.$cursorLayer.$pixelPos)
		                this.$updateGutterLineHighlight();
		        },
		        initialValue: false,
		        value: true
		    },
		    hScrollBarAlwaysVisible: {
		        set: function(val) {
		            if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)
		                this.$loop.schedule(this.CHANGE_SCROLL);
		        },
		        initialValue: false
		    },
		    vScrollBarAlwaysVisible: {
		        set: function(val) {
		            if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)
		                this.$loop.schedule(this.CHANGE_SCROLL);
		        },
		        initialValue: false
		    },
		    fontSize:  {
		        set: function(size) {
		            if (typeof size == "number")
		                size = size + "px";
		            this.container.style.fontSize = size;
		            this.updateFontSize();
		        },
		        initialValue: 12
		    },
		    fontFamily: {
		        set: function(name) {
		            this.container.style.fontFamily = name;
		            this.updateFontSize();
		        }
		    },
		    maxLines: {
		        set: function(val) {
		            this.updateFull();
		        }
		    },
		    minLines: {
		        set: function(val) {
		            this.updateFull();
		        }
		    },
		    maxPixelHeight: {
		        set: function(val) {
		            this.updateFull();
		        },
		        initialValue: 0
		    },
		    scrollPastEnd: {
		        set: function(val) {
		            val = +val || 0;
		            if (this.$scrollPastEnd == val)
		                return;
		            this.$scrollPastEnd = val;
		            this.$loop.schedule(this.CHANGE_SCROLL);
		        },
		        initialValue: 0,
		        handlesSet: true
		    },
		    fixedWidthGutter: {
		        set: function(val) {
		            this.$gutterLayer.$fixedWidth = !!val;
		            this.$loop.schedule(this.CHANGE_GUTTER);
		        }
		    },
		    theme: {
		        set: function(val) { this.setTheme(val) },
		        get: function() { return this.$themeId || this.theme; },
		        initialValue: "./theme/textmate",
		        handlesSet: true
		    }
		});
		
		exports.VirtualRenderer = VirtualRenderer;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/editor/worker/worker_client.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var oop = require("../lib/oop");
		var net = require("../lib/net");
		var EventEmitter = require("../lib/event_emitter").EventEmitter;
		var config = require("../config");
		
		var WorkerClient = function(topLevelNamespaces, mod, classname, workerUrl) {
		    this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
		    this.changeListener = this.changeListener.bind(this);
		    this.onMessage = this.onMessage.bind(this);
		
		    // nameToUrl is renamed to toUrl in requirejs 2
		    if (require.nameToUrl && !require.toUrl)
		        require.toUrl = require.nameToUrl;
		    
		    if (config.get("packaged") || !require.toUrl) {
		        workerUrl = workerUrl || config.moduleUrl(mod, "worker");
		    } else {
		        var normalizePath = this.$normalizePath;
		        workerUrl = workerUrl || normalizePath(require.toUrl("ace/worker/worker.js", null, "_"));
		
		        var tlns = {};
		        topLevelNamespaces.forEach(function(ns) {
		            tlns[ns] = normalizePath(require.toUrl(ns, null, "_").replace(/(\.js)?(\?.*)?$/, ""));
		        });
		    }
		
		    try {
		        this.$worker = new window.Worker(workerUrl);
		    } catch(e) {
		        if (e instanceof window.DOMException) {
		            // Likely same origin problem. Use importScripts from a shim Worker
		            var blob = this.$workerBlob(workerUrl);
		            var URL = window.URL || window.webkitURL;
		            var blobURL = URL.createObjectURL(blob);
		
		            this.$worker = new Worker(blobURL);
		            URL.revokeObjectURL(blobURL);
		        } else {
		            throw e;
		        }
		    }
		    this.$worker.postMessage({
		        init : true,
		        tlns : tlns,
		        module : mod,
		        classname : classname
		    });
		
		    this.callbackId = 1;
		    this.callbacks = {};
		
		    this.$worker.onmessage = this.onMessage;
		};
		
		(function(){
		
		    oop.implement(this, EventEmitter);
		
		    this.onMessage = function(e) {
		        var msg = e.data;
		        switch(msg.type) {
		            case "event":
		                this._signal(msg.name, {data: msg.data});
		                break;
		            case "call":
		                var callback = this.callbacks[msg.id];
		                if (callback) {
		                    callback(msg.data);
		                    delete this.callbacks[msg.id];
		                }
		                break;
		            case "error":
		                this.reportError(msg.data);
		                break;
		            case "log":
		                window.console && console.log && console.log.apply(console, msg.data);
		                break;
		        }
		    };
		    
		    this.reportError = function(err) {
		        window.console && console.error && console.error(err);
		    };
		
		    this.$normalizePath = function(path) {
		        return net.qualifyURL(path);
		    };
		
		    this.terminate = function() {
		        this._signal("terminate", {});
		        this.deltaQueue = null;
		        this.$worker.terminate();
		        this.$worker = null;
		        if (this.$doc)
		            this.$doc.off("change", this.changeListener);
		        this.$doc = null;
		    };
		
		    this.send = function(cmd, args) {
		        this.$worker.postMessage({command: cmd, args: args});
		    };
		
		    this.call = function(cmd, args, callback) {
		        if (callback) {
		            var id = this.callbackId++;
		            this.callbacks[id] = callback;
		            args.push(id);
		        }
		        this.send(cmd, args);
		    };
		
		    this.emit = function(event, data) {
		        try {
		            // firefox refuses to clone objects which have function properties
		            // TODO: cleanup event
		            this.$worker.postMessage({event: event, data: {data: data.data}});
		        }
		        catch(ex) {
		            console.error(ex.stack);
		        }
		    };
		
		    this.attachToDocument = function(doc) {
		        if(this.$doc)
		            this.terminate();
		
		        this.$doc = doc;
		        this.call("setValue", [doc.getValue()]);
		        doc.on("change", this.changeListener);
		    };
		
		    this.changeListener = function(delta) {
		        if (!this.deltaQueue) {
		            this.deltaQueue = [];
		            setTimeout(this.$sendDeltaQueue, 0);
		        }
		        if (delta.action == "insert")
		            this.deltaQueue.push(delta.start, delta.lines);
		        else
		            this.deltaQueue.push(delta.start, delta.end);
		    };
		
		    this.$sendDeltaQueue = function() {
		        var q = this.deltaQueue;
		        if (!q) return;
		        this.deltaQueue = null;
		        if (q.length > 50 && q.length > this.$doc.getLength() >> 1) {
		            this.call("setValue", [this.$doc.getValue()]);
		        } else
		            this.emit("change", {data: q});
		    };
		
		    this.$workerBlob = function(workerUrl) {
		        // workerUrl can be protocol relative
		        // importScripts only takes fully qualified urls
		        var script = "importScripts('" + net.qualifyURL(workerUrl) + "');";
		        try {
		            return new Blob([script], {"type": "application/javascript"});
		        } catch (e) { // Backwards-compatibility
		            var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
		            var blobBuilder = new BlobBuilder();
		            blobBuilder.append(script);
		            return blobBuilder.getBlob("application/javascript");
		        }
		    };
		
		}).call(WorkerClient.prototype);
		
		
		var UIWorkerClient = function(topLevelNamespaces, mod, classname) {
		    this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
		    this.changeListener = this.changeListener.bind(this);
		    this.callbackId = 1;
		    this.callbacks = {};
		    this.messageBuffer = [];
		
		    var main = null;
		    var emitSync = false;
		    var sender = Object.create(EventEmitter);
		    var _self = this;
		
		    this.$worker = {};
		    this.$worker.terminate = function() {};
		    this.$worker.postMessage = function(e) {
		        _self.messageBuffer.push(e);
		        if (main) {
		            if (emitSync)
		                setTimeout(processNext);
		            else
		                processNext();
		        }
		    };
		    this.setEmitSync = function(val) { emitSync = val };
		
		    var processNext = function() {
		        var msg = _self.messageBuffer.shift();
		        if (msg.command)
		            main[msg.command].apply(main, msg.args);
		        else if (msg.event)
		            sender._signal(msg.event, msg.data);
		    };
		
		    sender.postMessage = function(msg) {
		        _self.onMessage({data: msg});
		    };
		    sender.callback = function(data, callbackId) {
		        this.postMessage({type: "call", id: callbackId, data: data});
		    };
		    sender.emit = function(name, data) {
		        this.postMessage({type: "event", name: name, data: data});
		    };
		
		    config.loadModule(["worker", mod], function(Main) {
		        main = new Main[classname](sender);
		        while (_self.messageBuffer.length)
		            processNext();
		    });
		};
		
		UIWorkerClient.prototype = WorkerClient.prototype;
		
		exports.UIWorkerClient = UIWorkerClient;
		exports.WorkerClient = WorkerClient;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor/ace/index.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		(function() {
			var Editor = require("./editor");
			latte.require.find(__dirname + '/editor/ext/').forEach(function(file) {
				require(__dirname + '/editor/ext/' + file);
			});
			this.create = function(data, view, controller) {
				var Controller = require("../../../controller.js");
				
				
				var editor = Editor.edit(view.children[0].dom);
				editor.setValue(data.get("text") || "");
				editor.getSession().on("change", function(e) {
					data._set("text", editor.getValue());
				});
				data.on("text", function(value) {
					editor.setValue(value);
				});
				editor.setOptions({
				    enableBasicAutocompletion: true,
				    enableSnippets: true,
				    enableLiveAutocompletion: true
				});
				var themeName = view.latte("editor-theme");
				if(themeName) {
					console.log(themeName);
					var changeTheme = function(value, oldValue) {
						editor.setTheme("./theme/" + value);
					};
					controller.bind("data", themeName, changeTheme);
					data.get(themeName) && changeTheme(data.get(themeName));
				}
				var modeName = view.latte("editor-mode");
				if(modeName) {
					console.log(data.get(modeName));
					var changeMode = function(value, oldValue) {
						var Mode = require("./editor/mode/"+value);
						if(!Mode) {
							Mode = require('./editor/mode/text');
						}
						var mode = new Mode.Mode();
						editor.session.setMode(mode);
						
					}
					controller.bind("data", modeName, changeMode);
					data.get(modeName) && changeMode(data.get(modeName));
				}
			}
		}).call(module.exports);
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/editor.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var Command = {};
		(function() {
			this.after = function(data, view, controller) {
				if(view.type != 'h5View') {
					return;
				}
				var editorAttribute = view.latte("editor");
				if(editorAttribute) {
					//var d = data.get(editorAttribute);
					require("./editor/ace").create(data, view, controller);
				}
			}
		}).call(Command);
		module.exports = Command;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/keys.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		/**
			暂时规定多一些
			必须小写不判断capslock是否打开
			最多支持control+key
			@example
				button (keys:"keys")
				{
					keys:  {
						'control+s': function() {
				
						}
					}
				}
		*/
		(function() {
			var keyMap = {
				65: "a",
				66: "b",
				67: "c",
				83: "s"
			};
			var getKeys = function(keys) {
				return keys.sort(function(a, b) {
					return a - b;
				}).map(function(o) {
					return keyMap[o] || o;
				}).join("+");
				
			}
			this.after = function(data, view, controller) {
				var keyAttribute = view.attr('latte-keys');
				if(keyAttribute) {
					/*var keys = [];
					var doIt = function(e) {
						var key = getKeys(keys);
						var value = data.get(key);
						value && value.call(data, e);
					}
					var keyUpEvent = function(e) {
						if(controller.isClose()) {
							return controller.unbind('view', 'keyup', keyUpEvent);
						}
						var index = keys.indexOf(e.keyCode);
						if(index == -1) {
							return;
						}
						keys.splice(index, 1);
						doIt(e);
					}*/
					var keyDownEvent = function(e) {
						if(controller.isClose()) {
							return controller.unbind('view', 'keydown', keyDownEvent, true);
						}
						/*var index = keys.indexOf(e.keyCode);
						if(index != -1) {
							return;
						}
						keys.push(e.keyCode);
						doIt(e)*/;
						var k = keyMap[e.keyCode];
						if(!k) {
							return;
						}
						if(e.metaKey || e.ctrlKey) {
							k = 'control+' + k;
						}
						var value = data.get(keyAttribute).get(k);
						if(value) {
							e.preventDefault();
							value.call(data, e);
						}
					}
					//controller.bind("view", "keyup", keyUpEvent);
					controller.bind("view", "keydown", keyDownEvent, true);
				}
			}
		}).call(module.exports);
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/list.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		/**
			@example
				list (list:"listData")
					latte "{{text}}"
		
				{
					listData: [{
						text: "list1"
					},{
						text: "list2"
					}]
				}
		*/
		(function() {
			this.beforeLevel = 1;
			var latte_lib = require('latte_lib');
			this.before = function(data, view, controller) {
				var list = view.latte("list");
				var Controller = require("../index.js");
				if(list) {
					var child = view.children[0];
					view.removeChild(child);
					var setFunc = function(i, value, old) {
						Controller.remove(view.children[i], old);
						Controller.create(view.children[i], value);
					}
					var spliceFunc = function(startIndex, removes, adds) {
						var num = removes.length;
						for(var i = 0; i < num; i++) {
							var o = view.children[startIndex];
							view.removeChild(o);
							Controller.remove(o);
						}
						var afterDom = view.children[startIndex];
						var list = this;
						adds.forEach(function(add) {
							var cloneChild = child.clone();
							if(afterDom) {
								view.insertBefore(cloneChild, afterDom);
							}else{
								view.appendChild(cloneChild);
							}
							Controller.create(cloneChild, add);
						});
					}
					var change = function(value, oldValue) {
						/*if(value == null && oldValue == null) {
							return;
						}*/
						for(var i = 0, len = view.children.length; i < len; i++) {
							var c = view.children[0];
							Controller.remove(c);
							view.removeChild(c);
						}
						for(var i = 0, len = value.length; i < len; i++) {
							(function(i) {
								var cloneChild = child.clone();
								view.appendChild(cloneChild);
								Controller.create(view.children[i], value.get(i));
							})(i);
						}
						if(oldValue) {
							oldValue.off("set", setFunc);
							oldValue.off("splice", spliceFunc);
						}
						value.on("set", setFunc);
						value.on("splice", spliceFunc);
					}
					controller.bind("data", list, change);
					change(data.get(list));
				}
			}
		}).call(module.exports);
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/right.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		(function() {
			this.after = function(data, dom, controller) {
				var rightClick = dom.latte("rightClick");
				if(rightClick) {
					//var key1s = lib.stringRegExp(rightMenu, "{{", "}}");
					var clickEvent = function(e) {
						console.log(e.srcElement.view);
						var self =  dom.constructor.create(e.srcElement);
						if(controller.closed) {
							return controller.unbind("view", "contextmenu", clickEvent);
						}
						var events = rightClick.split(" ");
						events.forEach(function(eventName) {
							var click = data.get(eventName);
							click && click.call(data, e, self, dom);
						});
					}
					controller.bind("view", "contextmenu", clickEvent);
					
				}
			}
		}).call(module.exports);
		
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/route.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		/**
			@example
				latte (route:"index")
				{
					index: "route1",
					route1: {
						url: "./route1.lade",
						data: {
				
						},
						start: function() {
			
						},
						end: function() {
			
						}
					},
					route2: {
						url: "./route2.lade",
						data: {
			
						},
						start: function() {
			
						},
						end: function() {
						
						}
					}
					
				}
		*/
		(function() {
			var Routes = {};
			var latte_lib = require("latte_lib");
			var cache = {};
			var Latte = require("latte_view/latte");
			this.before = function(data, dom, controller) {
				var Controller = require("../index.js");
				var ViewDom = require("../../view");
				var dataName = dom.latte("route");
				//var dom = dom.node();
				if(dataName) {
					var change = function(value, oldValue) {
						var d = data.get(value);
						if(d) {
							var doIt = function(latte) {
								//var html = ViewDom.create(latte);
								if(oldValue) {
									var oldD = data.get(oldValue);
									oldD.get("end") && oldD.get("end").call(oldD);
								}
								Controller.removeChild(dom);
		
								dom.appendChild(latte);
								Controller.createChild(dom, d.get("data"));
								d.on("data", function(value, oldValue) {
									Controller.removeChild(dom);
									Controller.createChild(dom, value);
								});
								d.get("start") && d.get("start").call(d);
							}
							var url = d.get("url");
							if(url) {
								return Latte.load(d.get("url"), dom.constructor.getComponents(),function(err, latte) {
									if(err) {
										throw new Error("load error");
									}
									doIt(latte);
								});
							}
							var view = d.get("view");
							if(view){
								var latte = Latte.create(view);
								doIt(latte);
							}
							
						}else{
							throw new Error("no route");
						}
					}
					data.on(dataName, change);
					change(data.get(dataName));
				}
			}
		}).call(module.exports);
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/selectList.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		(function() {
			this.beforeLevel = 2;
			this.before = function(data, view, controller) {
				var selectList = view.latte("selectList");
				if(selectList) {
					view.latte('list', selectList+'.data');
					if(!data.get(selectList)) {
						data.set(selectList, {
							select: 0,
							data:[]
						});
					}
					if(!data.get(selectList+'.data')) {
						data.set(selectList+'.data', []);
					}
					var lists = data.get(selectList + '.data');
					var selectok = false;
					for(var i = 0, len = lists.length; i < len; i++) {
						if(lists[i].get('selected') == true && selectok == false) {
							data.get(selectList)._set('select', i);
							selectok = true;
							continue;
						}
						if(selectok == true){
		
						}
					}
					var change = function(now, old) {
						if(old == null) {
							data.get(selectList + '.data');
						}
						var nowo = data.get(selectList+'.data').get(now);
						if(!nowo && view.latte('overflow') == null) {
							data.get(selectList)._set('select', old);
							return;
						}
						if(old != null) {
							var o = data.get(selectList+'.data').get(old);
							if(o) {
								o.set('selected', false);
							}
						}
						if(nowo) {
							nowo.set('selected', true);
						}
						
						
						
					};
					controller.bind('data', selectList + '.select', change);
					change(data.get(selectList+'.select'));
				}
			}
		}).call(module.exports);
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/show.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		/**
			@example
				p (show:"{{status}}=='show'")
				{
					status:"show" 
				}
		*/
		(function() {
			var latte_lib = require('latte_lib');
			var Language = require('../../language');
			var forEachJSON = function(data, key, result) {
					for(var i in data) {
						
						if(latte_lib.isObject(data[i])) {
							var ckey = latte_lib.clone(key);
							ckey.push(i);
							forEachJSON(data[i], ckey, result);
						}else if(latte_lib.isArray(data[i])){
							var ckey = latte_lib.clone(key);
							ckey.push(i);
							forEachJSON(data[i], ckey, result);
						}else{
							var ckey = latte_lib.clone(key);
							ckey.push(i);
							result[ckey.join(".")] = data[i] != null ?data[i].toString(): "undefined";
							
		
						}
					}
				}
			var toJSON = function(data) {
		
				if(latte_lib.isObject(data)) {
					return JSON.stringify(data.toJSON());
				}else if(latte_lib.isString(data)){
					return '"' + data +'"'
				}else{
					return JSON.stringify(data);
				}
				
			}
			this.after = function(data, view, controller) {
				var showValue = view.latte("show");
				if(showValue) {
					var key1s = Language.stringRegExp(showValue, "{{", "}}");
					var doChange = function() {
						var text = showValue;
						var j = {};
						key1s.forEach(function(key) {
							j[key] = toJSON(data.get(key));
						});
						text = latte_lib.format.templateStringFormat(text, j);
						if(!!eval(text)) {
							view.show();
						}else{
							view.hide();
						}
					};
					doChange();
					key1s.forEach(function(key) {
						controller.bind("data", key, function(value, oldValue) {
							doChange();
						});
					});
				}
			}
		}).call(module.exports);
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/src.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		/**
			@example
				p (src:"{{path}}/{{filename}}")
				{
					path:"./html",
					filename: "./"
				}
		*/
		(function() {
			var latte_lib = require('latte_lib');
			var Language = require('../../language');
			this.after = function(data, view, controller) {
				var stringContent = view.latte('src');
				if(stringContent) {
					var keys = Language.stringRegExp(stringContent);
					view.src(latte_lib.format.templateStringFormat(stringContent, data.toJSON()));
					keys.forEach(function(key) {
						controller.bind("data", key, function() {
							view.src(latte_lib.format.templateStringFormat(stringContent, data.toJSON()));
						});
					});
				}
			}
		}).call(module.exports);
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/text.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		/**
			@example
				p (text:"{{status}}")
				{
					status:"show" 
				}
		*/
		(function() {
			var latte_lib = require('latte_lib');
			var forEachJSON = function(data, key, result) {
							for(var i in data) {
								
								if(latte_lib.isObject(data[i])) {
									var ckey = latte_lib.clone(key);
									ckey.push(i);
									forEachJSON(data[i], ckey, result);
								}else if(latte_lib.isArray(data[i])){
									var ckey = latte_lib.clone(key);
									ckey.push(i);
									forEachJSON(data[i], ckey, result);
								}else{
									var ckey = latte_lib.clone(key);
									ckey.push(i);
									result[ckey.join(".")] = data[i] != null ?data[i].toString(): "undefined";
									
		
								}
							}
						}
					var toJSON = function(data) {
						var result = {};
						var json = data.toJSON();
						forEachJSON(json,  [], result);	
						
						return result;
					}
					var templateLanguage = function(template, options) {
						var data = template;
						var key2s = Language.stringRegExp(data, "!#", "#!");
						//for(var i in key2s) {
						key2s.forEach(function(i) {
							data = data.replace(new RegExp("!#"+i+"#!","igm"), options[i] || i);
						});
							
						//}
						
						return data;
					}
			var Language = require('../../language');
			this.after = function(data, view, controller) {
				var latteValue = view.latte("text");
				var doChange = function(str) {
					var text = latte_lib.format.templateStringFormat(str, toJSON(data));
					text = templateLanguage(text, Language.toJSON());
					//如果有dom的话可能会修改掉dom  比如button  里面有span  会被覆盖掉   暂时没想到其他简单的解决方案
					
					var list = [];
					if(view.children.length) {
						
						var v ;
						while( v = view.children[0]) {
							list.push(v);
							view.removeChild(v);
						} 
					}
					view.text(text);
					if(list.length) {
						list.forEach(function(v) {
							view.appendChild(v);
						});
						
					}
				};
				var changeFunc = function(str) {
					var key1s = Language.stringRegExp(str , "{{", "}}");
					var key2s = Language.stringRegExp(str, "!#", "#!");
					doChange(str);
					key1s.forEach(function(key) {
						controller.bind("data", key, function(value, oldValue) {
							doChange(str);
						});
					});
					if(!key2s.length) {
						Language.on('change', function(value, old) {
							doChange(str);
						});
					}
				}
				if(latteValue) {
					changeFunc(latteValue);
				}
			}
		}).call(module.exports);
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/commands/view.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		(function() {	
			var Lade = require("latte_view/latte/index.js");
				/**
					view 切换
				*/
			this.before = function(data, dom, controller) {
				var viewAttr = dom.latte("view");
				if(viewAttr) {
					var changeView = function(now, old) {
						if(now === old) {
							return;
						}
						var createView = function(lade) {
							var Controller = require("../index");
							Controller.removeChild(dom);
							dom.removeAll();
							var viewDom = dom.constructor.create(lade);
							dom.appendChild(viewDom);
							var childDataAttr = dom.latte("childData");
							var childData = childDataAttr? data.get(childDataAttr): data;
							
							Controller.createChild(dom, childData);
						};
						if(now.indexOf('.lade') == -1 && now.indexOf('.blank') == -1) {
							createView(Lade.create(now, dom.constructor.getComponents()));
						}else{
							Lade.load(now, dom.constructor.getComponents(), function(err, lade) {
								if(err) {
									console.error("lade load error ", now);
									return;
								}
								createView(lade);
							});
						}
						
					}
					controller.bind("data", viewAttr, changeView);
					var viewPath = data.get(viewAttr);
					controller.once("finish", function() {
						changeView(viewPath);
					});
				}
					
				
			}	
		}).call(module.exports);	
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/controller/index.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var latte_lib = require('latte_lib');
		var getClass = latte_lib.getClass || function(obj) {
			return obj.constructor;
		};
		var Controller = function(view, data) {
			view.controller = this;
			this.view = view;
			this.root = view.getRoot();
			this.dataEvents = {};
			this.viewEvents = {};
			this.rootEvents = {};
			if(view.latte('data')) {
				this.data = data.get(view.latte('data'));
			}else{
				this.data = data;
			}
			if(!this.data) {
				console.log(data, view.latte("data"));
				throw new Error("data "+view.latte("data")+" Error");
			}
			var View = getClass(view);
			var component = View.getComponent(view.latte("tag"));
			if(component && component.data) {
				for(var i in component.data) {
					if(this.data.get(i) == undefined) {
						this.data.set(i, latte_lib.clone(component.data[i]));
					}
				}
				if(this.view.latte('lazy')) {
					var child = View.create(component.latte.clone());
					this.view.appendChild(child);
					this.view.latte('lazy', null);
				}
				if(component.dataChanges) {
					for(var i in component.dataChanges) {
						component.dataChanges[i].call(this.data, this.data.get(i));
						this.bind('data', i, component.dataChanges[i]);
					}
					
				}
			}
			
			this.status = 'ready';
		
		};
		latte_lib.extends(Controller, latte_lib.events);
		(function() {
			this.init = function() {
				var self = this;
				Controller.befores.forEach(function(command) {
					command(self.data, self.view, self);
				});
				Controller.middle(self.data, self.view, self);
				Controller.afters.forEach(function(command) {
					command(self.data, self.view, self);
				});
				this.emit('finish');
				this.status = 'open';
			}
			this.onceBind= function(type, eventType, funcs, ops) {
				/*if(!latte_lib.isArray(funcs)) {
					funcs = [funcs];
				}
				var self = this;
				var f = this[type], events = this[type + "Events"];
				for(var i = 0, len = funcs.length; i < len; i++) {
					var fn = funcs[i];
					if(!latte_lib.isFunction(fn)) {
						console.error("add is not function");
						return;
					}
					function on() {
						self.unbind(type, eventType, fn, ops);
						fn.apply(this, arguments);
					}
					on.fn = fn;
					f.on(eventType, on);
				}
				events[eventType] = funcs.concat(events[eventType] || []);*/
				if(!latte_lib.isFunction(funcs)) {
					console.error("add is not function");
					return;
				}
				var self = this;
				var f = this[type], events = this[type + "Events"];
				events[eventType] = events[eventType] || [];
				for(var i = 0, len = events[eventType].length; i < len; i++) {
					if(events[eventType][i] == funcs || events[eventType][i].on == funcs ) {
						return;
					}
				}
				function on() {
					self.unbind(type, eventType, funcs, ops);
					funcs.apply(this, arguments);
				}
				funcs.on = on;
				f.on(eventType, on);
				
				events[eventType].push(funcs);
			}
			this.bind = function(type, eventType, funcs, ops) {
				/*if(!latte_lib.isArray(funcs)) {
					funcs = [funcs];
				}
				var f = this[type], events = this[type + "Events"];
				for(var i = 0, len = funcs.length; i < len; i++) {
					var func = funcs[i];
					if(!latte_lib.isFunction(func)) {
						console.error("add is not function");
						return;
					}
					f.on(eventType, func);
				}
				events[eventType] = funcs.concat(events[eventType] || []);*/
				if(!latte_lib.isFunction(funcs)) {
					console.error("add is not function");
					return;
				}
				var f = this[type], events = this[type + "Events"];
				events[eventType] = events[eventType] || [];
				for(var i = 0, len = events[eventType].length; i < len; i++) {
					if(events[eventType][i] == funcs || events[eventType][i].on == funcs ) {
						return;
					}
				}
				f.on(eventType, funcs);
				events[eventType].push(funcs);
			}
			this.unbind = function(type, eventType, funcs, ops) {
				/*var f = this[type], events = this[type + "Events"];
				if(!latte_lib.isArray(funcs)) {
					funcs = [funcs];
				}
				for(var i = 0, len = funcs.length; i < len; i++) {
					var func = funcs[i]
						, fIndex = events[eventType].indexOf(func);
					if(fIndex == -1) {
						return console.error("not find the func");
					}
					f.off(eventType, func, ops);
					events[eventType].splice(fIndex, 1);
				}*/
				if(!latte_lib.isFunction(funcs)) {
					console.error("unbind is not function");
					return;
				}
				var f = this[type], events = this[type + "Events"];
				var fun , index;
				for(var i = 0, len = events[eventType].length; i < len; i++) {
					if(events[eventType][i] == funcs || events[eventType][i].on == funcs ) {
						fun = events[eventType][i].on || events[eventType][i];
						index = i;
						break;
					}
				}
				if(fun == undefined) {
					return console.error("not find the func");
				} 
				
				f.off(eventType, fun, ops);
				events[eventType].splice(index, 1);
				
			}
			this.close = function() {
				this.status = 'closed';
				var self = this;
				for(var i in this.dataEvents) {
					this.dataEvents[i].forEach(function(func) {
						self.data.off(i, func);
					});
				}
				this.dataEvents = {};
				var self = this;
				for(var  i in this.viewEvents) {
					this.viewEvents[i].forEach(function(func) {
						self.view.off(i, func);
					});
					
				}
				this.viewEvents = {};
				for(var i = 0, len = this.view.children.length; i < length; i++) {
					Controller.remove(this.view.children[i]);
				}
				delete this.view.controller;
				this.emit('close');
			}
			this.isClose = function() {
				return this.status == 'closed';
			}
		}).call(Controller.prototype);
		(function() {
			this.befores = [];
			this.afters = [];
			this.middle = function(data, view, controller) {
				if(view.attr('latte-stop')) {
					return;
				}
				for(var i = 0, len = view.children.length; i< len; i++) {
					(function(i, view) {
						var child = view.children[i];
						Controller.create(child, data);
					})(i, view);
				}
			};
			
			this.create = function(view, data) {
				if(view.controller) {
					return view.controller;
				}
				data = latte_lib.object.create(data);
				var controller = new Controller(view, data);
				controller.init();
				return controller;
		 	}
		 	this.remove = function(view, data, controller) {
		 		if(!view) {
		 			return;
		 		}
		 		controller = controller || view.controller;
		 		controller && controller.close();
		 	}
		 	this.removeChild = function(view) {
		 		for(var i = 0,len = view.children.length; i < len; i++) {
		 			Controller.remove(view.children[i]);
		 			view.removeChild(view.children[i]);
		 		}
		 	}
		 	this.createChild = function(view, data) {
		 		for(var i = 0, len = view.children.length; i < len; i++) {
		 			Controller.create(view.children[i], data);
		 		}
		  	}
		  	this.addCommand = function(path) {
		  		var funcs = latte.require.find(path).map(function(r) {
				var o = require(path + r);
					return o;
				});
				funcs.sort(function(a, b) {
					return (b.beforeLevel || b.level || 0) - (a.beforeLevel || a.level || 0);
				}).forEach(function(b) {
					if(b.before && latte_lib.isFunction(b.before)) {
						Controller.befores.push(b.before);
					}
				});
				funcs.sort(function(a, b) {
					return (b.afterLevel || b.level || 0) - (a.afterLevel || a.level || 0);
				}).forEach(function(a) {
					if(a.after && latte_lib.isFunction(a.after)) {
						Controller.afters.push(a.after);
					}
				});
		  	}
		
		}).call(Controller);
		Controller.addCommand("latte_view/controller/commands/");
		module.exports = Controller;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/index.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var Controller = require('./controller');
		var Loader = require('./loader');
		var latte_lib = require('latte_lib');
		(function() {
			var Latte = function(config) {
				this.context = null;
				this.config = config;
				this.status = "ready";
			};
			(function() {
				/*this.init = function(callback) {
					var self = this;
					this.loader.loadLatte(this.config.main, function(err, result) {
						if(err) {
							return callback(err);
						}
						switch(this.config.type) {
							case "html":
								this.initHtml(result, callback);
							break;
							case "canvas":
								this.initCanvas(result, callback);
							break;
							case "ios":
							break;
							case "android":
							break;
						}
					});
					
				}
				this.load = function(config, callback) {
					var result = {};
					var self = this;
					var loadConfig = Object.keys(config).forEach(function(key) {
						return function(cb) {
							self.loader.get(key, config[key], function(err, data) {
								if(err) {
									return cb(err);
								}
								result[key] = data;
								return cb();
							});
						}
					});
					latte_lib.async.parallel(loadConfig, function(err) {
						if(err) {
							return callback(err);
						}
						callback(null, result);
					});
				} 
				this.initHtml = function(latte, callback) {
					loader.loadCss(this.config.css, function() {
		
					});
		
				}	
				this.initCanvas = function(latte, css) {
					loader.loadCss(this.config.css, function(err, css) {
						view.load(latte, css);				
					});
				}*/
				this.init = function(callback) {
					
					switch(this.config.type) {
						case 'canvas':
							this.initCanvas(callback);
						break;
						case 'html5':
							this.initHtml5(callback);
						break;
					}
				}
				this.initHtml5 = function(callback) {
					var rootDom = document.getElementById(this.config.id || 'latte');
					if(!rootDom) {
						var rootDom = document.createElement('div');
						rootDom.id = this.config.id || 'latte';
						document.appendChild(rootDom);
					}
					var View = require('./view/h5View');
					View.initComponent();
					View.loadCss(this.config.css, this.config.css);
					this.view = View.create(rootDom);
					this.view.latte('data', 'data');
					this.view.latte('route', 'index');
					this.data = latte_lib.object.create({
						data: this.config.route
					});
					this.controller = Controller.create(this.view, this.data);
					this.status = 'open';
					callback(null, this.data);
				}
				this.initCanvas = function(callback) {
					var dom = document.getElementById(this.config.id || 'latte');
					if(!dom) {
						dom = document.createElement('canvas');
						dom.id = this.config.id || 'latte';
						document.appendChild(dom);
					}else if(dom.tagName.toLocaleLowerCase() != 'canvas') {
						var canvas = document.createElement('canvas');
						dom.appendChild(canvas);
						dom = canvas;
					}
					var View = require('./view/canvasView');
					View.initComponent();
					var self = this;
					View.loadCss(this.config.css, function() {
						self.view = View.createRoot(dom);
						self.view.latte('data', 'data');
						self.view.latte('route', 'index');
						self.data = latte_lib.object.create({
							data: self.config.route
						});
						self.controller = Controller.create(self.view, self.data);
						self.status = 'open';
						self.view.draw(function() {
							callback(null , self.data);
						});
					});
					
					
				}
				this.close = function() {
					this.status = 'closed';
				}
			}).call(Latte.prototype);
			this.create = function(config, callback) {
				var latte = new Latte(config);
				latte.init(callback);
				return latte;
			}
			this.H5View = require('./view/h5View');
			this.Controller = Controller;
			this.Object = latte_lib.object;
			this.Latte = require('./latte');
			this.Lcss = require('./lcss');
		}).call(module.exports);
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/language/index.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var latte_lib = require("latte_lib");
		var Language = function(language) {
			this.language = language;
			this.data =  {};
		};
		latte_lib.inherits(Language, latte_lib.events);
		(function() {
			this.load = function(language, path, callback) {
				var self = this;
				self.language = language;
				latte_lib.xhr.get(path, {}, function(data) {
					try {
						data = JSON.parse(data);
					}catch(e) {
						console.error("language page json  format is Error");
						callback && callback(e);
					}
					self.set(language, data);
					callback && callback();
				}, function(err) {
					console.error("language page ajax Error", err);
					callback && callback(err);
				});
			}	
			this.get = function(name) {
				return this.data[this.language][name];
			}
			this.set = function(language, data) {
				var self = this;
				this.language = language;
				self.data[language] = self.data[language] || {};
				
				var now = self.data[language];
				for(var i in data) {
					self.emit(i, data[i], self.data[language][i]);
					self.data[language][i] = data[i];
				}
				console.log("change");
				self.emit("change", data, now);
		
			}
			this.toJSON = function() {
				return this.data[this.language];
			}
		}).call(Language.prototype);
		module.exports = new Language();
		(function() {
			var self = this;
			this.stringRegExp = function(str, prefix , suffix) {
				prefix = prefix || "{{";
				suffix =  suffix || "}}";
				var vernier = 0;
				var next = 1;
				var keys = [];
				while(next) {
					var startIndex = str.indexOf(prefix, vernier);
					if(startIndex == -1) {
						next = 0;
						return keys;
					}
					var endIndex = str.indexOf(suffix, startIndex);
					if(endIndex == -1) {
						next = 0;
						return keys;
					}
					keys.push(str.substring(startIndex+prefix.length, endIndex));
					vernier = endIndex;
				}
			}
			this.toString = function(str) {
				str = str.trim();
				var r = str;
				if(str[0] == '"' && str[str.length - 1] == '"') {
					r = str.substr(1, str.length - 2);
				}
				if(str[0] == "'" && str[str.length - 1] == "'") {
					r = str.substr(1, str.length - 2);
				}
				console.log(r);
				return r;
			}
			var v2str = function(v) {
				if(v == null) {
					return 'null';
				}
				if(v.toJSON) {
					return v2str(v.toJSON());
				}
				return JSON.stringify(v);
			}
			this.format = function(key, data) {
				var keys = self.stringRegExp(key);
				var d = {};
				keys.forEach(function(k) {
					var v = data.get(k);
					d[k] = v2str(v);
				});
				var str = latte_lib.format.templateStringFormat(key, d);
				console.log('format', key, data);
				return str;
			}
			this.run = function(key, data) {
				var d = self.format(key, data);
				try{
					console.log('eval', d);
					return eval(d);
				}catch(err) {
					console.log('eval error', d);
					return null;
				}
		
			}
		}).call(module.exports);
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/latte/index.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var latte_lib = require('latte_lib');
		var Latte = function() {
			this.all = '';
			this.tab = -1;
			this._text = '';
			this._attribute = {};
			this._latte = {};
			this._style = {};
			this.tag = '';
			this.children = [];
			this._glass = [];
		};
		latte_lib.extends(Latte, latte_lib.events);
		(function() {
			this.latte = function(key, value) {
				if(key == null) {
					return this._latte;
				}
				if(value != null) {
					this._latte[key] = value;
				}else{
					if(latte_lib.isObject(key)) {
						for(var i in key) {
							this._latte[i] = key[i]; 
						}
						
					}else{
						return this._latte[key];
					}
					
				}
			}
			this.text = function(value) {
				if(value != null) {
					this._text = value;
				}else{
					return this._text;
				}
			}
			this.attr = function(key, value) {
				if(key == null) {
					return this._attribute;
				}
				if(value != null) {
					this._attribute[key] = value;
				}else{
					if(latte_lib.isObject(key)) {
						for(var i in key) {
							this._attribute[i] = key[i]; 
						}
						
					}else{
						return this._attribute[key];
					}
					
				}
			}
			this.style = function(key, value) {
				if(key == null) {
					return this._style;
				}
				if(value != null) {
					this._style[key] = value;
				}else{
					if(latte_lib.isObject(key)) {
						for(var i in key) {
							this._style[i] = key[i]; 
						}
						
					}else{
						return this._style[key];
					}
				}
			}
			this.classed = function(key, value) {
				if(key == null) {
					return this._glass;
				}
				if(latte_lib.isArray(key)) {
					var self = this;
					return key.forEach(function(c) {
						self.classed(c, 1);
					})
				}
				var index = this._glass.indexOf(key);
				if(value == null) {
					return index == -1;
				}else if(value) {
					this._glass.push(key);
				}else{
					this._glass.splice(index, 1);
				}
			}
			this.appendChild = function(latte) {
				this.children.push(latte);
				latte.parent = this;
				this.emit('appendChild', latte);
			}
			this.removeChild = function(latte) {
				var index = this.children.indexOf(latte);
				if(index == -1) {
					return;
				}
				this.children.splice(index, 1);
				this.emit('removeChild', latte);
				latte.parent = undefined;
			}
			this.changeParent = function(nowParent) {
				this.parent.removeChild(this);
				nowParent.appendChild(this);
			}
			this.removeAllChild = function() {
				this.children.forEach(function(o) {
					o.parent = null;
					this.emit('removeChild', o);
				});
			}
			this.clone = function() {
				var clone = new Latte();
				clone.all = this.all;
				clone.tab = this.tab;
				clone._text = this._text;
				clone._attribute = latte_lib.copy(this._attribute);
				clone._latte = latte_lib.copy(this._latte);
				clone._style = latte_lib.copy(this._style);;
				clone.tag = this.tag;
				clone._glass = latte_lib.copy(this._glass);
				clone.children = this.children.map(function(c) {
					return c.clone();
				});
				return clone;
			}
		}).call(Latte.prototype);
		(function() {
			var load = function(url, callback) {
				/*$.ajax({
		            url: url,
		            success: function (data) {
		                callback(null, data);
		            },
		            error: function (err) {
		                var error = new Error("loadError:" + url);
		                error.httpError = err;
		                return callback(error);
		            }
		        });*/
				require('../loader').loadFile(url, callback);
			}
			var attrchar = {
				"}": "_attribute",
				")": "_latte",
				">": "_style"
			};
			var attribute = {
				"_attribute": ["{","}"],
				"_latte": ["(",")"],
				"_style": ["<",">"]
			};
			var getLast = function(line, attrs) {
				return attrs[line[line.length - 1]];
			}
			var findEndIndex = function(line, strs) {
				var reg = new RegExp("["+strs.join("|")+"]", "ig");
				var result = line.match(reg);
				if(result.length%2 != 0 || result[result.length - 1] != strs[1]) {
					console.error(line, strs);
					return -1;
				}
				var d = 1;
				var index = line.length - 1;
				var r ;
				for(var i = result.length - 2; 0<= i ;i--) {
					index = line.lastIndexOf(result[i], index-1);
					if(result[i] == strs[1]) {
						d++;
					}else{
						d--;
					}
					if(d == 0) {
						r = i;
						break;
					}
				}
				if( r == null) {
					console.error(line, strs);
					return -1;
				}
				return index;
				
			}
			var line2object = function(line, components) {
				var result = new Latte();
				result.all = line;
				var tab = 0;
				for(var i = 0, len = line.length; i < len;i++) {
					if(line[i] == ' ') {
						tab++;
					}else if(line[i] == '\t') {
						tab += 4;
					}else{
						break;
					}
				}
				result.tab = tab;
				var line = line.trim();
				if(line[line.length - 1] == '"') {
					var endIndex = line.lastIndexOf('"', line.length - 2);
					result._text = line.substring(endIndex+1, line.length -1);
					line = line.substring(0, endIndex).trim();
				}
				var type;
				while(type = getLast(line, attrchar)) {
					var endIndex = findEndIndex(line, attribute[type]);
					//var endIndex = line.lastIndexOf(attribute[type][0]);
					if(endIndex == -1) {
						break;
					}
					var o = line.substring(endIndex + 1, line.length - 1);
					//console.log(type, o, line);
					var kvs = o.split(',');
					var obj = {};
					kvs.forEach(function(kv) {
						var array = kv.split(':');
						if(array.length < 2) {
							return;
						} 
						var k = array.shift().trim();
						var c = array.join(':').trim();
						
						if(c[0] == '"' || c[0] == "'") {
							obj[k] = c.substring(1, c.length - 1);
						}else{
							if(!isNaN(c - 0)) {
								obj[k] = c - 0;
		 					} else {
		 						obj[k] = c;
		  					}
						}
					});
					result[type] = obj;
					line = line.substring(0, endIndex).trim();
				}
				var classsArray  = line.split('.');
				if(classsArray.length > 1) {
					result._glass = classsArray.slice(1);
					line = classsArray[0];
				}
				var idArray = line.split('#');
				if(idArray.length > 1) {
					result.id = idArray[idArray.length - 1];
					line = idArray[0];
				}
				var tag = result.tag = line.trim();
				result.children = [];
				var component = components[result.tag];
				if(component) {
					
					
					//if(!result.latte('lazy')) {
						var cloneC = component.latte.clone();
						/*result._glass.forEach(function(c) {
							if(cloneC._glass.indexOf(c) != -1) {
								return;
							}
							cloneC._glass.push(c);
						});
						result._glass = [];
						cloneC.style(result.style());
						result._style = {};
						cloneC.latte(result.latte());
						result._latte = {};*/
						result.latte('tag', tag) ;
						result.tag = 'latte';
						//cloneC.tab = result.tab;
						//cloneC.id = result.id;
						//cloneC.latte('tag', result.tag);
						/*result.childrens.forEach(function(c) {
							cloneC.childrens.push(c);
						});*/
						result.children.push(cloneC);
					//}
					//return cloneC;
				}
				if(result.latte('lazy')) {
					result.latte('tag', tag) ;
					result.tag = 'latte';
				}
				return result;
			}
			var isBlank = function(str) {
				return str.replace(/\s/g, "") == "";
			}
			var findParent = function(last, tab) {
				var old = last;
				if(last.tab < tab) {
					return last;
				}
				while(last.tab > tab) {
					last = last.parent;
					if(!last) {
						//debugger;
						//return console.error('not findParent',old, tab);
						return null;
					}
				}
				if(last.tab < tab) {
					return last;
				}else if(last.tab == tab){
					return last.parent;
				}
				return null;
			}
			var str2obj = function(data, components) {
				var root, last;
				var reg = /(\/\*(.|\s)*?\*\/)/g;
				data = data.replace(reg, ""); 
				var lines = data.split('\n');
				lines.forEach(function(line) {
					if(isBlank(line)) {
						return;
					}
					var l2o = line2object(line, components);
					if(!root) {
						root = l2o;
						last = root;
						return;
					}
					var parent = findParent(last, l2o.tab) || root;
					l2o.parent = parent;
					parent.children.push(l2o);
					last = l2o;
				});
				return root;
			}
			var defaultComponents = {};
			this.load = function(url, components, callback) {
				if(latte_lib.isFunction(components)) {
					callback = components;
					components = defaultComponents;
				}
				load(url, function(err, data) {
					if(err) {
						return callback(err);
					}
					var latte = str2obj(data, components);
					callback(null, latte);
				});
			}
			this.create = function(lade, components) {
				if(latte_lib.isString(lade)) {
					var latte = str2obj(lade, components || defaultComponents);
					return latte;
					//components[component.tag] = latte;
				}else if(Latte.isLatte(lade)) {
					return lade;
					//components[component.tag] = component.latte;
				}else{
					console.log('create latte 失败', lade);
					return null;
				}
				//return str2obj(o);
			}
			this.isLatte = function(o) {
				return o instanceof Latte;
			}
			
			
			
			/*this.addComponent = function(component, callback) {
				if(latte_lib.isString(component.lade)) {
					var latte = str2obj(component.lade);
					component.latte = latte;
					//components[component.tag] = latte;
				}else if(Latte.isLatte(component.lade)) {
					component.latte = latte;
					//components[component.tag] = component.latte;
				}else if(latte_lib.isObject(component.lade)) {
					var latte = new Latte();
					component.latte = latte;
					//components[component.tag] = latte;
				}else{
					callback('添加component失败');
					return console.log('添加component失败', component);
				}
				callback(null, component);
			}*/
			var toStringArray = this.toStringArray = function(latte) {
				var array = [];
				var str = latte.all.trim();
				array.push(str);
				latte.children.forEach(function(c) {
					array.push(toStringArray(c));
				});
				return array;
			}
			var formatArray = function(array, tab) {
				tab = tab || "";
				return array.map(function(c) {
					if(latte_lib.isString(c)) {
						return tab + c;
					}else{
						return formatArray(c, tab + "\t")
					}
				}).join("\n");
			}
			this.format = function(data) {
				var latte = str2obj(data);
				return formatArray(toStringArray(latte));
			}
			
		}).call(Latte);
		module.exports = Latte;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/lcss/index.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var Loader = require('../loader');
		var latte_lib = require('latte_lib');
		var Lcss = function() {
			this.data = [];
		};
		(function() {
			this.push = function(obj) {
				this.data.push(obj);
			}
			this.forEach = function(callback) {
				this.data.forEach(callback);
			}
		}).call(Lcss.prototype);
		(function() {
			var formatHead = function(head) {
				return head.replace(/\s+/ig," ");
			}
			var formatValue = function(value) {
				if(value[0] == '"' || value[0] == "'") {
					return value.substring(1, value.length - 1);
				}
				return isNaN(value - 0)? value : value - 0;
			}
			var parseOneStr = function(str, left, right, path, data, p) {
				var body = str.substring(left + 1, right);
				var bodySplits = body.split(';');
				var key = formatHead(path).trim();
				var obj = {};
				bodySplits.forEach(function(o) {
					if(o.trim() != '') {
						var keys = o.split(':');
						obj[keys[0].trim()] = formatValue(keys[1].trim());
					}
				});
				/*if(key.indexOf('@keyframes') != -1) {
					var keys = key.replace('@keyframes').trim().split(' ');
					if(keys.length > 2) {
						console.error('@keyframes error');
					}
					var k = keys[0];
					debugger;
				}else{*/
					var mks = key.split(',');
					mks.forEach(function(k) {
						data.push({
							key: k,
							value: obj
						});
					});
					
				//}
				
				return str.substring(left, right + 1);
			}
			var getPath = function(array) {
				return array.map(function(o) {
					return o.path;
				}).join(" ");
			}
			var getHead = function(str, start, end) {
				var max = str.length;
				var a = str.lastIndexOf('}', end - 1) || max;
				var b = str.lastIndexOf('{', end - 1) || max;
				var c = str.lastIndexOf(';', end - 1) || max;
				if(a == b == c == max) {
					return str.substring(0, end);
				}
				var max = Math.max(a, b, c);
				var header = str.substring(max + 1, end);
				return header;
		 	}
			var str2css = function(str, css) {
				var reg = /(\/\*(.|\s)*?\*\/)/g;
				str = str.replace(reg, ""); 
				var left = str.indexOf("{");
				if(left == -1) {
					return;
				}
				var lefts = [];
				var right = str.indexOf("}");
				var lastLeft = -1;
				while(true) {
					left = str.indexOf('{', lastLeft + 1);
					if(left == -1) {
						var oneStr = parseOneStr(str, lastLeft, right, getPath(lefts), css);
						var o = lefts.pop();
						str = str.replace(o.path + oneStr, "");
						if(lefts.length == 0) {
							lastLeft = 0;
						}else{
							lastLeft = lefts[lefts.length - 1].index;
						}
						break;
					}
					if(left < right) {
						lefts.push({
							path : getHead(str, lastLeft, left),
							index: left
						});
						lastLeft = left;
					} else {
						var oneStr = parseOneStr(str, lastLeft, right, getPath(lefts), css);
						var o = lefts.pop();
						str = str.replace(o.path + oneStr, '');
						if(lefts.length == 0) {
							lastLeft = 0;
						} else {
							lastLeft = lefts[lefts.length - 1].index;
						}
						right = str.indexOf('}');
					}
				}
				if(lefts.length > 0) {
					var i = lefts.length;
					while(i--) {
						right = str.indexOf('}');
						var oneStr = parseOneStr(str, lastLeft, right, getPath(lefts), css);
						var o = lefts.pop();
						str = str.replace(o.path + oneStr, "");
						if(lefts.length != 0) {
							lastLeft = lefts[lefts.length - 1].index;
						}
					}
				}
			}
			this.isLcss = function(data) {
				return data instanceof Lcss;
			}
			this.create = function(data) {
				if(latte_lib.isString(data)) {
					var lcss = new Lcss();
					str2css(data, lcss);
					return lcss;
				}
				if(Lcss.isLcss(data)) {
					return data;
				}
				return null;
			}
		}).call(Lcss);
		var unInherits = ['left', 'top', 'bottom', 'right'];
		var LcssManagement = function(config) {
			this.data = [];
			this.maps = {};
			this.unInherits = config.unInherits || unInherits;
		};
		(function() {
			
			var load = function(url, callback) {
				/*$.ajax({
		            url: url,
		            success: function (data) {
		                callback(null, data);
		            },
		            error: function (err) {
		                var error = new Error("loadError:" + url);
		                error.httpError = err;
		                return callback(error);
		            }
		        });*/
				Loader.loadFile(url, callback);
			}
			this.load = function(url, callback) {
				var self = this;
				Loader.loadFile(url, function(err, data) {
					if(err) {
						return callback(err);
					}
					//var lcss = Lcss.create(data);
					var lcss = self.addLcss(url, data);
					callback && callback(null, lcss);
				});
			}
			this.addLcss = function(key, lcss) {
				var lcss = Lcss.create(lcss);
				if(!lcss) {
					return;
				}
				this.maps[key] = lcss;
				if(this.data.indexOf(key) == -1) {
					this.data.push(key);
				}
				return lcss;
				
			}
			var getReg = function(latte) {
				var result = [];
				if(latte.tag) {
					result.push(latte.tag);
				}
				if(latte.id) {
					result.push('#' + latte.id);
				}
				if(latte._glass) {
					latte._glass.forEach(function(c) {
						result.push('.' + c);
					});
				};
				return result;
			}
			var getKey = function(latte) {
				var result = [getReg(latte)];
				var o = latte;
				while(o.parent) {
					result.unshift(getReg(o.parent));
					o = o.parent;
				}
				return result;
		
			}
			var isKey = function(key, regArray) {
				var splits = key.split(' ');
				var k = 0;
				for(var i = 0, len = splits.length; i< len ; i++) {
					while(regArray[k] && (regArray[k].indexOf(splits[i]) == -1)) {
						k++;
					}
					if(regArray[k] == null) {
						return false;
					}
					k++;
				}
				return true;
			}
			this.getStyle = function(latte) {
				var cssArray = [];
				var style = {};
				var key = getKey(latte);
				var self = this;
				this.data.forEach(function(k) {
					var o = self.maps[k];
					o.data.forEach(function(data) {
						if(isKey(data.key, key)) {
							var sps = data.key.split(' ');
							var o = sps.pop();
							var index = 0;
							for(var i = key.length - 1; i >= 0; i--) {
								if(key[i].indexOf(o) != -1) {
									index = i;
									break;
								}
							}
							cssArray.push({
								index: index,
								key: data.key,
								value: data.value
							});
						}
					});
				});
				cssArray.sort(function(a, b) {
					return a.index - b.index;
				});
				var max = key.length - 1;
				cssArray.forEach(function(c) {
					for(var i in c.value) {
						if(c.index != max && self.unInherits.indexOf(i) != -1) {
							continue;
						}else{
							style[i] = c.value[i];
						}
						
					}
				});
		
				return style;
			}
		
		}).call(LcssManagement.prototype);
		(function() {
			this.createManagement = function(config) {
				return new LcssManagement(config);
			}
			this.format = function(code) {
				code = code.replace(/(\s){2,}/ig,'$1'); 
				code = code.replace(/(\S)\s*\{/ig,'$1 {'); 
				code = code.replace(/\*\/(.[^\}\{]*)}/ig,'\*\/\n$1}'); 
				code = code.replace(/\/\*/ig,'\n\/\*'); 
				code = code.replace(/;\s*(\S)/ig,';\n\t$1'); 
				code = code.replace(/\}\s*(\S)/ig,'\}\n$1'); 
				code = code.replace(/\n\s*\}/ig,'\n\}'); 
				code = code.replace(/\{\s*(\S)/ig,'\{\n\t$1'); 
				code = code.replace(/(\S)\s*\*\//ig,'$1\*\/'); 
				code = code.replace(/\*\/\s*([^\}\{]\S)/ig,'\*\/\n\t$1'); 
				code = code.replace(/(\S)\}/ig,'$1\n\}'); 
				code = code.replace(/(\n){2,}/ig,'\n'); 
				code = code.replace(/:/ig,': '); 
				code = code.replace(/  /ig,' '); 
				return code;
			}
			this.createLcss = function(data) {
				var lcss = new Lcss();
				str2css(data.trim(),lcss);
				return lcss;
			}
		}).call(module.exports);
		module.exports = require('./lcss');
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/lcss/lcss.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var Loader = require('../loader');
		var latte_lib = require('latte_lib');
		var Lcss = require('./lcssParse');
		
		var unInherits = ['left', 'top', 'bottom', 'right', 'animation-name', 'animation-duration','animation-timing-function'];
		var LcssManagement = function(config) {
			config = config || {};
			this.data = [];
			this.maps = {};
			this.unInherits = config.unInherits || unInherits;
		};
		(function() {
			
			var load = function(url, callback) {
				Loader.loadFile(url, callback);
			}
			this.load = function(url, callback) {
				var self = this;
				Loader.loadFile(url, function(err, data) {
					if(err) {
						return callback(err);
					}
					//var lcss = Lcss.create(data);
					var lcss = self.addLcss(url, data);
					callback && callback(null, lcss);
				});
			}
			this.addLcss = function(key, lcss) {
				var lcss = Lcss.create(lcss);
				if(!lcss) {
					return;
				}
				this.maps[key] = lcss;
				if(this.data.indexOf(key) == -1) {
					this.data.push(key);
				}
				return lcss;
				
			}
			var getReg = function(latte) {
				var result = [];
				if(latte.tag) {
					result.push(latte.tag);
				}
				if(latte.id) {
					result.push('#' + latte.id);
				}
				if(latte._glass) {
					latte._glass.forEach(function(c) {
						result.push('.' + c);
					});
				};
				return result;
			}
			var getKey = function(latte) {
				var result = [getReg(latte)];
				var o = latte;
				while(o.parent) {
					result.unshift(getReg(o.parent));
					o = o.parent;
				}
				return result;
		
			}
			var isKey = function(key, regArray) {
				var splits = key.split(' ');
				var k = 0;
				for(var i = 0, len = splits.length; i< len ; i++) {
					while(regArray[k] && (regArray[k].indexOf(splits[i]) == -1)) {
						k++;
					}
					if(regArray[k] == null) {
						return false;
					}
					k++;
				}
				return true;
			}
			this.getStyle = function(latte) {
				var cssArray = [];
				var style = {};
				var key = getKey(latte);
				var self = this;
				var max = key.length - 1;
				this.data.forEach(function(k) {
					var o = self.maps[k];
					o.data.forEach(function(data) {
						if(isKey(data.key, key)) {
							var sps = data.key.split(' ');
							var o = sps.pop();
							var index = 0;
							for(var i = max; i >= 0; i--) {
								if(key[i].indexOf(o) != -1) {
									index = i;
									break;
								}
							}
							cssArray.push({
								index: index,
								key: data.key,
								value: data.value
							});
						}
					});
				});
				cssArray.sort(function(a, b) {
					return a.index - b.index;
				});
		
				cssArray.forEach(function(c) {
					for(var i in c.value) {
						if(c.index == max || self.unInherits.indexOf(i) == -1) {
							style[i] = c.value[i];
						}
						
					}
				});
		
				return style;
			}
			this.getFrame = function(key) {
				var result ;
				/*this.data.forEach(function(k) {
					var o = self.maps[k];
					o.
				});*/
				for(var i = this.data.length -1; i >= 0; i--) {
					var o = this.maps[this.data[i]];
					if(o.keyframes[key]) {
						return o.keyframes[key];
					}
				}
				return null;
			}
		
		}).call(LcssManagement.prototype);
		(function(){
			this.createManagement = function(config) {
				return new LcssManagement(config);
			}
			this.format = function(code) {
				code = code.replace(/(\s){2,}/ig,'$1'); 
				code = code.replace(/(\S)\s*\{/ig,'$1 {'); 
				code = code.replace(/\*\/(.[^\}\{]*)}/ig,'\*\/\n$1}'); 
				code = code.replace(/\/\*/ig,'\n\/\*'); 
				code = code.replace(/;\s*(\S)/ig,';\n\t$1'); 
				code = code.replace(/\}\s*(\S)/ig,'\}\n$1'); 
				code = code.replace(/\n\s*\}/ig,'\n\}'); 
				code = code.replace(/\{\s*(\S)/ig,'\{\n\t$1'); 
				code = code.replace(/(\S)\s*\*\//ig,'$1\*\/'); 
				code = code.replace(/\*\/\s*([^\}\{]\S)/ig,'\*\/\n\t$1'); 
				code = code.replace(/(\S)\}/ig,'$1\n\}'); 
				code = code.replace(/(\n){2,}/ig,'\n'); 
				code = code.replace(/:/ig,': '); 
				code = code.replace(/  /ig,' '); 
				return code;
			}
			this.createLcss = function(data) {
				/*var lcss = new Lcss();
				str2css(data.trim(),lcss);*/
				var lcss = Lcss.create(data);
				return lcss;
			}
		}).call(LcssManagement);
		module.exports = LcssManagement;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/lcss/lcssParse.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var latte_lib = require('latte_lib');
		
		var Lcss = function() {
			this.data = [];
			this.keyframes = {};
		};
		(function() {
			this.push = function(obj) {
				this.data.push(obj);
			}
			this.forEach = function(callback) {
				this.data.forEach(callback);
			}
			this.addFrame = function(key, frame) {
				this.keyframes[key] = frame;
			}
		}).call(Lcss.prototype);
		
		(function() {
			var formatHead = function(head) {
				return head.replace(/\s+/ig," ");
			}
			var formatValue = function(value) {
				if(value[0] == '"' || value[0] == "'") {
					return value.substring(1, value.length - 1);
				}
				return isNaN(value - 0)? value : value - 0;
			}
			var parseOneStr = function(str, left, right, path, data, p) {
				var body = str.substring(left + 1, right);
				var bodySplits = body.split(';');
				var key = formatHead(path).trim();
				var obj = {};
				bodySplits.forEach(function(o) {
					if(o.trim() != '') {
						var keys = o.split(':');
						obj[keys[0].trim()] = formatValue(keys[1].trim());
					}
				});
				/*if(key.indexOf('@keyframes') != -1) {
					var keys = key.replace('@keyframes').trim().split(' ');
					if(keys.length > 2) {
						console.error('@keyframes error');
					}
					var k = keys[0];
					debugger;
				}else{*/
					var mks = key.split(',');
					mks.forEach(function(k) {
						data.push({
							key: k,
							value: obj
						});
					});
					
				//}
				
				return str.substring(left, right + 1);
			}
			var getPath = function(array) {
				return array.map(function(o) {
					return o.path;
				}).join(" ");
			}
			var getHead = function(str, start, end) {
				var max = str.length;
				var a = str.lastIndexOf('}', end - 1) || max;
				var b = str.lastIndexOf('{', end - 1) || max;
				var c = str.lastIndexOf(';', end - 1) || max;
				if(a == b == c == max) {
					return str.substring(0, end);
				}
				var max = Math.max(a, b, c);
				var header = str.substring(max + 1, end);
				return header;
		 	}
		 	var findEnd = function(str, startIndex) {
		 		var leftN = 1;
		 		var start =   str.indexOf("{", startIndex);
		 		var right = str.indexOf("}", start + 1);
		 		while(leftN != 0) {
		 			var ln = str.indexOf('{', start + 1);
		 			if(ln == -1) {
		 				 console.error('css 有问题');
		 				 return -1;
		 			}
		 			if(ln < right) {
		 				leftN++;
		 				start = ln;
		 			}else{
		 				leftN--;
		 				start = right;
		 				right = str.indexOf('}', start + 1);
		 			}
		 		}
		 		return start;
		 	}
		 	var addKeyFrame = function(str, css) {
		 		str = str.replace('@keyframes', "");
		 		var start = str.indexOf('{');
		 		var key = str.substring(0, start).trim();
		 		str = str.substring(start + 1, str.length-1);
		 		var obj = {};
		 		var keys = str.split('}');
		 		keys.forEach(function(k) {
		 			var i = k.indexOf('{');
		 			if(i == -1) {
		 				return;
		 			}
		 			var result = {};
		 			var ik = k.substring(0, i).trim();
		 			k = k.substring(i + 1)
		 			var all = k.split(';');
		 			all.forEach(function(a) {
		 				var sps = a.split(':');
		 				if(sps.length == 2) {
		 					result[sps[0].trim()] = formatValue(sps[1].trim());
		 				}
		 			});
		 			obj[ik] = result;
		 		});
		 		css.addFrame(key, obj);
		 	}
		 	var findKeyFrames = function(str, css) {
		 		var start;
		 		while((start = str.indexOf('@keyframes')) != -1) {
		 			var end = findEnd(str, start);
		 			if(end == -1) {
		 				return '';
		 			}
		 			var kstr = str.substring(start, end + 1);
		 			addKeyFrame(kstr, css);
		 			str = str.replace(kstr, "");
		 		}
		 		return str;
		 	}
		 	
			var str2css = function(str, css) {
				var reg = /(\/\*(.|\s)*?\*\/)/g;
				str = str.replace(reg, ""); 
				if(str.indexOf('@keyframes') != -1) {
					str = findKeyFrames(str, css);
				}
				var left = str.indexOf("{");
				if(left == -1) {
					return;
				}
				var lefts = [];
				var right = str.indexOf("}");
				var lastLeft = -1;
		
				
		
				
				while(true) {
					left = str.indexOf('{', lastLeft + 1);
					if(left == -1) {
						var oneStr = parseOneStr(str, lastLeft, right, getPath(lefts), css);
						var o = lefts.pop();
						str = str.replace(o.path + oneStr, "");
						if(lefts.length == 0) {
							lastLeft = 0;
						}else{
							lastLeft = lefts[lefts.length - 1].index;
						}
						break;
					}
					if(left < right) {
						lefts.push({
							path : getHead(str, lastLeft, left),
							index: left
						});
						lastLeft = left;
					} else {
						var oneStr = parseOneStr(str, lastLeft, right, getPath(lefts), css);
						var o = lefts.pop();
						str = str.replace(o.path + oneStr, '');
						if(lefts.length == 0) {
							lastLeft = 0;
						} else {
							lastLeft = lefts[lefts.length - 1].index;
						}
						right = str.indexOf('}');
					}
				}
				if(lefts.length > 0) {
					var i = lefts.length;
					while(i--) {
						right = str.indexOf('}');
						var oneStr = parseOneStr(str, lastLeft, right, getPath(lefts), css);
						var o = lefts.pop();
						str = str.replace(o.path + oneStr, "");
						if(lefts.length != 0) {
							lastLeft = lefts[lefts.length - 1].index;
						}
					}
				}
			}
			this.isLcss = function(data) {
				return data instanceof Lcss;
			}
			this.create = function(data) {
				if(latte_lib.isString(data)) {
					var lcss = new Lcss();
					str2css(data, lcss);
					return lcss;
				}
				if(Lcss.isLcss(data)) {
					return data;
				}
				return null;
			}
		}).call(Lcss);
		module.exports = Lcss;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/loader/index.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		/*(function() {
			var Cache = function(config) {
				this.config = config;
				this.caches = {
		
				};
			};
			(function() {
				this.set = function(key, value) {
					this.caches[key] = {
						timeout: this.config.timeout == -1? -1: this.config.timeout + Date.now(),
						value: value
					};
				}
				this.get = function(key) {
					this.checkout();
					if(this.caches[key] && this.caches[key].value) {
						return this.caches[key].value;
					}
					return null;
				} 
				this.checkout = function() {
					if(this.config.timeout == -1) {
						return;
					}
					var nowTime = Date.now();
					var self = this;
					Object.keys(this.caches).forEach(function(key) {
						if(self.caches[key].timeout < nowTime) {
							delete self.caches[key];
						}
					});
				}
			}).call(Cache.prototype);
			var caches = {
				latte: new Cache({
					timeout: -1
				}),
				lcss: new Cache({
					timeout: -1
				})
			};
			var Latte = require('../latte');
			var Lcss = require('../lcss');
			var Loader = function(loader) {
				var loadings = {
		
				};
				this.load = function(url, callback) {
					if(loadings[url]) {
						return loadings[url].on("finish", callback);
					}
					loadings[url] = new latte_lib.events();
					loadings[url].on("finish", callback);
					loader(url, function(err, data){
						loadings[url].emit("finish", err, data);
						delete loadings[url];
					});
				}
			};
			var loaders = {
				latte: new Loader(Latte.load),
				lcss: new Loader(Lcss.load)
			};
			this.get = function(type, url, callback) {
				if(caches[type].get(url)) {
					return callback(null, caches[type].get(url));
				}
				loaders[type](url, function(err, obj) {
					if(err) {
						return callback(err);
					}
					caches[type].set(url, obj);
					return callback(null, obj);
				});
			}
			
		
		}).call(module.exports);*/
		var latte_lib = require('latte_lib');
		var Loader = function() {
			this.cache = {};
		};
		latte_lib.extends(Loader, latte_lib.events);
		(function() {
				var loadProtocol = (function() {
					var ajaxLocation = location.href;  
					var rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/; //打印[http://localhost:8080,http:,localhost,8080]  
					var rhash = /#.*$/;  
					//匹配开头的"//"字段  
					var rprotocol = /^\/\//;  
					//获取前面的协议字段，如"http:","file:"等  
					var ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];  
					//第一个replace去掉用hash值,第二个replace表示如果去掉hash值以后开头已经是//那么也要进行相应的处理  
					//var result=ajaxLocation.replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );
					return ajaxLocParts[1];
				})();
				var loadFile = function(url, callback) {
					var xhr;
					window.XMLHttpRequest?xhr = new XMLHttpRequest():xhr = new ActiveXObject("Microsoft.XMLHTTP");
					xhr.open("get",url,true);
					xhr.send(null);
					xhr.onreadystatechange = function(){
						if(xhr.responseText != '') {
							//console.log(xhr.readyState, xhr.status);
						}
						if(xhr.readyState==4){
							/*if(xhr.responseURL) {
								return callback(new Error())
							}
							callback(null, xhr.responseText);*/
							if(loadProtocol == 'file:' ) {
								if(xhr.responseURL == '') {
									return callback(new Error('not find'));
								}else{
									return callback(null, xhr.responseText);
								}
		 					}else{
								if(xhr.status == 200) {
									return callback(null, xhr.responseText);
								}
							}
						}
					}
				}
			this.loadFile = function(obj, callback) {
				if(latte_lib.isString(obj)) {
					obj = {
						url: obj,
						parser : function(data){
							return data;
						}
					};
				}
				if(!latte_lib.isObject(obj)) {
					return callback(new Error('url format error'))
				}
				
				var text = require(obj.url);
				//console.log('loadFile', obj.url, text);
				if(text != null) {
					return callback(null, text);
				}
				loadFile(obj.url, function(err, data){
					if(err) {
						return callback(err);
					}
					data = obj.parser(data);
					return callback(null, data);
				});
			}
			/*this.loadView = function(url, callback) {
				var Latte = require('../latte/index');
				this.loadFile({
					url: url,
					parser: function(data) {
						return Latte.padata;
					}
				}, callback);
			}*/
			var images = {};
			var loadImages = {};
			var loadImageEvent = new latte_lib.events();
			this.loadImage = function(url, callback) {
				if(loadImages[url]) {
					loadImageEvent.on(url, callback);
				}
				if(images[url]) {
					return images[url];
				} 
				loadImageEvent.on(url, callback);
				var image = images[url] = new Image();
				image.src = url;
				image.onload = function() {
					loadImages[url] = undefined;
					loadImageEvent.emit(url);
				}
				image.onerror = function(err) {
					console.error('loadImageError',url)
					images[url] = undefined;
					loadImages[url] = undefined;
				}
				loadImages[url] = 1;
				return image;
			}
		}).call(Loader.prototype);
		module.exports = new Loader();
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/view/canvasView.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var View = require('./index.js');
		var latte_lib = require('latte_lib');
		var Lcss = require("../lcss");
		var Latte = require('../latte');
		var Loader = require('../loader');
		var CanvasView = function(latte, parent, root) {
			this._latte = latte;
			this.children = [];
			this.type = 'canvas';
			this.parent = parent;
			this.drawStatus = {};
			this.cache = {};
			//this.attrs = {};
			if(!this.parent && !root) {
				this.root = this;
			}else{
				this.root = root;
			}
			for(var i = 0,len = this._latte.children.length; i < len; i++) {
				var c = this._latte.children[i];
				this.children.push(new CanvasView(c, this, this.root));
			}
			
		};
		latte_lib.extends(CanvasView, View);
		(function() {
			this.attr = function(key, value) {
				return this._latte.attr(key, value);
			}
			this.latte = function(key, value) {
				return this._latte.latte(key, value);
			}
			this.width = function(width) {
				return this.style('width', width);
			}
			this.height = function(height) {
				return this.style('height' , height );
			}	
			this.style = function(key, value) {
				return this._latte.style(key, value);
			}
			this.setParent = function(parent) {
				this.parent = parent;
			}
			this.top = function(top) {
				return this.style('y', top);
			}
			this.left = function(left) {
				return this.style('x', left);
			}
			var mergerStyle = function(a, b) {
				for(var bk in b ) {
					a[bk] = b[bk];
				}
				return a;
			}
			this.text = function(value) {
				if(value == null) {
					return this._latte.text();
				}
				this._latte.text(value);
			}
			this.update = function() {
				this.drawStatus = mergerStyle(this.root.getStyle(this) , this._latte.style());
				if(this.drawStatus.position != 'absolute') {
					this.drawStatus.x = ( this.parent? this.parent.drawStatus.x : 0) + (this.drawStatus.x || 0);
					this.drawStatus.y = (this.parent? this.parent.drawStatus.y : 0)+ (this.drawStatus.y || 0);
				}
				this.drawStatus.text = this._latte.text();
				if(latte_lib.isString(this.drawStatus.src)) {
					var self = this;
					this.drawStatus.src = Loader.loadImage(this.drawStatus.src, function() {
						self.update();
					});
				}
				if(this.drawStatus.src) {
					this.drawStatus.imageX = this.drawStatus.imageX || 0;
					this.drawStatus.imageY = this.drawStatus.imageY || 0;
					this.drawStatus.imageWidth = this.drawStatus.imageWidth || this.drawStatus.src.width;
					this.drawStatus.imageHeight = this.drawStatus.imageHeight || this.drawStatus.src.height;
				}
				
					
				
			}
			this.appendChild = function(view) {
				var view = this.root.createView(view);
				view.setParent(this);
				this.children.push(view);
				this._latte.children.push(view._latte);
				view.root = this.root;
			}
			this.removeChild = function(view) {
				var index = this.children.indexOf(view);
				if(index == -1) {return;}
				this.children.splice(index, 1);
				this._latte.removeChild(view._latte);
			}
			
			this.getRoot = function() {
				return this.root || this;
			}
			this.clone = function() {
				var latte = this._latte.clone();
				return new CanvasView(latte , null, this.root);
			}
			this.lcssClass = function(str) {
				if(str == null) {
					return this._latte._glass;
				}
				this._latte._glass = str.split(' ');
			}
			
		}).call(CanvasView.prototype);
		(function() {
			this.createRoot = function(dom) {
				var canvas = new CanvasView(Latte.create('root'), null, null);
				canvas.style({
					width: dom.width || 1000,
					height: dom.height || 1000,
					x: 0,
					y: 0
				});
				canvas.lcss = CanvasView.lcss;
				canvas.context = new Context(dom, canvas.lcss);
				canvas.root = canvas;
				canvas.getStyle = function(v) {
					//console.log(canvas.lcss);
					return canvas.lcss.getStyle(v._latte);
				}
				canvas.createView = function(tag) {
					if(CanvasView.isView(tag)) {
						return tag;
					}
					var latte;
					if(latte_lib.isString(tag)) {
						latte = Latte.create(tag);
					}else if(Latte.isLatte(tag)) {
						latte = tag;
					}
					
					return new CanvasView(latte, null, canvas);
				}
				canvas.draw = function(callback) {
					//console.log(canvas._latte);
					var self = this;
					if(this.status == "close") {
						return;
					}
					setTimeout(function() {
						canvas.draw();
					}, 1000/60);
					if(this.status == "drawing") {
						this.once('drawed', callback);
						return;
					}
					this.context.clean();
					this.status = 'drawing';
					this.context.draw(this);
					this.status = 'idle';
					this.emit('drawed');
				}
				canvas.draw();
				return canvas;
			}
			var lcss = this.lcss = Lcss.createManagement();
			this.loadCss = function(url, callback) {
				//console.log(url);
				CanvasView.lcss.load(url, callback);
			}
			this.initComponent = function() {
		
			}
			this.getComponents = function() {
				return {};
			}
			this.getComponent = function() {
				return null;
			}
			this.isView = function(o) {
				return o instanceof CanvasView;
			}
		}).call(CanvasView);
		var Context = function(dom) {
			this.dom = dom;
			this.ctx = dom.getContext("2d");
			this._dom = document.createElement("canvas");
			this._ctx = this._dom.getContext("2d");
		};
		(function() {
			this.clean = function() {
				this.ctx.clearRect(0,0, this.dom.width, this.dom.height);
			}
			this.draw = function(obj) {
				obj.update();
				//console.log(obj.drawStatus);
				this.drawBackground(obj.drawStatus);
				this.drawText(obj.drawStatus);
				var self = this;
				obj.children.forEach(function(c) {
					self.draw(c);
				});
			}
			this.drawText = function(style) {
				if(!style.text) {
					return;
				}
				this.ctx.save();
				this.ctx.beginPath();
				style.fontSize = style.fontSize || 16;
				this.ctx.fillStyle = style["color"] || "#fff";  //填充的颜色
				var fontSize = style.height? Math.min(style.height, style.fontSize): style.fontSize;
				this.ctx.font = [fontSize + "px", style.font || "sans-serif"].join(' ');
				this.ctx.textBaseline = "top";
				this.ctx.fillStyle = style.fontColor ;
				
				switch(style.align) {
					
					case 'center':
						var obj = this.ctx.measureText(this.ctx.text);
						this.ctx.fillText(style.text, (style.width - obj.width)/2 + style.x, style.y, obj.width);
					break;
					case 'right':
						var obj = this.ctx.measureText(this.ctx.text);
						this.ctx.fillText(style.text, (style.width - obj.width ) + style.x, style.y, obj.width);
					
					break;
					case 'left':
					default:
						var obj = this.ctx.measureText(this.ctx.text);
						this.ctx.fillText(style.text, style.x, style.y, style.width);
					break;
				}
				this.ctx.closePath();
				this.ctx.restore();
			}
			this.drawImg = function(style) {
				this.ctx.globalAlpha = style.opacity || 1;
				//console.log(style.src, style.imageX, style.imageY, style.imageWidth, style.imageHeight, style.x, style.y, style.width, style.height);
				this.ctx.drawImage(style.src, style.imageX, style.imageY, style.imageWidth, style.imageHeight, style.x, style.y, style.width, style.height);
				//console.log(style.src.width, style.src.height);
				
				//document.body.appendChild(style.src);
				//this.ctx.drawImage(style.src, 0, 0,100, 100, 0,0,100,100);	
			}
			this.drawBox = function(style) {
				this.ctx.globalAlpha = style.opacity || 1;;
				this.ctx.fillStyle = style["background-color"] || "#fff";  //填充的颜色
				this.ctx.strokeStyle = style.borderColor || style["background-color"] || "#fff";  //边框颜色
				this.ctx.fillRect( (style.x || 0), (style.y || 0),style.width,style.height);  //填充颜色 x y坐标 宽 高
			}
			this.drawBackground = function(style) {
				this.ctx.save();
				this.ctx.beginPath();
				if(style.src) {
					this.drawImg(style);
				}else{
					this.drawBox(style);
				}
				this.ctx.closePath();
				this.ctx.restore();
			}
		}).call(Context.prototype);
		(function() {
		
			this.parseLatte = function() {
				
			}
		}).call(Context);
		module.exports = CanvasView;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/view/h5/dialog.css", ["require", "exports", "module", "window","__filename", "__dirname"],
 	function(require, exports, module, window, __filename, __dirname) {
 		module.exports = 'latte {    display: block;}.latte-dialog-wrapper {		z-index: 1000;		position: fixed;	    left: 0;	    top: 0;	    width: 100%;	    height: 100%;	    background: rgba(0,0,0,0.5);	}	.latte-dialog-wrapper {		margin: 0;    	top: 0;	    right: 0;	    bottom: 0;	    left: 0;	    position: fixed;	    overflow: auto;	    margin: 0;	}	.latte-dialog {		top: 30%;	    position: absolute;	    left: 50%;	    transform: translateX(-50%);	    background: #fff;	    border-radius: 2px;	    box-shadow: 0 1px 3px rgba(0,0,0,.3);	    box-sizing: border-box;	    margin-bottom: 50px;	}	.latte-dialog-header {	    padding: 20px 20px 0;	}	.latte-dialog-body {	    padding: 30px 20px;	    color: #48576a;	    font-size: 14px;	}	.latte-dialog-footer {	    padding: 10px 20px 15px;	    text-align: right;	    box-sizing: border-box;	}';
 	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });

(function(define) {'use strict'
	define("latte_view/view/h5/dialog.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		(function() {
			this.lade = require('./dialog.lade');
			this.css = __dirname + '/dialog.css';
			this.data = {
				text:'',
				show: false,
				viewData: {
					
				},
				close: function() {
					this.set('show', false);
				}
			};
			this.tag = "dialog";
		}).call(module.exports);
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/view/h5/dialog.lade", ["require", "exports", "module", "window","__filename", "__dirname"],
 	function(require, exports, module, window, __filename, __dirname) {
 		module.exports = 'latte.latte-dialog-wrapper (show:{{show}})\n	latte.latte-dialog (width:"{{width}}", height: "{{height}}")\n		latte.latte-dialog-header\n			latte.span (text:"{{text}}")\n				latte.latte-dialog-header-button\n					latte.latte-icon-close (click:"close")\n		latte.latte-dialog-body \n			latte (view:"view", childData:"viewData")\n		latte.latte-dialog-footer\n			latte.latte-button.latte-button-default (click:"close")\n				latte   "取消"\n			latte.latte-button.latte-button-primary (click:"ok")\n				latte   "确定"'
 	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });

(function(define) {'use strict'
	define("latte_view/view/h5/editor.css", ["require", "exports", "module", "window","__filename", "__dirname"],
 	function(require, exports, module, window, __filename, __dirname) {
 		module.exports = '.latte_editor_ace {	position: relative;	float: left;	width: 100%;	height: 100%;}.latte_editor_ace > pre{	margin: 0;    position: absolute;    top: 0; bottom: 0; left: 0; right: 0;}';
 	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });

(function(define) {'use strict'
	define("latte_view/view/h5/editor.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		(function() {
			this.lade = require('./editor.lade');
			this.css = __dirname + '/editor.css';
			this.data = {
				text: "hello",
				mode: "css",
		    	theme: "twilight",
		    	"find_show": false,
		    	keys: {
		    		'control+f': function(event) {
		    			console.log(this);
		    		}
		    	}
			};
			this.tag = "editor";
		}).call(module.exports);
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/view/h5/editor.lade", ["require", "exports", "module", "window","__filename", "__dirname"],
 	function(require, exports, module, window, __filename, __dirname) {
 		module.exports = 'div.latte_editor_ace (editor:"true", editor-mode: "mode",editor-theme: "theme", keys:"keys")\n	pre (stop:"true")\n	latte.editor_find (show:"{{find_show}}")\n		input {type:"search",placeholder:"What are you find?" }\n			div {pseudo}'
 	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });

(function(define) {'use strict'
	define("latte_view/view/h5/fileTree.css", ["require", "exports", "module", "window","__filename", "__dirname"],
 	function(require, exports, module, window, __filename, __dirname) {
 		module.exports = '[class*=" latte-icon-"], [class^=latte-icon-] {    font-family: latte-icons!important;    speak: none;    font-style: normal;    font-weight: 400;    font-variant: normal;    text-transform: none;    line-height: 1;    vertical-align: baseline;    display: inline-block;    -webkit-font-smoothing: antialiased;    -moz-osx-font-smoothing: grayscale;}.latte-icon-minus {	line-height:34px;}.latte-icon-plus {	line-height:34px;}.latte-tree-node-content {    line-height: 36px;    height: 36px;    cursor: pointer;}.latte-tree-node {	min-height: 30px;		position: relative;}.latte-tree-node-expand-icon {    width: 35px;    transition: all .3s;}.latte-tree-node-children {	margin-left: 30px;}.close .latte-tree-node-children {	display: none;}';
 	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });

(function(define) {'use strict'
	define("latte_view/view/h5/fileTree.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		(function() {
			this.lade = require('./fileTree.lade');
			this.css = __dirname + '/fileTree.css';
			this.data = {
				name: "",
				children:[],
				type: "",
				status : "close",
				closeOrOpen: function() {
					console.log(this.get("type"));
					if(this.get("type") == "dir") {
						if(this.get("status") == "close") {
							this.set("status", "open");
						}else{
							this.set("status", "close");
						}	
					}
				},
				fileMenu: {
		
				},
				dirMenu: {
		
				},
				click: function() {
					
				}
			};
			this.tag = "fileTree";
			this.lazy = true;
		}).call(module.exports);
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/view/h5/fileTree.lade", ["require", "exports", "module", "window","__filename", "__dirname"],
 	function(require, exports, module, window, __filename, __dirname) {
 		module.exports = 'div.latte-tree-node (glass:"{{status}}")\n	div.latte-tree-node-content\n		span.latte-tree-node-expand-icon.latte-icon-tree (glass:"{{type}}",click:"closeOrOpen")\n		span.latte-tree-node-label  (text:"{{name}}")\n	div.latte-tree-node-children (list:"children")\n		fileTree (lazy:"1")'
 	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });

(function(define) {'use strict'
	define("latte_view/view/h5/rightMenu.css", ["require", "exports", "module", "window","__filename", "__dirname"],
 	function(require, exports, module, window, __filename, __dirname) {
 		module.exports = '.latte-rightMenuNode {	display: list-item;    text-align: -webkit-match-parent;}.latte-rightMenuList {    display: block;    list-style-type: disc;    -webkit-margin-before: 1em;    -webkit-margin-after: 1em;    -webkit-margin-start: 0px;    -webkit-margin-end: 0px;    -webkit-padding-start: 40px;    list-style: none;}.latte-rightMenu .latte-rightMenuList, .latte-rightMenu .latte-rightMenuNode {    margin: 0;    padding: 0;}.latte-rightMenu {    width: 150px;    border: 1px solid #ccc;    border-bottom: none;    position: absolute;    background-color: #dddddd;    z-index: 1000;}.latte-rightMenu .latte-rightMenuList {	list-style : none;}.latte-rightMenu  .latte-rightMenuNode {    border-bottom: 1px solid #ccc;    padding: 5px 10px;    cursor: pointer;}.latte-rightMenu  .latte-rightMenuNode:hover{    background-color: #ccc;}';
 	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });

(function(define) {'use strict'
	define("latte_view/view/h5/rightMenu.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		(function() {
			this.lade = require('./rightMenu.lade');
			this.css = __dirname + '/rightMenu.css';
			this.data = {
				show: false,
				left: 0,
				top: 0,
				nodes: []
			};
			this.tag = "rightMenu";
		}).call(module.exports);
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/view/h5/rightMenu.lade", ["require", "exports", "module", "window","__filename", "__dirname"],
 	function(require, exports, module, window, __filename, __dirname) {
 		module.exports = 'latte.latte-rightMenu (show:"{{show}}", top:"{{top}}",left:"{{left}}")\n	ul.latte-rightMenuList (list:"nodes")\n		li.latte-rightMenuNode (click:"click", text:"{{text}}", glass:"{{type}}")'
 	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });

(function(define) {'use strict'
	define("latte_view/view/h5/tab.css", ["require", "exports", "module", "window","__filename", "__dirname"],
 	function(require, exports, module, window, __filename, __dirname) {
 		module.exports = '.latte_tab {}';
 	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });

(function(define) {'use strict'
	define("latte_view/view/h5/tab.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		(function() {
			this.lade = require('./tab.lade');
			this.css = __dirname + '/tab.css';
			this.data = {
				tabs: [],
				tabIndex: 0,
				click: function(event, view) {
					if(view.latte("click") != "tabHeaderClick") {
						return;
					}
					var data = view.controller.data;
					var index = this.get('tabs').indexOf(data);
					if(index == -1) {
						return;
					}
					this.set('tabIndex', index); 
				}
			};
			this.dataChanges = {
				tabIndex: function(nowIndex, oldIndex) {
					if(!this.get("tabs") || this.get("tabs") .length <= nowIndex) {
						return;
					}
					var self = this;
					if(oldIndex !== undefined) {
						self.get("tabs").get(oldIndex).set("selected", "");
					}
					self.get("tabs").get(nowIndex).set("selected", "is-actived");
				}
		
			};
			this.tag = "tab";
		}).call(module.exports);
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/view/h5/tab.lade", ["require", "exports", "module", "window","__filename", "__dirname"],
 	function(require, exports, module, window, __filename, __dirname) {
 		module.exports = 'latte.latte-tabs \n	latte.latte-tabs-header (click:"click", rightClick:"headRightClick")\n		latte.latte-tabs-nav-wrap \n			latte.latte-tabs-nav-scroll \n				latte.latte-tabs-nav (list:"tabs")\n					latte.latte-tabs-item (glass:"{{selected}}", click:"tabHeaderClick", rightClick:"tabHeadRightClick",text:"{{name}}") \n	latte.latte-tabs-body (rightClick:"bodyRightClick")\n		latte (list:"tabs")\n			latte (show: "!!{{selected}}", view: "view")\n				'
 	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });

(function(define) {'use strict'
	define("latte_view/view/h5View.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		var View = require('./index.js');
		var latte_lib = require('latte_lib');
		var Loader = require('../loader');
		var H5View = function(dom, latte) {
			this._latte = latte;
			this.dom = dom;
			dom.view = this;
			this.children  = [];
			for(var i = 0,len = this.dom.children.length; i < len; i++) {
				var c = this.dom.children[i];
				this.children.push(new H5View(c));
			}
			this.domEvents = {
		
			};
			this.preDisplayStyle = undefined;
			this.type = 'h5View';
		};
		latte_lib.extends(H5View, View);
		(function() {
			this.src = function(value) {
				if(value) {
					this.attr('src', value);
				}else{
					return this.attr('src');
				}
			}
			this.scrollTop = function(value) {
				if(value == null) {
					return this.dom.scrollTop;
				}
				this.dom.scrollTop = value;
			}
			this.clone = function() {
				var dom = this.dom.cloneNode(true);
				return new H5View(dom);
			}
			this.hide = function() {
				this.dom.style.display = "none";
			}
			this.show = function() {
				this.dom.style.display = "";
			}
			this.top = function(value) {
				if(value == null) {
					return this.dom.style.top;
				}
				if(isNaN(value - 0)){
					this.dom.style.top = value;
				}else{
					this.dom.style.top = value + 'px';
				}
			}
			this.left = function(value) {
				if(value == null) {
					return this.dom.style.left;
				}
				if(isNaN(value - 0)){
					this.dom.style.left = value;
				}else{
					this.dom.style.left = value + 'px';
				}
			}
			this.right = function(value) {
				if(value == null) {
					return this.dom.style.right;
				}
				if(isNaN(value - 0)){
					this.dom.style.right = value;
				}else{
					this.dom.style.right = value + 'px';
				}
			}
			this.bottom = function(value) {
				if(value == null) {
					return this.dom.style.bottom;
				}
				if(isNaN(value - 0)){
					this.dom.style.bottom = value;
				}else{
					this.dom.style.bottom = value + 'px';
				}
			}
			this.width = function(value) {
				if(isNaN(value - 0)){
					this.dom.style.width = value;
				}else{
					this.dom.style.width = value + 'px';
				}
			}
			this.height = function(value) {
				if(isNaN(value - 0)){
					this.dom.style.height = value;
				}else{
					this.dom.style.height = value + 'px';
				}
			}
			this.on = function(key, value, opts) {
				if(!this.domEvents[key]) {
					this.domEvents[key] = {
						before: [],
						after: []
					};
					var self = this;
					this.dom.addEventListener(key, function(event) {
						self.domEvents[key].before.forEach(function(f) {
							f(event);
						});
					}, true);
					this.dom.addEventListener(key, function(event) {
						self.domEvents[key].after.forEach(function(f) {
							f(event);
						});
					});
				}
				var array = this.domEvents[key][opts?'before':'after'];
				var index = array.indexOf(value);
				if(index != -1) {
					return;
				}
				array.push(value);
				
			}
			this.off = function(key, value, opts) {
				if(!this.domEvents[key]) {
					return;
				}
				var array = this.domEvents[key][opts?'before':'after'];
				var index = array.indexOf(value);
				if(index == -1) {
					return;
				}
				array.splice(index, 1);
		
			}
			Object.defineProperty(this, 'id', {
				set: function(id) {
					this.dom.id = id;
				},
				get: function() {
					return this.dom.id;
				}
			});
			this.attr = function(key, value) {
		
				if(value === undefined) {
					if(latte_lib.isString(key)) {
						return this.dom.getAttribute(key);
					}else{
						for(var i in key) {
							this.dom.setAttribute(i, key[i]);
						}
					}
				}else{
					this.dom.setAttribute(key, value);
				}
			}
			this.latte = function(key, value) {
				var self = this;
				if(value === undefined) {
					if(latte_lib.isString(key)) {
						return this.dom.getAttribute('latte-' + key);
					}else{
						for(var i in key) {
							this.dom.setAttribute('latte-' + i, key[i]);
						}
					}
				}else{
					this.dom.setAttribute('latte-' + key, value);
				}
			}
			var requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
			var requote = function(s) {
		    	return s.replace(requote_re, "\\$&");
		  	};
			var classedRe = function(name) {
		   		return new RegExp("(?:^|\\s+)" + requote(name) + "(?:\\s+|$)", "g");
		  	}
		  	this.lcssClass = function(key) {
		  		if(key) {
		  			this.dom.className = key;
		  		}else{
		  			return this.dom.className;
		  		}
		  	}
		  	var getClassName = function(dom) {
		  		if(latte_lib.isString(dom.className)) {
		  			return dom.className;
		  		}else{
		  			return dom.getAttribute('class') || "";
		  		}
		  	}
		  	var setClassName = function(dom, str) {
		  		if(latte_lib.isString(dom.className)) {
		  			dom.className = str;
		  		}else{
		  			dom.setAttribute('class', str);
		  		}
		  	}
			this.classed = function(key, value) {
				if(key == undefined) {
					return this.dom.className;
				}
				var self = this;
				var set = function(k, v) {
					if(!value){
						setClassName(self.dom, getClassName(self.dom).replace(classedRe(k), ' '));
					}else{
						setClassName(self.dom, getClassName(self.dom).replace(classedRe(k), ' ') + ' ' + k);
					}
				}
				if(value == undefined) {
					if(latte_lib.isString(key)) {
						return classedRe(key).test(this.dom.className);
					}else{
						for(var i in key) {
							set(i, key[i]);
						}
					}
					
				}else {
					set(key, value);
				}
			}
			this.text = function(value) {
				if(value == undefined) {
					return this.dom.text;
				}else{
					this.dom.textContent = value;
				}
			}
			this.style = function(key, value) {
				if(value == undefined) {
					if(latte_lib.isString(key)) {
						return this.dom.style[key];
					}else{
						for(var i in key) {
							this.dom.style[key] = key[i];
						}
					}
					
				}else{
					this.dom.style[key] = value;
				}
			}
			this.insertBefore = function(o, c) {
				o = H5View.create(o);
				var index = this.children.indexOf(o);
				if(index != -1) {
					return;
				}
				c = H5View.create(c);
				index = this.children.indexOf(c);
				if(index == -1) {
					return;
				}
				this.children.splice(index, 0 , o);
				this.dom.insertBefore(o.dom, c.dom);
			}
			this.appendChild = function(o) {
				/*if(H5View.isDom(o)) {
					this.dom.appendChild(o);
					if(o.view) {
						this.children.push(o.view);
					}else{
						this.children.push(new H5View(o));
					}
				}else if(H5View.isView(o)) {
					this.dom.appendChild(o.dom);
					this.children.push(o);
				}*/
				var o = H5View.create(o);
				var index = this.children.indexOf(o);
				if(index != -1) {
					return;
				}
				this.dom.appendChild(o.dom);
				this.children.push(o);
			}
			this.removeChild = function(o) {
				/*if(H5View.isDom(o)) {
					this.dom.removeChild(o);
					latte_lib.remove(this.children, o.view);
				}else if(H5View.isView(o)) {
					this.dom.removeChild(o.dom);
					latte_lib.remove(this.children, o);
				}
				this.dom.removeChild(o);*/
				if(H5View.isDom(o)) {
					o = o.view;
				}
				if(!H5View.isView(o)) {
					return;
				}
				var index = this.children.indexOf(o);
				if(index == -1) {
					return;
				}
				this.dom.removeChild(o.dom);
				this.children.splice(index, 1);
			}
			this.removeAll = function() {
				this.dom.html = '';
			}
			this.getRoot = function() {
				return H5View.root;
			}
			this.value = function(value) {
				if(value == undefined) {
					return this.dom.value;
				}else{
					this.dom.value = value;
				}
			}
			this.getTag = function() {
				return this.dom.tagName || this._latte.tag;
			}
		
		}).call(H5View.prototype);
		(function() {
			this.create = function(dom) {
				var Latte = require('../latte/index');
				if(H5View.isView(dom)) {
					return dom;
				}else if(H5View.isDom(dom)) {
					if(dom.view) {
						return dom.view;
					}
					//latte = H5View.createLatte(dom);
					var view = new H5View(dom);
					return view;
				}else if(Latte.isLatte(dom)) {
					var latte = dom;
					return H5View.createDom(latte);
				}
				
			}
			this.isDom = HTMLElement ? (( typeof HTMLElement === 'object' ) ?
			    function(obj){
			        return obj instanceof HTMLElement;
			    } :
			    function(obj){
			        return obj && typeof obj === 'object' && obj.nodeType === 1 && typeof obj.nodeName === 'string';
			    }): null;
			this.isView = function(obj) {
				return obj instanceof H5View;
			}
			var nsPrefix = {
			    svg: "http://www.w3.org/2000/svg",
			    xhtml: "http://www.w3.org/1999/xhtml",
			    xlink: "http://www.w3.org/1999/xlink",
			    xml: "http://www.w3.org/XML/1998/namespace",
			    xmlns: "http://www.w3.org/2000/xmlns/"
		  	};
			this.createElement = function(tag, ns) {
			    return document.createElementNS ?
			           document.createElementNS(ns ||  nsPrefix['xhtml'], tag) :
			           document.createElement(tag);
			};
			this.createDom = function(latte) {
				latte.ns = nsPrefix[latte.tag] || latte.ns || "";
				var dom = H5View.createElement(latte.tag, latte.ns);
				var view = new H5View(dom, latte);
				view.attr('id', latte.id);
				latte.classed().forEach(function(c) {
					view.classed(c, 1);
				});
				view.attr(latte.attr());
				view.style(latte.style());
				view.latte(latte.latte());
				view.text(latte.text());
				latte.children.forEach(function(c) {
					c.ns = latte.ns;
					var v = H5View.createDom(c);
					view.appendChild(v);
				});
				return view;
			}
			var hasCssString = function(id, doc) {
				var index = 0, sheets;
				doc = doc || document;
				if(doc.createStyleSheet && (sheets = doc.styleSheets)) {
					while(index < sheets.length) {
						if(sheets[index++].owningElement.id==id) {
							return true;
						}
					}
				}else if((sheets = doc.getElementsByTagName("style"))) {
					while(index < sheets.length) {
						if(sheets[index++].id === id) {
							return true;
						}
					}
				}
				return false;
			}
			var getDocumentHead = function(doc) {
				if(!doc) {
					doc = document;
				}
				return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
			}
			this.loadCss = function(url, id, doc) {
				doc = doc || document;
				id = id || url;
				if(id && hasCssString(id, doc)) {
					return null;
				}
				var style;
				if(doc.createStyleSheet) {
					style = doc.createStyleSheet();
					style.owningElement.id = id;
					Loader.loadFile(url, function(err, cssText) {
						if(err) {
							return;
						}
						style.cssText = cssText;
					});
				}else{
					style = document.createElement("style");
					style.id = id;
					getDocumentHead(doc).appendChild(style);
					Loader.loadFile(url, function(err, cssText) {
						if(err) {
							return;
						}
						style.appendChild(doc.createTextNode(cssText));
					});
				}
			}
			var lackComponentList = {};
			var componentMap = {};
			var loadComponent = {};
		
			this.addComponent = function(component) {
				var load = function(cb) {
					H5View.loadCss(component.css);
					component.latte = H5View.parseLatte(component.lade);
					componentMap[component.tag] = component;
					cb();
					/*Latte.addComponent(component, function(err) {
						if(err) {
							return cb();
						}
						componentMap[component.tag] = component;
						cb();
					});*/
				};
				if(component.requires) {
					component.requires.forEach(function(r) {
						if(!loadComponent[r]) {
							lackComponentList[r] = 1;
						}
					});
				}
				delete lackComponentList[component.tag];
				loadComponent[component.tag] = component.requires? component.requires.push(load): load;
			}
			this.initComponent = function(callback) {
				var keys = Object.keys(lackComponentList);
				if(keys.length > 0) {
					return callback(new Error(keys.join(',') + " component not registered"));
				}
				latte_lib.async.auto(loadComponent, function(err, data) {
					if(err) {
						return callback(err);
					}
					loadComponent = null;
					callback && callback();
				});
			}
			this.getComponent = function(id) {
				return componentMap[id];
			}
			this.parseLatte = function(str) {
				var Latte = require('../latte');
				return Latte.create(str, componentMap);
			}
			var files = ['editor.js','rightMenu.js', 'fileTree.js', "tab.js", "dialog.js"];
			files.forEach(function(o) {
				H5View.addComponent(require('./h5/' + o));
			});
			this.root = new H5View(document);
			this.getComponents = function() {
				return componentMap;
			};
		}).call(H5View);
		module.exports = H5View;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });
(function(define) {'use strict'
	define("latte_view/view/index.js", ["require", "exports", "module", "window","__filename", "__dirname"], function(require, exports, module, window, __filename, __dirname) {
		
		var latte_lib = require('latte_lib');
		var View = function(dom) {
			
		};
		latte_lib.extends(View, latte_lib.events);
		(function() {
			this.attr = function() {
		
			}
			this.latte = function() {
		
			}
			this.classed = function(name, value) {
		
			}
			this.text = function(name, value) {
		
			}
			/*Object.defineProperty(this, "children" , {
				get: function() {
					return this.dom.children;
				}
			});*/
			this.insertBefore = function(o) {
		
			}
			this.appendChild = function(o) {
		
			}
			this.removeChild = function() {
		
			}
			this.removeAll = function() {
		
			}
			this.clone = function() {
		
			}
			
		}).call(View.prototype);
		module.exports = View;
	});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });